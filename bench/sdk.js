var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// gen/front_end/core/sdk/FrameAssociated.js
var require_FrameAssociated = __commonJS({
  "gen/front_end/core/sdk/FrameAssociated.js"() {
    "use strict";
  }
});

// gen/front_end/core/sdk/SDKModel.js
var SDKModel_exports = {};
__export(SDKModel_exports, {
  SDKModel: () => SDKModel
});
import * as Common from "./../common/common.js";
var registeredModels = /* @__PURE__ */ new Map();
var SDKModel = class extends Common.ObjectWrapper.ObjectWrapper {
  #targetInternal;
  constructor(target) {
    super();
    this.#targetInternal = target;
  }
  target() {
    return this.#targetInternal;
  }
  /**
   * Override this method to perform tasks that are required to suspend the
   * model and that still need other models in an unsuspended state.
   */
  async preSuspendModel(_reason) {
  }
  async suspendModel(_reason) {
  }
  async resumeModel() {
  }
  /**
   * Override this method to perform tasks that are required to after resuming
   * the model and that require all models already in an unsuspended state.
   */
  async postResumeModel() {
  }
  dispose() {
  }
  static register(modelClass, registrationInfo) {
    if (registrationInfo.early && !registrationInfo.autostart) {
      throw new Error(`Error registering model ${modelClass.name}: early models must be autostarted.`);
    }
    registeredModels.set(modelClass, registrationInfo);
  }
  static get registeredModels() {
    return registeredModels;
  }
};

// gen/front_end/core/sdk/CSSMetadata.js
var CSSMetadata_exports = {};
__export(CSSMetadata_exports, {
  CSSMetadata: () => CSSMetadata,
  CSSWideKeyword: () => CSSWideKeyword,
  CSSWideKeywords: () => CSSWideKeywords,
  CustomVariableRegex: () => CustomVariableRegex,
  GridAreaRowRegex: () => GridAreaRowRegex,
  PositionTryOrderKeyword: () => PositionTryOrderKeyword,
  PositionTryOrderKeywords: () => PositionTryOrderKeywords,
  URLRegex: () => URLRegex,
  VariableNameRegex: () => VariableNameRegex,
  VariableRegex: () => VariableRegex,
  cssMetadata: () => cssMetadata
});

// gen/front_end/generated/protocol.js
var Accessibility;
((Accessibility2) => {
  let AXValueType;
  ((AXValueType2) => {
    AXValueType2["Boolean"] = "boolean";
    AXValueType2["Tristate"] = "tristate";
    AXValueType2["BooleanOrUndefined"] = "booleanOrUndefined";
    AXValueType2["Idref"] = "idref";
    AXValueType2["IdrefList"] = "idrefList";
    AXValueType2["Integer"] = "integer";
    AXValueType2["Node"] = "node";
    AXValueType2["NodeList"] = "nodeList";
    AXValueType2["Number"] = "number";
    AXValueType2["String"] = "string";
    AXValueType2["ComputedString"] = "computedString";
    AXValueType2["Token"] = "token";
    AXValueType2["TokenList"] = "tokenList";
    AXValueType2["DomRelation"] = "domRelation";
    AXValueType2["Role"] = "role";
    AXValueType2["InternalRole"] = "internalRole";
    AXValueType2["ValueUndefined"] = "valueUndefined";
  })(AXValueType = Accessibility2.AXValueType || (Accessibility2.AXValueType = {}));
  let AXValueSourceType;
  ((AXValueSourceType2) => {
    AXValueSourceType2["Attribute"] = "attribute";
    AXValueSourceType2["Implicit"] = "implicit";
    AXValueSourceType2["Style"] = "style";
    AXValueSourceType2["Contents"] = "contents";
    AXValueSourceType2["Placeholder"] = "placeholder";
    AXValueSourceType2["RelatedElement"] = "relatedElement";
  })(AXValueSourceType = Accessibility2.AXValueSourceType || (Accessibility2.AXValueSourceType = {}));
  let AXValueNativeSourceType;
  ((AXValueNativeSourceType2) => {
    AXValueNativeSourceType2["Description"] = "description";
    AXValueNativeSourceType2["Figcaption"] = "figcaption";
    AXValueNativeSourceType2["Label"] = "label";
    AXValueNativeSourceType2["Labelfor"] = "labelfor";
    AXValueNativeSourceType2["Labelwrapped"] = "labelwrapped";
    AXValueNativeSourceType2["Legend"] = "legend";
    AXValueNativeSourceType2["Rubyannotation"] = "rubyannotation";
    AXValueNativeSourceType2["Tablecaption"] = "tablecaption";
    AXValueNativeSourceType2["Title"] = "title";
    AXValueNativeSourceType2["Other"] = "other";
  })(AXValueNativeSourceType = Accessibility2.AXValueNativeSourceType || (Accessibility2.AXValueNativeSourceType = {}));
  let AXPropertyName;
  ((AXPropertyName2) => {
    AXPropertyName2["Actions"] = "actions";
    AXPropertyName2["Busy"] = "busy";
    AXPropertyName2["Disabled"] = "disabled";
    AXPropertyName2["Editable"] = "editable";
    AXPropertyName2["Focusable"] = "focusable";
    AXPropertyName2["Focused"] = "focused";
    AXPropertyName2["Hidden"] = "hidden";
    AXPropertyName2["HiddenRoot"] = "hiddenRoot";
    AXPropertyName2["Invalid"] = "invalid";
    AXPropertyName2["Keyshortcuts"] = "keyshortcuts";
    AXPropertyName2["Settable"] = "settable";
    AXPropertyName2["Roledescription"] = "roledescription";
    AXPropertyName2["Live"] = "live";
    AXPropertyName2["Atomic"] = "atomic";
    AXPropertyName2["Relevant"] = "relevant";
    AXPropertyName2["Root"] = "root";
    AXPropertyName2["Autocomplete"] = "autocomplete";
    AXPropertyName2["HasPopup"] = "hasPopup";
    AXPropertyName2["Level"] = "level";
    AXPropertyName2["Multiselectable"] = "multiselectable";
    AXPropertyName2["Orientation"] = "orientation";
    AXPropertyName2["Multiline"] = "multiline";
    AXPropertyName2["Readonly"] = "readonly";
    AXPropertyName2["Required"] = "required";
    AXPropertyName2["Valuemin"] = "valuemin";
    AXPropertyName2["Valuemax"] = "valuemax";
    AXPropertyName2["Valuetext"] = "valuetext";
    AXPropertyName2["Checked"] = "checked";
    AXPropertyName2["Expanded"] = "expanded";
    AXPropertyName2["Modal"] = "modal";
    AXPropertyName2["Pressed"] = "pressed";
    AXPropertyName2["Selected"] = "selected";
    AXPropertyName2["Activedescendant"] = "activedescendant";
    AXPropertyName2["Controls"] = "controls";
    AXPropertyName2["Describedby"] = "describedby";
    AXPropertyName2["Details"] = "details";
    AXPropertyName2["Errormessage"] = "errormessage";
    AXPropertyName2["Flowto"] = "flowto";
    AXPropertyName2["Labelledby"] = "labelledby";
    AXPropertyName2["Owns"] = "owns";
    AXPropertyName2["Url"] = "url";
  })(AXPropertyName = Accessibility2.AXPropertyName || (Accessibility2.AXPropertyName = {}));
})(Accessibility || (Accessibility = {}));
var Animation;
((Animation2) => {
  let AnimationType;
  ((AnimationType2) => {
    AnimationType2["CSSTransition"] = "CSSTransition";
    AnimationType2["CSSAnimation"] = "CSSAnimation";
    AnimationType2["WebAnimation"] = "WebAnimation";
  })(AnimationType = Animation2.AnimationType || (Animation2.AnimationType = {}));
})(Animation || (Animation = {}));
var Audits;
((Audits2) => {
  let CookieExclusionReason;
  ((CookieExclusionReason2) => {
    CookieExclusionReason2["ExcludeSameSiteUnspecifiedTreatedAsLax"] = "ExcludeSameSiteUnspecifiedTreatedAsLax";
    CookieExclusionReason2["ExcludeSameSiteNoneInsecure"] = "ExcludeSameSiteNoneInsecure";
    CookieExclusionReason2["ExcludeSameSiteLax"] = "ExcludeSameSiteLax";
    CookieExclusionReason2["ExcludeSameSiteStrict"] = "ExcludeSameSiteStrict";
    CookieExclusionReason2["ExcludeInvalidSameParty"] = "ExcludeInvalidSameParty";
    CookieExclusionReason2["ExcludeSamePartyCrossPartyContext"] = "ExcludeSamePartyCrossPartyContext";
    CookieExclusionReason2["ExcludeDomainNonASCII"] = "ExcludeDomainNonASCII";
    CookieExclusionReason2["ExcludeThirdPartyCookieBlockedInFirstPartySet"] = "ExcludeThirdPartyCookieBlockedInFirstPartySet";
    CookieExclusionReason2["ExcludeThirdPartyPhaseout"] = "ExcludeThirdPartyPhaseout";
    CookieExclusionReason2["ExcludePortMismatch"] = "ExcludePortMismatch";
    CookieExclusionReason2["ExcludeSchemeMismatch"] = "ExcludeSchemeMismatch";
  })(CookieExclusionReason = Audits2.CookieExclusionReason || (Audits2.CookieExclusionReason = {}));
  let CookieWarningReason;
  ((CookieWarningReason2) => {
    CookieWarningReason2["WarnSameSiteUnspecifiedCrossSiteContext"] = "WarnSameSiteUnspecifiedCrossSiteContext";
    CookieWarningReason2["WarnSameSiteNoneInsecure"] = "WarnSameSiteNoneInsecure";
    CookieWarningReason2["WarnSameSiteUnspecifiedLaxAllowUnsafe"] = "WarnSameSiteUnspecifiedLaxAllowUnsafe";
    CookieWarningReason2["WarnSameSiteStrictLaxDowngradeStrict"] = "WarnSameSiteStrictLaxDowngradeStrict";
    CookieWarningReason2["WarnSameSiteStrictCrossDowngradeStrict"] = "WarnSameSiteStrictCrossDowngradeStrict";
    CookieWarningReason2["WarnSameSiteStrictCrossDowngradeLax"] = "WarnSameSiteStrictCrossDowngradeLax";
    CookieWarningReason2["WarnSameSiteLaxCrossDowngradeStrict"] = "WarnSameSiteLaxCrossDowngradeStrict";
    CookieWarningReason2["WarnSameSiteLaxCrossDowngradeLax"] = "WarnSameSiteLaxCrossDowngradeLax";
    CookieWarningReason2["WarnAttributeValueExceedsMaxSize"] = "WarnAttributeValueExceedsMaxSize";
    CookieWarningReason2["WarnDomainNonASCII"] = "WarnDomainNonASCII";
    CookieWarningReason2["WarnThirdPartyPhaseout"] = "WarnThirdPartyPhaseout";
    CookieWarningReason2["WarnCrossSiteRedirectDowngradeChangesInclusion"] = "WarnCrossSiteRedirectDowngradeChangesInclusion";
    CookieWarningReason2["WarnDeprecationTrialMetadata"] = "WarnDeprecationTrialMetadata";
    CookieWarningReason2["WarnThirdPartyCookieHeuristic"] = "WarnThirdPartyCookieHeuristic";
  })(CookieWarningReason = Audits2.CookieWarningReason || (Audits2.CookieWarningReason = {}));
  let CookieOperation;
  ((CookieOperation2) => {
    CookieOperation2["SetCookie"] = "SetCookie";
    CookieOperation2["ReadCookie"] = "ReadCookie";
  })(CookieOperation = Audits2.CookieOperation || (Audits2.CookieOperation = {}));
  let MixedContentResolutionStatus;
  ((MixedContentResolutionStatus2) => {
    MixedContentResolutionStatus2["MixedContentBlocked"] = "MixedContentBlocked";
    MixedContentResolutionStatus2["MixedContentAutomaticallyUpgraded"] = "MixedContentAutomaticallyUpgraded";
    MixedContentResolutionStatus2["MixedContentWarning"] = "MixedContentWarning";
  })(MixedContentResolutionStatus = Audits2.MixedContentResolutionStatus || (Audits2.MixedContentResolutionStatus = {}));
  let MixedContentResourceType;
  ((MixedContentResourceType2) => {
    MixedContentResourceType2["AttributionSrc"] = "AttributionSrc";
    MixedContentResourceType2["Audio"] = "Audio";
    MixedContentResourceType2["Beacon"] = "Beacon";
    MixedContentResourceType2["CSPReport"] = "CSPReport";
    MixedContentResourceType2["Download"] = "Download";
    MixedContentResourceType2["EventSource"] = "EventSource";
    MixedContentResourceType2["Favicon"] = "Favicon";
    MixedContentResourceType2["Font"] = "Font";
    MixedContentResourceType2["Form"] = "Form";
    MixedContentResourceType2["Frame"] = "Frame";
    MixedContentResourceType2["Image"] = "Image";
    MixedContentResourceType2["Import"] = "Import";
    MixedContentResourceType2["JSON"] = "JSON";
    MixedContentResourceType2["Manifest"] = "Manifest";
    MixedContentResourceType2["Ping"] = "Ping";
    MixedContentResourceType2["PluginData"] = "PluginData";
    MixedContentResourceType2["PluginResource"] = "PluginResource";
    MixedContentResourceType2["Prefetch"] = "Prefetch";
    MixedContentResourceType2["Resource"] = "Resource";
    MixedContentResourceType2["Script"] = "Script";
    MixedContentResourceType2["ServiceWorker"] = "ServiceWorker";
    MixedContentResourceType2["SharedWorker"] = "SharedWorker";
    MixedContentResourceType2["SpeculationRules"] = "SpeculationRules";
    MixedContentResourceType2["Stylesheet"] = "Stylesheet";
    MixedContentResourceType2["Track"] = "Track";
    MixedContentResourceType2["Video"] = "Video";
    MixedContentResourceType2["Worker"] = "Worker";
    MixedContentResourceType2["XMLHttpRequest"] = "XMLHttpRequest";
    MixedContentResourceType2["XSLT"] = "XSLT";
  })(MixedContentResourceType = Audits2.MixedContentResourceType || (Audits2.MixedContentResourceType = {}));
  let BlockedByResponseReason;
  ((BlockedByResponseReason2) => {
    BlockedByResponseReason2["CoepFrameResourceNeedsCoepHeader"] = "CoepFrameResourceNeedsCoepHeader";
    BlockedByResponseReason2["CoopSandboxedIFrameCannotNavigateToCoopPage"] = "CoopSandboxedIFrameCannotNavigateToCoopPage";
    BlockedByResponseReason2["CorpNotSameOrigin"] = "CorpNotSameOrigin";
    BlockedByResponseReason2["CorpNotSameOriginAfterDefaultedToSameOriginByCoep"] = "CorpNotSameOriginAfterDefaultedToSameOriginByCoep";
    BlockedByResponseReason2["CorpNotSameOriginAfterDefaultedToSameOriginByDip"] = "CorpNotSameOriginAfterDefaultedToSameOriginByDip";
    BlockedByResponseReason2["CorpNotSameOriginAfterDefaultedToSameOriginByCoepAndDip"] = "CorpNotSameOriginAfterDefaultedToSameOriginByCoepAndDip";
    BlockedByResponseReason2["CorpNotSameSite"] = "CorpNotSameSite";
  })(BlockedByResponseReason = Audits2.BlockedByResponseReason || (Audits2.BlockedByResponseReason = {}));
  let HeavyAdResolutionStatus;
  ((HeavyAdResolutionStatus2) => {
    HeavyAdResolutionStatus2["HeavyAdBlocked"] = "HeavyAdBlocked";
    HeavyAdResolutionStatus2["HeavyAdWarning"] = "HeavyAdWarning";
  })(HeavyAdResolutionStatus = Audits2.HeavyAdResolutionStatus || (Audits2.HeavyAdResolutionStatus = {}));
  let HeavyAdReason;
  ((HeavyAdReason2) => {
    HeavyAdReason2["NetworkTotalLimit"] = "NetworkTotalLimit";
    HeavyAdReason2["CpuTotalLimit"] = "CpuTotalLimit";
    HeavyAdReason2["CpuPeakLimit"] = "CpuPeakLimit";
  })(HeavyAdReason = Audits2.HeavyAdReason || (Audits2.HeavyAdReason = {}));
  let ContentSecurityPolicyViolationType;
  ((ContentSecurityPolicyViolationType2) => {
    ContentSecurityPolicyViolationType2["KInlineViolation"] = "kInlineViolation";
    ContentSecurityPolicyViolationType2["KEvalViolation"] = "kEvalViolation";
    ContentSecurityPolicyViolationType2["KURLViolation"] = "kURLViolation";
    ContentSecurityPolicyViolationType2["KTrustedTypesSinkViolation"] = "kTrustedTypesSinkViolation";
    ContentSecurityPolicyViolationType2["KTrustedTypesPolicyViolation"] = "kTrustedTypesPolicyViolation";
    ContentSecurityPolicyViolationType2["KWasmEvalViolation"] = "kWasmEvalViolation";
  })(ContentSecurityPolicyViolationType = Audits2.ContentSecurityPolicyViolationType || (Audits2.ContentSecurityPolicyViolationType = {}));
  let SharedArrayBufferIssueType;
  ((SharedArrayBufferIssueType2) => {
    SharedArrayBufferIssueType2["TransferIssue"] = "TransferIssue";
    SharedArrayBufferIssueType2["CreationIssue"] = "CreationIssue";
  })(SharedArrayBufferIssueType = Audits2.SharedArrayBufferIssueType || (Audits2.SharedArrayBufferIssueType = {}));
  let AttributionReportingIssueType;
  ((AttributionReportingIssueType2) => {
    AttributionReportingIssueType2["PermissionPolicyDisabled"] = "PermissionPolicyDisabled";
    AttributionReportingIssueType2["UntrustworthyReportingOrigin"] = "UntrustworthyReportingOrigin";
    AttributionReportingIssueType2["InsecureContext"] = "InsecureContext";
    AttributionReportingIssueType2["InvalidHeader"] = "InvalidHeader";
    AttributionReportingIssueType2["InvalidRegisterTriggerHeader"] = "InvalidRegisterTriggerHeader";
    AttributionReportingIssueType2["SourceAndTriggerHeaders"] = "SourceAndTriggerHeaders";
    AttributionReportingIssueType2["SourceIgnored"] = "SourceIgnored";
    AttributionReportingIssueType2["TriggerIgnored"] = "TriggerIgnored";
    AttributionReportingIssueType2["OsSourceIgnored"] = "OsSourceIgnored";
    AttributionReportingIssueType2["OsTriggerIgnored"] = "OsTriggerIgnored";
    AttributionReportingIssueType2["InvalidRegisterOsSourceHeader"] = "InvalidRegisterOsSourceHeader";
    AttributionReportingIssueType2["InvalidRegisterOsTriggerHeader"] = "InvalidRegisterOsTriggerHeader";
    AttributionReportingIssueType2["WebAndOsHeaders"] = "WebAndOsHeaders";
    AttributionReportingIssueType2["NoWebOrOsSupport"] = "NoWebOrOsSupport";
    AttributionReportingIssueType2["NavigationRegistrationWithoutTransientUserActivation"] = "NavigationRegistrationWithoutTransientUserActivation";
    AttributionReportingIssueType2["InvalidInfoHeader"] = "InvalidInfoHeader";
    AttributionReportingIssueType2["NoRegisterSourceHeader"] = "NoRegisterSourceHeader";
    AttributionReportingIssueType2["NoRegisterTriggerHeader"] = "NoRegisterTriggerHeader";
    AttributionReportingIssueType2["NoRegisterOsSourceHeader"] = "NoRegisterOsSourceHeader";
    AttributionReportingIssueType2["NoRegisterOsTriggerHeader"] = "NoRegisterOsTriggerHeader";
    AttributionReportingIssueType2["NavigationRegistrationUniqueScopeAlreadySet"] = "NavigationRegistrationUniqueScopeAlreadySet";
  })(AttributionReportingIssueType = Audits2.AttributionReportingIssueType || (Audits2.AttributionReportingIssueType = {}));
  let SharedDictionaryError;
  ((SharedDictionaryError2) => {
    SharedDictionaryError2["UseErrorCrossOriginNoCorsRequest"] = "UseErrorCrossOriginNoCorsRequest";
    SharedDictionaryError2["UseErrorDictionaryLoadFailure"] = "UseErrorDictionaryLoadFailure";
    SharedDictionaryError2["UseErrorMatchingDictionaryNotUsed"] = "UseErrorMatchingDictionaryNotUsed";
    SharedDictionaryError2["UseErrorUnexpectedContentDictionaryHeader"] = "UseErrorUnexpectedContentDictionaryHeader";
    SharedDictionaryError2["WriteErrorCossOriginNoCorsRequest"] = "WriteErrorCossOriginNoCorsRequest";
    SharedDictionaryError2["WriteErrorDisallowedBySettings"] = "WriteErrorDisallowedBySettings";
    SharedDictionaryError2["WriteErrorExpiredResponse"] = "WriteErrorExpiredResponse";
    SharedDictionaryError2["WriteErrorFeatureDisabled"] = "WriteErrorFeatureDisabled";
    SharedDictionaryError2["WriteErrorInsufficientResources"] = "WriteErrorInsufficientResources";
    SharedDictionaryError2["WriteErrorInvalidMatchField"] = "WriteErrorInvalidMatchField";
    SharedDictionaryError2["WriteErrorInvalidStructuredHeader"] = "WriteErrorInvalidStructuredHeader";
    SharedDictionaryError2["WriteErrorNavigationRequest"] = "WriteErrorNavigationRequest";
    SharedDictionaryError2["WriteErrorNoMatchField"] = "WriteErrorNoMatchField";
    SharedDictionaryError2["WriteErrorNonListMatchDestField"] = "WriteErrorNonListMatchDestField";
    SharedDictionaryError2["WriteErrorNonSecureContext"] = "WriteErrorNonSecureContext";
    SharedDictionaryError2["WriteErrorNonStringIdField"] = "WriteErrorNonStringIdField";
    SharedDictionaryError2["WriteErrorNonStringInMatchDestList"] = "WriteErrorNonStringInMatchDestList";
    SharedDictionaryError2["WriteErrorNonStringMatchField"] = "WriteErrorNonStringMatchField";
    SharedDictionaryError2["WriteErrorNonTokenTypeField"] = "WriteErrorNonTokenTypeField";
    SharedDictionaryError2["WriteErrorRequestAborted"] = "WriteErrorRequestAborted";
    SharedDictionaryError2["WriteErrorShuttingDown"] = "WriteErrorShuttingDown";
    SharedDictionaryError2["WriteErrorTooLongIdField"] = "WriteErrorTooLongIdField";
    SharedDictionaryError2["WriteErrorUnsupportedType"] = "WriteErrorUnsupportedType";
  })(SharedDictionaryError = Audits2.SharedDictionaryError || (Audits2.SharedDictionaryError = {}));
  let GenericIssueErrorType;
  ((GenericIssueErrorType2) => {
    GenericIssueErrorType2["FormLabelForNameError"] = "FormLabelForNameError";
    GenericIssueErrorType2["FormDuplicateIdForInputError"] = "FormDuplicateIdForInputError";
    GenericIssueErrorType2["FormInputWithNoLabelError"] = "FormInputWithNoLabelError";
    GenericIssueErrorType2["FormAutocompleteAttributeEmptyError"] = "FormAutocompleteAttributeEmptyError";
    GenericIssueErrorType2["FormEmptyIdAndNameAttributesForInputError"] = "FormEmptyIdAndNameAttributesForInputError";
    GenericIssueErrorType2["FormAriaLabelledByToNonExistingId"] = "FormAriaLabelledByToNonExistingId";
    GenericIssueErrorType2["FormInputAssignedAutocompleteValueToIdOrNameAttributeError"] = "FormInputAssignedAutocompleteValueToIdOrNameAttributeError";
    GenericIssueErrorType2["FormLabelHasNeitherForNorNestedInput"] = "FormLabelHasNeitherForNorNestedInput";
    GenericIssueErrorType2["FormLabelForMatchesNonExistingIdError"] = "FormLabelForMatchesNonExistingIdError";
    GenericIssueErrorType2["FormInputHasWrongButWellIntendedAutocompleteValueError"] = "FormInputHasWrongButWellIntendedAutocompleteValueError";
    GenericIssueErrorType2["ResponseWasBlockedByORB"] = "ResponseWasBlockedByORB";
  })(GenericIssueErrorType = Audits2.GenericIssueErrorType || (Audits2.GenericIssueErrorType = {}));
  let ClientHintIssueReason;
  ((ClientHintIssueReason2) => {
    ClientHintIssueReason2["MetaTagAllowListInvalidOrigin"] = "MetaTagAllowListInvalidOrigin";
    ClientHintIssueReason2["MetaTagModifiedHTML"] = "MetaTagModifiedHTML";
  })(ClientHintIssueReason = Audits2.ClientHintIssueReason || (Audits2.ClientHintIssueReason = {}));
  let FederatedAuthRequestIssueReason;
  ((FederatedAuthRequestIssueReason2) => {
    FederatedAuthRequestIssueReason2["ShouldEmbargo"] = "ShouldEmbargo";
    FederatedAuthRequestIssueReason2["TooManyRequests"] = "TooManyRequests";
    FederatedAuthRequestIssueReason2["WellKnownHttpNotFound"] = "WellKnownHttpNotFound";
    FederatedAuthRequestIssueReason2["WellKnownNoResponse"] = "WellKnownNoResponse";
    FederatedAuthRequestIssueReason2["WellKnownInvalidResponse"] = "WellKnownInvalidResponse";
    FederatedAuthRequestIssueReason2["WellKnownListEmpty"] = "WellKnownListEmpty";
    FederatedAuthRequestIssueReason2["WellKnownInvalidContentType"] = "WellKnownInvalidContentType";
    FederatedAuthRequestIssueReason2["ConfigNotInWellKnown"] = "ConfigNotInWellKnown";
    FederatedAuthRequestIssueReason2["WellKnownTooBig"] = "WellKnownTooBig";
    FederatedAuthRequestIssueReason2["ConfigHttpNotFound"] = "ConfigHttpNotFound";
    FederatedAuthRequestIssueReason2["ConfigNoResponse"] = "ConfigNoResponse";
    FederatedAuthRequestIssueReason2["ConfigInvalidResponse"] = "ConfigInvalidResponse";
    FederatedAuthRequestIssueReason2["ConfigInvalidContentType"] = "ConfigInvalidContentType";
    FederatedAuthRequestIssueReason2["ClientMetadataHttpNotFound"] = "ClientMetadataHttpNotFound";
    FederatedAuthRequestIssueReason2["ClientMetadataNoResponse"] = "ClientMetadataNoResponse";
    FederatedAuthRequestIssueReason2["ClientMetadataInvalidResponse"] = "ClientMetadataInvalidResponse";
    FederatedAuthRequestIssueReason2["ClientMetadataInvalidContentType"] = "ClientMetadataInvalidContentType";
    FederatedAuthRequestIssueReason2["IdpNotPotentiallyTrustworthy"] = "IdpNotPotentiallyTrustworthy";
    FederatedAuthRequestIssueReason2["DisabledInSettings"] = "DisabledInSettings";
    FederatedAuthRequestIssueReason2["DisabledInFlags"] = "DisabledInFlags";
    FederatedAuthRequestIssueReason2["ErrorFetchingSignin"] = "ErrorFetchingSignin";
    FederatedAuthRequestIssueReason2["InvalidSigninResponse"] = "InvalidSigninResponse";
    FederatedAuthRequestIssueReason2["AccountsHttpNotFound"] = "AccountsHttpNotFound";
    FederatedAuthRequestIssueReason2["AccountsNoResponse"] = "AccountsNoResponse";
    FederatedAuthRequestIssueReason2["AccountsInvalidResponse"] = "AccountsInvalidResponse";
    FederatedAuthRequestIssueReason2["AccountsListEmpty"] = "AccountsListEmpty";
    FederatedAuthRequestIssueReason2["AccountsInvalidContentType"] = "AccountsInvalidContentType";
    FederatedAuthRequestIssueReason2["IdTokenHttpNotFound"] = "IdTokenHttpNotFound";
    FederatedAuthRequestIssueReason2["IdTokenNoResponse"] = "IdTokenNoResponse";
    FederatedAuthRequestIssueReason2["IdTokenInvalidResponse"] = "IdTokenInvalidResponse";
    FederatedAuthRequestIssueReason2["IdTokenIdpErrorResponse"] = "IdTokenIdpErrorResponse";
    FederatedAuthRequestIssueReason2["IdTokenCrossSiteIdpErrorResponse"] = "IdTokenCrossSiteIdpErrorResponse";
    FederatedAuthRequestIssueReason2["IdTokenInvalidRequest"] = "IdTokenInvalidRequest";
    FederatedAuthRequestIssueReason2["IdTokenInvalidContentType"] = "IdTokenInvalidContentType";
    FederatedAuthRequestIssueReason2["ErrorIdToken"] = "ErrorIdToken";
    FederatedAuthRequestIssueReason2["Canceled"] = "Canceled";
    FederatedAuthRequestIssueReason2["RpPageNotVisible"] = "RpPageNotVisible";
    FederatedAuthRequestIssueReason2["SilentMediationFailure"] = "SilentMediationFailure";
    FederatedAuthRequestIssueReason2["ThirdPartyCookiesBlocked"] = "ThirdPartyCookiesBlocked";
    FederatedAuthRequestIssueReason2["NotSignedInWithIdp"] = "NotSignedInWithIdp";
    FederatedAuthRequestIssueReason2["MissingTransientUserActivation"] = "MissingTransientUserActivation";
    FederatedAuthRequestIssueReason2["ReplacedByActiveMode"] = "ReplacedByActiveMode";
    FederatedAuthRequestIssueReason2["InvalidFieldsSpecified"] = "InvalidFieldsSpecified";
    FederatedAuthRequestIssueReason2["RelyingPartyOriginIsOpaque"] = "RelyingPartyOriginIsOpaque";
    FederatedAuthRequestIssueReason2["TypeNotMatching"] = "TypeNotMatching";
  })(FederatedAuthRequestIssueReason = Audits2.FederatedAuthRequestIssueReason || (Audits2.FederatedAuthRequestIssueReason = {}));
  let FederatedAuthUserInfoRequestIssueReason;
  ((FederatedAuthUserInfoRequestIssueReason2) => {
    FederatedAuthUserInfoRequestIssueReason2["NotSameOrigin"] = "NotSameOrigin";
    FederatedAuthUserInfoRequestIssueReason2["NotIframe"] = "NotIframe";
    FederatedAuthUserInfoRequestIssueReason2["NotPotentiallyTrustworthy"] = "NotPotentiallyTrustworthy";
    FederatedAuthUserInfoRequestIssueReason2["NoAPIPermission"] = "NoApiPermission";
    FederatedAuthUserInfoRequestIssueReason2["NotSignedInWithIdp"] = "NotSignedInWithIdp";
    FederatedAuthUserInfoRequestIssueReason2["NoAccountSharingPermission"] = "NoAccountSharingPermission";
    FederatedAuthUserInfoRequestIssueReason2["InvalidConfigOrWellKnown"] = "InvalidConfigOrWellKnown";
    FederatedAuthUserInfoRequestIssueReason2["InvalidAccountsResponse"] = "InvalidAccountsResponse";
    FederatedAuthUserInfoRequestIssueReason2["NoReturningUserFromFetchedAccounts"] = "NoReturningUserFromFetchedAccounts";
  })(FederatedAuthUserInfoRequestIssueReason = Audits2.FederatedAuthUserInfoRequestIssueReason || (Audits2.FederatedAuthUserInfoRequestIssueReason = {}));
  let StyleSheetLoadingIssueReason;
  ((StyleSheetLoadingIssueReason2) => {
    StyleSheetLoadingIssueReason2["LateImportRule"] = "LateImportRule";
    StyleSheetLoadingIssueReason2["RequestFailed"] = "RequestFailed";
  })(StyleSheetLoadingIssueReason = Audits2.StyleSheetLoadingIssueReason || (Audits2.StyleSheetLoadingIssueReason = {}));
  let PropertyRuleIssueReason;
  ((PropertyRuleIssueReason2) => {
    PropertyRuleIssueReason2["InvalidSyntax"] = "InvalidSyntax";
    PropertyRuleIssueReason2["InvalidInitialValue"] = "InvalidInitialValue";
    PropertyRuleIssueReason2["InvalidInherits"] = "InvalidInherits";
    PropertyRuleIssueReason2["InvalidName"] = "InvalidName";
  })(PropertyRuleIssueReason = Audits2.PropertyRuleIssueReason || (Audits2.PropertyRuleIssueReason = {}));
  let InspectorIssueCode;
  ((InspectorIssueCode2) => {
    InspectorIssueCode2["CookieIssue"] = "CookieIssue";
    InspectorIssueCode2["MixedContentIssue"] = "MixedContentIssue";
    InspectorIssueCode2["BlockedByResponseIssue"] = "BlockedByResponseIssue";
    InspectorIssueCode2["HeavyAdIssue"] = "HeavyAdIssue";
    InspectorIssueCode2["ContentSecurityPolicyIssue"] = "ContentSecurityPolicyIssue";
    InspectorIssueCode2["SharedArrayBufferIssue"] = "SharedArrayBufferIssue";
    InspectorIssueCode2["LowTextContrastIssue"] = "LowTextContrastIssue";
    InspectorIssueCode2["CorsIssue"] = "CorsIssue";
    InspectorIssueCode2["AttributionReportingIssue"] = "AttributionReportingIssue";
    InspectorIssueCode2["QuirksModeIssue"] = "QuirksModeIssue";
    InspectorIssueCode2["NavigatorUserAgentIssue"] = "NavigatorUserAgentIssue";
    InspectorIssueCode2["GenericIssue"] = "GenericIssue";
    InspectorIssueCode2["DeprecationIssue"] = "DeprecationIssue";
    InspectorIssueCode2["ClientHintIssue"] = "ClientHintIssue";
    InspectorIssueCode2["FederatedAuthRequestIssue"] = "FederatedAuthRequestIssue";
    InspectorIssueCode2["BounceTrackingIssue"] = "BounceTrackingIssue";
    InspectorIssueCode2["CookieDeprecationMetadataIssue"] = "CookieDeprecationMetadataIssue";
    InspectorIssueCode2["StylesheetLoadingIssue"] = "StylesheetLoadingIssue";
    InspectorIssueCode2["FederatedAuthUserInfoRequestIssue"] = "FederatedAuthUserInfoRequestIssue";
    InspectorIssueCode2["PropertyRuleIssue"] = "PropertyRuleIssue";
    InspectorIssueCode2["SharedDictionaryIssue"] = "SharedDictionaryIssue";
  })(InspectorIssueCode = Audits2.InspectorIssueCode || (Audits2.InspectorIssueCode = {}));
  let GetEncodedResponseRequestEncoding;
  ((GetEncodedResponseRequestEncoding2) => {
    GetEncodedResponseRequestEncoding2["Webp"] = "webp";
    GetEncodedResponseRequestEncoding2["Jpeg"] = "jpeg";
    GetEncodedResponseRequestEncoding2["Png"] = "png";
  })(GetEncodedResponseRequestEncoding = Audits2.GetEncodedResponseRequestEncoding || (Audits2.GetEncodedResponseRequestEncoding = {}));
})(Audits || (Audits = {}));
var Extensions;
((Extensions2) => {
  let StorageArea;
  ((StorageArea2) => {
    StorageArea2["Session"] = "session";
    StorageArea2["Local"] = "local";
    StorageArea2["Sync"] = "sync";
    StorageArea2["Managed"] = "managed";
  })(StorageArea = Extensions2.StorageArea || (Extensions2.StorageArea = {}));
})(Extensions || (Extensions = {}));
var Autofill;
((Autofill2) => {
  let FillingStrategy;
  ((FillingStrategy2) => {
    FillingStrategy2["AutocompleteAttribute"] = "autocompleteAttribute";
    FillingStrategy2["AutofillInferred"] = "autofillInferred";
  })(FillingStrategy = Autofill2.FillingStrategy || (Autofill2.FillingStrategy = {}));
})(Autofill || (Autofill = {}));
var BackgroundService;
((BackgroundService2) => {
  let ServiceName;
  ((ServiceName2) => {
    ServiceName2["BackgroundFetch"] = "backgroundFetch";
    ServiceName2["BackgroundSync"] = "backgroundSync";
    ServiceName2["PushMessaging"] = "pushMessaging";
    ServiceName2["Notifications"] = "notifications";
    ServiceName2["PaymentHandler"] = "paymentHandler";
    ServiceName2["PeriodicBackgroundSync"] = "periodicBackgroundSync";
  })(ServiceName = BackgroundService2.ServiceName || (BackgroundService2.ServiceName = {}));
})(BackgroundService || (BackgroundService = {}));
var Browser;
((Browser2) => {
  let WindowState;
  ((WindowState2) => {
    WindowState2["Normal"] = "normal";
    WindowState2["Minimized"] = "minimized";
    WindowState2["Maximized"] = "maximized";
    WindowState2["Fullscreen"] = "fullscreen";
  })(WindowState = Browser2.WindowState || (Browser2.WindowState = {}));
  let PermissionType;
  ((PermissionType2) => {
    PermissionType2["AccessibilityEvents"] = "accessibilityEvents";
    PermissionType2["AudioCapture"] = "audioCapture";
    PermissionType2["BackgroundSync"] = "backgroundSync";
    PermissionType2["BackgroundFetch"] = "backgroundFetch";
    PermissionType2["CapturedSurfaceControl"] = "capturedSurfaceControl";
    PermissionType2["ClipboardReadWrite"] = "clipboardReadWrite";
    PermissionType2["ClipboardSanitizedWrite"] = "clipboardSanitizedWrite";
    PermissionType2["DisplayCapture"] = "displayCapture";
    PermissionType2["DurableStorage"] = "durableStorage";
    PermissionType2["Flash"] = "flash";
    PermissionType2["Geolocation"] = "geolocation";
    PermissionType2["IdleDetection"] = "idleDetection";
    PermissionType2["LocalFonts"] = "localFonts";
    PermissionType2["Midi"] = "midi";
    PermissionType2["MidiSysex"] = "midiSysex";
    PermissionType2["Nfc"] = "nfc";
    PermissionType2["Notifications"] = "notifications";
    PermissionType2["PaymentHandler"] = "paymentHandler";
    PermissionType2["PeriodicBackgroundSync"] = "periodicBackgroundSync";
    PermissionType2["ProtectedMediaIdentifier"] = "protectedMediaIdentifier";
    PermissionType2["Sensors"] = "sensors";
    PermissionType2["StorageAccess"] = "storageAccess";
    PermissionType2["SpeakerSelection"] = "speakerSelection";
    PermissionType2["TopLevelStorageAccess"] = "topLevelStorageAccess";
    PermissionType2["VideoCapture"] = "videoCapture";
    PermissionType2["VideoCapturePanTiltZoom"] = "videoCapturePanTiltZoom";
    PermissionType2["WakeLockScreen"] = "wakeLockScreen";
    PermissionType2["WakeLockSystem"] = "wakeLockSystem";
    PermissionType2["WebAppInstallation"] = "webAppInstallation";
    PermissionType2["WindowManagement"] = "windowManagement";
  })(PermissionType = Browser2.PermissionType || (Browser2.PermissionType = {}));
  let PermissionSetting;
  ((PermissionSetting2) => {
    PermissionSetting2["Granted"] = "granted";
    PermissionSetting2["Denied"] = "denied";
    PermissionSetting2["Prompt"] = "prompt";
  })(PermissionSetting = Browser2.PermissionSetting || (Browser2.PermissionSetting = {}));
  let BrowserCommandId;
  ((BrowserCommandId2) => {
    BrowserCommandId2["OpenTabSearch"] = "openTabSearch";
    BrowserCommandId2["CloseTabSearch"] = "closeTabSearch";
  })(BrowserCommandId = Browser2.BrowserCommandId || (Browser2.BrowserCommandId = {}));
  let SetDownloadBehaviorRequestBehavior;
  ((SetDownloadBehaviorRequestBehavior2) => {
    SetDownloadBehaviorRequestBehavior2["Deny"] = "deny";
    SetDownloadBehaviorRequestBehavior2["Allow"] = "allow";
    SetDownloadBehaviorRequestBehavior2["AllowAndName"] = "allowAndName";
    SetDownloadBehaviorRequestBehavior2["Default"] = "default";
  })(SetDownloadBehaviorRequestBehavior = Browser2.SetDownloadBehaviorRequestBehavior || (Browser2.SetDownloadBehaviorRequestBehavior = {}));
  let DownloadProgressEventState;
  ((DownloadProgressEventState2) => {
    DownloadProgressEventState2["InProgress"] = "inProgress";
    DownloadProgressEventState2["Completed"] = "completed";
    DownloadProgressEventState2["Canceled"] = "canceled";
  })(DownloadProgressEventState = Browser2.DownloadProgressEventState || (Browser2.DownloadProgressEventState = {}));
})(Browser || (Browser = {}));
var CSS2;
((CSS22) => {
  let StyleSheetOrigin;
  ((StyleSheetOrigin2) => {
    StyleSheetOrigin2["Injected"] = "injected";
    StyleSheetOrigin2["UserAgent"] = "user-agent";
    StyleSheetOrigin2["Inspector"] = "inspector";
    StyleSheetOrigin2["Regular"] = "regular";
  })(StyleSheetOrigin = CSS22.StyleSheetOrigin || (CSS22.StyleSheetOrigin = {}));
  let CSSRuleType;
  ((CSSRuleType2) => {
    CSSRuleType2["MediaRule"] = "MediaRule";
    CSSRuleType2["SupportsRule"] = "SupportsRule";
    CSSRuleType2["ContainerRule"] = "ContainerRule";
    CSSRuleType2["LayerRule"] = "LayerRule";
    CSSRuleType2["ScopeRule"] = "ScopeRule";
    CSSRuleType2["StyleRule"] = "StyleRule";
    CSSRuleType2["StartingStyleRule"] = "StartingStyleRule";
  })(CSSRuleType = CSS22.CSSRuleType || (CSS22.CSSRuleType = {}));
  let CSSMediaSource;
  ((CSSMediaSource2) => {
    CSSMediaSource2["MediaRule"] = "mediaRule";
    CSSMediaSource2["ImportRule"] = "importRule";
    CSSMediaSource2["LinkedSheet"] = "linkedSheet";
    CSSMediaSource2["InlineSheet"] = "inlineSheet";
  })(CSSMediaSource = CSS22.CSSMediaSource || (CSS22.CSSMediaSource = {}));
})(CSS2 || (CSS2 = {}));
var CacheStorage;
((CacheStorage2) => {
  let CachedResponseType;
  ((CachedResponseType2) => {
    CachedResponseType2["Basic"] = "basic";
    CachedResponseType2["Cors"] = "cors";
    CachedResponseType2["Default"] = "default";
    CachedResponseType2["Error"] = "error";
    CachedResponseType2["OpaqueResponse"] = "opaqueResponse";
    CachedResponseType2["OpaqueRedirect"] = "opaqueRedirect";
  })(CachedResponseType = CacheStorage2.CachedResponseType || (CacheStorage2.CachedResponseType = {}));
})(CacheStorage || (CacheStorage = {}));
var DOM;
((DOM2) => {
  let PseudoType;
  ((PseudoType2) => {
    PseudoType2["FirstLine"] = "first-line";
    PseudoType2["FirstLetter"] = "first-letter";
    PseudoType2["Check"] = "check";
    PseudoType2["Before"] = "before";
    PseudoType2["After"] = "after";
    PseudoType2["SelectArrow"] = "select-arrow";
    PseudoType2["Marker"] = "marker";
    PseudoType2["Backdrop"] = "backdrop";
    PseudoType2["Column"] = "column";
    PseudoType2["Selection"] = "selection";
    PseudoType2["SearchText"] = "search-text";
    PseudoType2["TargetText"] = "target-text";
    PseudoType2["SpellingError"] = "spelling-error";
    PseudoType2["GrammarError"] = "grammar-error";
    PseudoType2["Highlight"] = "highlight";
    PseudoType2["FirstLineInherited"] = "first-line-inherited";
    PseudoType2["ScrollMarker"] = "scroll-marker";
    PseudoType2["ScrollMarkerGroup"] = "scroll-marker-group";
    PseudoType2["ScrollNextButton"] = "scroll-next-button";
    PseudoType2["ScrollPrevButton"] = "scroll-prev-button";
    PseudoType2["Scrollbar"] = "scrollbar";
    PseudoType2["ScrollbarThumb"] = "scrollbar-thumb";
    PseudoType2["ScrollbarButton"] = "scrollbar-button";
    PseudoType2["ScrollbarTrack"] = "scrollbar-track";
    PseudoType2["ScrollbarTrackPiece"] = "scrollbar-track-piece";
    PseudoType2["ScrollbarCorner"] = "scrollbar-corner";
    PseudoType2["Resizer"] = "resizer";
    PseudoType2["InputListButton"] = "input-list-button";
    PseudoType2["ViewTransition"] = "view-transition";
    PseudoType2["ViewTransitionGroup"] = "view-transition-group";
    PseudoType2["ViewTransitionImagePair"] = "view-transition-image-pair";
    PseudoType2["ViewTransitionOld"] = "view-transition-old";
    PseudoType2["ViewTransitionNew"] = "view-transition-new";
    PseudoType2["Placeholder"] = "placeholder";
    PseudoType2["FileSelectorButton"] = "file-selector-button";
    PseudoType2["DetailsContent"] = "details-content";
    PseudoType2["Picker"] = "picker";
  })(PseudoType = DOM2.PseudoType || (DOM2.PseudoType = {}));
  let ShadowRootType;
  ((ShadowRootType2) => {
    ShadowRootType2["UserAgent"] = "user-agent";
    ShadowRootType2["Open"] = "open";
    ShadowRootType2["Closed"] = "closed";
  })(ShadowRootType = DOM2.ShadowRootType || (DOM2.ShadowRootType = {}));
  let CompatibilityMode;
  ((CompatibilityMode2) => {
    CompatibilityMode2["QuirksMode"] = "QuirksMode";
    CompatibilityMode2["LimitedQuirksMode"] = "LimitedQuirksMode";
    CompatibilityMode2["NoQuirksMode"] = "NoQuirksMode";
  })(CompatibilityMode = DOM2.CompatibilityMode || (DOM2.CompatibilityMode = {}));
  let PhysicalAxes;
  ((PhysicalAxes2) => {
    PhysicalAxes2["Horizontal"] = "Horizontal";
    PhysicalAxes2["Vertical"] = "Vertical";
    PhysicalAxes2["Both"] = "Both";
  })(PhysicalAxes = DOM2.PhysicalAxes || (DOM2.PhysicalAxes = {}));
  let LogicalAxes;
  ((LogicalAxes2) => {
    LogicalAxes2["Inline"] = "Inline";
    LogicalAxes2["Block"] = "Block";
    LogicalAxes2["Both"] = "Both";
  })(LogicalAxes = DOM2.LogicalAxes || (DOM2.LogicalAxes = {}));
  let ScrollOrientation;
  ((ScrollOrientation2) => {
    ScrollOrientation2["Horizontal"] = "horizontal";
    ScrollOrientation2["Vertical"] = "vertical";
  })(ScrollOrientation = DOM2.ScrollOrientation || (DOM2.ScrollOrientation = {}));
  let EnableRequestIncludeWhitespace;
  ((EnableRequestIncludeWhitespace2) => {
    EnableRequestIncludeWhitespace2["None"] = "none";
    EnableRequestIncludeWhitespace2["All"] = "all";
  })(EnableRequestIncludeWhitespace = DOM2.EnableRequestIncludeWhitespace || (DOM2.EnableRequestIncludeWhitespace = {}));
  let GetElementByRelationRequestRelation;
  ((GetElementByRelationRequestRelation2) => {
    GetElementByRelationRequestRelation2["PopoverTarget"] = "PopoverTarget";
  })(GetElementByRelationRequestRelation = DOM2.GetElementByRelationRequestRelation || (DOM2.GetElementByRelationRequestRelation = {}));
})(DOM || (DOM = {}));
var DOMDebugger;
((DOMDebugger2) => {
  let DOMBreakpointType;
  ((DOMBreakpointType2) => {
    DOMBreakpointType2["SubtreeModified"] = "subtree-modified";
    DOMBreakpointType2["AttributeModified"] = "attribute-modified";
    DOMBreakpointType2["NodeRemoved"] = "node-removed";
  })(DOMBreakpointType = DOMDebugger2.DOMBreakpointType || (DOMDebugger2.DOMBreakpointType = {}));
  let CSPViolationType;
  ((CSPViolationType2) => {
    CSPViolationType2["TrustedtypeSinkViolation"] = "trustedtype-sink-violation";
    CSPViolationType2["TrustedtypePolicyViolation"] = "trustedtype-policy-violation";
  })(CSPViolationType = DOMDebugger2.CSPViolationType || (DOMDebugger2.CSPViolationType = {}));
})(DOMDebugger || (DOMDebugger = {}));
var Emulation;
((Emulation2) => {
  let ScreenOrientationType;
  ((ScreenOrientationType2) => {
    ScreenOrientationType2["PortraitPrimary"] = "portraitPrimary";
    ScreenOrientationType2["PortraitSecondary"] = "portraitSecondary";
    ScreenOrientationType2["LandscapePrimary"] = "landscapePrimary";
    ScreenOrientationType2["LandscapeSecondary"] = "landscapeSecondary";
  })(ScreenOrientationType = Emulation2.ScreenOrientationType || (Emulation2.ScreenOrientationType = {}));
  let DisplayFeatureOrientation;
  ((DisplayFeatureOrientation2) => {
    DisplayFeatureOrientation2["Vertical"] = "vertical";
    DisplayFeatureOrientation2["Horizontal"] = "horizontal";
  })(DisplayFeatureOrientation = Emulation2.DisplayFeatureOrientation || (Emulation2.DisplayFeatureOrientation = {}));
  let DevicePostureType;
  ((DevicePostureType2) => {
    DevicePostureType2["Continuous"] = "continuous";
    DevicePostureType2["Folded"] = "folded";
  })(DevicePostureType = Emulation2.DevicePostureType || (Emulation2.DevicePostureType = {}));
  let VirtualTimePolicy;
  ((VirtualTimePolicy2) => {
    VirtualTimePolicy2["Advance"] = "advance";
    VirtualTimePolicy2["Pause"] = "pause";
    VirtualTimePolicy2["PauseIfNetworkFetchesPending"] = "pauseIfNetworkFetchesPending";
  })(VirtualTimePolicy = Emulation2.VirtualTimePolicy || (Emulation2.VirtualTimePolicy = {}));
  let SensorType;
  ((SensorType2) => {
    SensorType2["AbsoluteOrientation"] = "absolute-orientation";
    SensorType2["Accelerometer"] = "accelerometer";
    SensorType2["AmbientLight"] = "ambient-light";
    SensorType2["Gravity"] = "gravity";
    SensorType2["Gyroscope"] = "gyroscope";
    SensorType2["LinearAcceleration"] = "linear-acceleration";
    SensorType2["Magnetometer"] = "magnetometer";
    SensorType2["RelativeOrientation"] = "relative-orientation";
  })(SensorType = Emulation2.SensorType || (Emulation2.SensorType = {}));
  let PressureSource;
  ((PressureSource2) => {
    PressureSource2["Cpu"] = "cpu";
  })(PressureSource = Emulation2.PressureSource || (Emulation2.PressureSource = {}));
  let PressureState;
  ((PressureState2) => {
    PressureState2["Nominal"] = "nominal";
    PressureState2["Fair"] = "fair";
    PressureState2["Serious"] = "serious";
    PressureState2["Critical"] = "critical";
  })(PressureState = Emulation2.PressureState || (Emulation2.PressureState = {}));
  let DisabledImageType;
  ((DisabledImageType2) => {
    DisabledImageType2["Avif"] = "avif";
    DisabledImageType2["Webp"] = "webp";
  })(DisabledImageType = Emulation2.DisabledImageType || (Emulation2.DisabledImageType = {}));
  let SetEmitTouchEventsForMouseRequestConfiguration;
  ((SetEmitTouchEventsForMouseRequestConfiguration2) => {
    SetEmitTouchEventsForMouseRequestConfiguration2["Mobile"] = "mobile";
    SetEmitTouchEventsForMouseRequestConfiguration2["Desktop"] = "desktop";
  })(SetEmitTouchEventsForMouseRequestConfiguration = Emulation2.SetEmitTouchEventsForMouseRequestConfiguration || (Emulation2.SetEmitTouchEventsForMouseRequestConfiguration = {}));
  let SetEmulatedVisionDeficiencyRequestType;
  ((SetEmulatedVisionDeficiencyRequestType2) => {
    SetEmulatedVisionDeficiencyRequestType2["None"] = "none";
    SetEmulatedVisionDeficiencyRequestType2["BlurredVision"] = "blurredVision";
    SetEmulatedVisionDeficiencyRequestType2["ReducedContrast"] = "reducedContrast";
    SetEmulatedVisionDeficiencyRequestType2["Achromatopsia"] = "achromatopsia";
    SetEmulatedVisionDeficiencyRequestType2["Deuteranopia"] = "deuteranopia";
    SetEmulatedVisionDeficiencyRequestType2["Protanopia"] = "protanopia";
    SetEmulatedVisionDeficiencyRequestType2["Tritanopia"] = "tritanopia";
  })(SetEmulatedVisionDeficiencyRequestType = Emulation2.SetEmulatedVisionDeficiencyRequestType || (Emulation2.SetEmulatedVisionDeficiencyRequestType = {}));
})(Emulation || (Emulation = {}));
var HeadlessExperimental;
((HeadlessExperimental2) => {
  let ScreenshotParamsFormat;
  ((ScreenshotParamsFormat2) => {
    ScreenshotParamsFormat2["Jpeg"] = "jpeg";
    ScreenshotParamsFormat2["Png"] = "png";
    ScreenshotParamsFormat2["Webp"] = "webp";
  })(ScreenshotParamsFormat = HeadlessExperimental2.ScreenshotParamsFormat || (HeadlessExperimental2.ScreenshotParamsFormat = {}));
})(HeadlessExperimental || (HeadlessExperimental = {}));
var IndexedDB;
((IndexedDB2) => {
  let KeyType;
  ((KeyType2) => {
    KeyType2["Number"] = "number";
    KeyType2["String"] = "string";
    KeyType2["Date"] = "date";
    KeyType2["Array"] = "array";
  })(KeyType = IndexedDB2.KeyType || (IndexedDB2.KeyType = {}));
  let KeyPathType;
  ((KeyPathType2) => {
    KeyPathType2["Null"] = "null";
    KeyPathType2["String"] = "string";
    KeyPathType2["Array"] = "array";
  })(KeyPathType = IndexedDB2.KeyPathType || (IndexedDB2.KeyPathType = {}));
})(IndexedDB || (IndexedDB = {}));
var Input;
((Input2) => {
  let GestureSourceType;
  ((GestureSourceType2) => {
    GestureSourceType2["Default"] = "default";
    GestureSourceType2["Touch"] = "touch";
    GestureSourceType2["Mouse"] = "mouse";
  })(GestureSourceType = Input2.GestureSourceType || (Input2.GestureSourceType = {}));
  let MouseButton;
  ((MouseButton2) => {
    MouseButton2["None"] = "none";
    MouseButton2["Left"] = "left";
    MouseButton2["Middle"] = "middle";
    MouseButton2["Right"] = "right";
    MouseButton2["Back"] = "back";
    MouseButton2["Forward"] = "forward";
  })(MouseButton = Input2.MouseButton || (Input2.MouseButton = {}));
  let DispatchDragEventRequestType;
  ((DispatchDragEventRequestType2) => {
    DispatchDragEventRequestType2["DragEnter"] = "dragEnter";
    DispatchDragEventRequestType2["DragOver"] = "dragOver";
    DispatchDragEventRequestType2["Drop"] = "drop";
    DispatchDragEventRequestType2["DragCancel"] = "dragCancel";
  })(DispatchDragEventRequestType = Input2.DispatchDragEventRequestType || (Input2.DispatchDragEventRequestType = {}));
  let DispatchKeyEventRequestType;
  ((DispatchKeyEventRequestType2) => {
    DispatchKeyEventRequestType2["KeyDown"] = "keyDown";
    DispatchKeyEventRequestType2["KeyUp"] = "keyUp";
    DispatchKeyEventRequestType2["RawKeyDown"] = "rawKeyDown";
    DispatchKeyEventRequestType2["Char"] = "char";
  })(DispatchKeyEventRequestType = Input2.DispatchKeyEventRequestType || (Input2.DispatchKeyEventRequestType = {}));
  let DispatchMouseEventRequestType;
  ((DispatchMouseEventRequestType2) => {
    DispatchMouseEventRequestType2["MousePressed"] = "mousePressed";
    DispatchMouseEventRequestType2["MouseReleased"] = "mouseReleased";
    DispatchMouseEventRequestType2["MouseMoved"] = "mouseMoved";
    DispatchMouseEventRequestType2["MouseWheel"] = "mouseWheel";
  })(DispatchMouseEventRequestType = Input2.DispatchMouseEventRequestType || (Input2.DispatchMouseEventRequestType = {}));
  let DispatchMouseEventRequestPointerType;
  ((DispatchMouseEventRequestPointerType2) => {
    DispatchMouseEventRequestPointerType2["Mouse"] = "mouse";
    DispatchMouseEventRequestPointerType2["Pen"] = "pen";
  })(DispatchMouseEventRequestPointerType = Input2.DispatchMouseEventRequestPointerType || (Input2.DispatchMouseEventRequestPointerType = {}));
  let DispatchTouchEventRequestType;
  ((DispatchTouchEventRequestType2) => {
    DispatchTouchEventRequestType2["TouchStart"] = "touchStart";
    DispatchTouchEventRequestType2["TouchEnd"] = "touchEnd";
    DispatchTouchEventRequestType2["TouchMove"] = "touchMove";
    DispatchTouchEventRequestType2["TouchCancel"] = "touchCancel";
  })(DispatchTouchEventRequestType = Input2.DispatchTouchEventRequestType || (Input2.DispatchTouchEventRequestType = {}));
  let EmulateTouchFromMouseEventRequestType;
  ((EmulateTouchFromMouseEventRequestType2) => {
    EmulateTouchFromMouseEventRequestType2["MousePressed"] = "mousePressed";
    EmulateTouchFromMouseEventRequestType2["MouseReleased"] = "mouseReleased";
    EmulateTouchFromMouseEventRequestType2["MouseMoved"] = "mouseMoved";
    EmulateTouchFromMouseEventRequestType2["MouseWheel"] = "mouseWheel";
  })(EmulateTouchFromMouseEventRequestType = Input2.EmulateTouchFromMouseEventRequestType || (Input2.EmulateTouchFromMouseEventRequestType = {}));
})(Input || (Input = {}));
var LayerTree;
((LayerTree2) => {
  let ScrollRectType;
  ((ScrollRectType2) => {
    ScrollRectType2["RepaintsOnScroll"] = "RepaintsOnScroll";
    ScrollRectType2["TouchEventHandler"] = "TouchEventHandler";
    ScrollRectType2["WheelEventHandler"] = "WheelEventHandler";
  })(ScrollRectType = LayerTree2.ScrollRectType || (LayerTree2.ScrollRectType = {}));
})(LayerTree || (LayerTree = {}));
var Log;
((Log2) => {
  let LogEntrySource;
  ((LogEntrySource2) => {
    LogEntrySource2["XML"] = "xml";
    LogEntrySource2["Javascript"] = "javascript";
    LogEntrySource2["Network"] = "network";
    LogEntrySource2["Storage"] = "storage";
    LogEntrySource2["Appcache"] = "appcache";
    LogEntrySource2["Rendering"] = "rendering";
    LogEntrySource2["Security"] = "security";
    LogEntrySource2["Deprecation"] = "deprecation";
    LogEntrySource2["Worker"] = "worker";
    LogEntrySource2["Violation"] = "violation";
    LogEntrySource2["Intervention"] = "intervention";
    LogEntrySource2["Recommendation"] = "recommendation";
    LogEntrySource2["Other"] = "other";
  })(LogEntrySource = Log2.LogEntrySource || (Log2.LogEntrySource = {}));
  let LogEntryLevel;
  ((LogEntryLevel2) => {
    LogEntryLevel2["Verbose"] = "verbose";
    LogEntryLevel2["Info"] = "info";
    LogEntryLevel2["Warning"] = "warning";
    LogEntryLevel2["Error"] = "error";
  })(LogEntryLevel = Log2.LogEntryLevel || (Log2.LogEntryLevel = {}));
  let LogEntryCategory;
  ((LogEntryCategory2) => {
    LogEntryCategory2["Cors"] = "cors";
  })(LogEntryCategory = Log2.LogEntryCategory || (Log2.LogEntryCategory = {}));
  let ViolationSettingName;
  ((ViolationSettingName2) => {
    ViolationSettingName2["LongTask"] = "longTask";
    ViolationSettingName2["LongLayout"] = "longLayout";
    ViolationSettingName2["BlockedEvent"] = "blockedEvent";
    ViolationSettingName2["BlockedParser"] = "blockedParser";
    ViolationSettingName2["DiscouragedAPIUse"] = "discouragedAPIUse";
    ViolationSettingName2["Handler"] = "handler";
    ViolationSettingName2["RecurringHandler"] = "recurringHandler";
  })(ViolationSettingName = Log2.ViolationSettingName || (Log2.ViolationSettingName = {}));
})(Log || (Log = {}));
var Memory;
((Memory2) => {
  let PressureLevel;
  ((PressureLevel2) => {
    PressureLevel2["Moderate"] = "moderate";
    PressureLevel2["Critical"] = "critical";
  })(PressureLevel = Memory2.PressureLevel || (Memory2.PressureLevel = {}));
})(Memory || (Memory = {}));
var Network;
((Network2) => {
  let ResourceType7;
  ((ResourceType22) => {
    ResourceType22["Document"] = "Document";
    ResourceType22["Stylesheet"] = "Stylesheet";
    ResourceType22["Image"] = "Image";
    ResourceType22["Media"] = "Media";
    ResourceType22["Font"] = "Font";
    ResourceType22["Script"] = "Script";
    ResourceType22["TextTrack"] = "TextTrack";
    ResourceType22["XHR"] = "XHR";
    ResourceType22["Fetch"] = "Fetch";
    ResourceType22["Prefetch"] = "Prefetch";
    ResourceType22["EventSource"] = "EventSource";
    ResourceType22["WebSocket"] = "WebSocket";
    ResourceType22["Manifest"] = "Manifest";
    ResourceType22["SignedExchange"] = "SignedExchange";
    ResourceType22["Ping"] = "Ping";
    ResourceType22["CSPViolationReport"] = "CSPViolationReport";
    ResourceType22["Preflight"] = "Preflight";
    ResourceType22["Other"] = "Other";
  })(ResourceType7 = Network2.ResourceType || (Network2.ResourceType = {}));
  let ErrorReason;
  ((ErrorReason2) => {
    ErrorReason2["Failed"] = "Failed";
    ErrorReason2["Aborted"] = "Aborted";
    ErrorReason2["TimedOut"] = "TimedOut";
    ErrorReason2["AccessDenied"] = "AccessDenied";
    ErrorReason2["ConnectionClosed"] = "ConnectionClosed";
    ErrorReason2["ConnectionReset"] = "ConnectionReset";
    ErrorReason2["ConnectionRefused"] = "ConnectionRefused";
    ErrorReason2["ConnectionAborted"] = "ConnectionAborted";
    ErrorReason2["ConnectionFailed"] = "ConnectionFailed";
    ErrorReason2["NameNotResolved"] = "NameNotResolved";
    ErrorReason2["InternetDisconnected"] = "InternetDisconnected";
    ErrorReason2["AddressUnreachable"] = "AddressUnreachable";
    ErrorReason2["BlockedByClient"] = "BlockedByClient";
    ErrorReason2["BlockedByResponse"] = "BlockedByResponse";
  })(ErrorReason = Network2.ErrorReason || (Network2.ErrorReason = {}));
  let ConnectionType;
  ((ConnectionType2) => {
    ConnectionType2["None"] = "none";
    ConnectionType2["Cellular2g"] = "cellular2g";
    ConnectionType2["Cellular3g"] = "cellular3g";
    ConnectionType2["Cellular4g"] = "cellular4g";
    ConnectionType2["Bluetooth"] = "bluetooth";
    ConnectionType2["Ethernet"] = "ethernet";
    ConnectionType2["Wifi"] = "wifi";
    ConnectionType2["Wimax"] = "wimax";
    ConnectionType2["Other"] = "other";
  })(ConnectionType = Network2.ConnectionType || (Network2.ConnectionType = {}));
  let CookieSameSite;
  ((CookieSameSite2) => {
    CookieSameSite2["Strict"] = "Strict";
    CookieSameSite2["Lax"] = "Lax";
    CookieSameSite2["None"] = "None";
  })(CookieSameSite = Network2.CookieSameSite || (Network2.CookieSameSite = {}));
  let CookiePriority;
  ((CookiePriority2) => {
    CookiePriority2["Low"] = "Low";
    CookiePriority2["Medium"] = "Medium";
    CookiePriority2["High"] = "High";
  })(CookiePriority = Network2.CookiePriority || (Network2.CookiePriority = {}));
  let CookieSourceScheme;
  ((CookieSourceScheme2) => {
    CookieSourceScheme2["Unset"] = "Unset";
    CookieSourceScheme2["NonSecure"] = "NonSecure";
    CookieSourceScheme2["Secure"] = "Secure";
  })(CookieSourceScheme = Network2.CookieSourceScheme || (Network2.CookieSourceScheme = {}));
  let ResourcePriority;
  ((ResourcePriority2) => {
    ResourcePriority2["VeryLow"] = "VeryLow";
    ResourcePriority2["Low"] = "Low";
    ResourcePriority2["Medium"] = "Medium";
    ResourcePriority2["High"] = "High";
    ResourcePriority2["VeryHigh"] = "VeryHigh";
  })(ResourcePriority = Network2.ResourcePriority || (Network2.ResourcePriority = {}));
  let RequestReferrerPolicy;
  ((RequestReferrerPolicy2) => {
    RequestReferrerPolicy2["UnsafeUrl"] = "unsafe-url";
    RequestReferrerPolicy2["NoReferrerWhenDowngrade"] = "no-referrer-when-downgrade";
    RequestReferrerPolicy2["NoReferrer"] = "no-referrer";
    RequestReferrerPolicy2["Origin"] = "origin";
    RequestReferrerPolicy2["OriginWhenCrossOrigin"] = "origin-when-cross-origin";
    RequestReferrerPolicy2["SameOrigin"] = "same-origin";
    RequestReferrerPolicy2["StrictOrigin"] = "strict-origin";
    RequestReferrerPolicy2["StrictOriginWhenCrossOrigin"] = "strict-origin-when-cross-origin";
  })(RequestReferrerPolicy = Network2.RequestReferrerPolicy || (Network2.RequestReferrerPolicy = {}));
  let CertificateTransparencyCompliance;
  ((CertificateTransparencyCompliance2) => {
    CertificateTransparencyCompliance2["Unknown"] = "unknown";
    CertificateTransparencyCompliance2["NotCompliant"] = "not-compliant";
    CertificateTransparencyCompliance2["Compliant"] = "compliant";
  })(CertificateTransparencyCompliance = Network2.CertificateTransparencyCompliance || (Network2.CertificateTransparencyCompliance = {}));
  let BlockedReason;
  ((BlockedReason2) => {
    BlockedReason2["Other"] = "other";
    BlockedReason2["Csp"] = "csp";
    BlockedReason2["MixedContent"] = "mixed-content";
    BlockedReason2["Origin"] = "origin";
    BlockedReason2["Inspector"] = "inspector";
    BlockedReason2["SubresourceFilter"] = "subresource-filter";
    BlockedReason2["ContentType"] = "content-type";
    BlockedReason2["CoepFrameResourceNeedsCoepHeader"] = "coep-frame-resource-needs-coep-header";
    BlockedReason2["CoopSandboxedIframeCannotNavigateToCoopPage"] = "coop-sandboxed-iframe-cannot-navigate-to-coop-page";
    BlockedReason2["CorpNotSameOrigin"] = "corp-not-same-origin";
    BlockedReason2["CorpNotSameOriginAfterDefaultedToSameOriginByCoep"] = "corp-not-same-origin-after-defaulted-to-same-origin-by-coep";
    BlockedReason2["CorpNotSameOriginAfterDefaultedToSameOriginByDip"] = "corp-not-same-origin-after-defaulted-to-same-origin-by-dip";
    BlockedReason2["CorpNotSameOriginAfterDefaultedToSameOriginByCoepAndDip"] = "corp-not-same-origin-after-defaulted-to-same-origin-by-coep-and-dip";
    BlockedReason2["CorpNotSameSite"] = "corp-not-same-site";
  })(BlockedReason = Network2.BlockedReason || (Network2.BlockedReason = {}));
  let CorsError;
  ((CorsError2) => {
    CorsError2["DisallowedByMode"] = "DisallowedByMode";
    CorsError2["InvalidResponse"] = "InvalidResponse";
    CorsError2["WildcardOriginNotAllowed"] = "WildcardOriginNotAllowed";
    CorsError2["MissingAllowOriginHeader"] = "MissingAllowOriginHeader";
    CorsError2["MultipleAllowOriginValues"] = "MultipleAllowOriginValues";
    CorsError2["InvalidAllowOriginValue"] = "InvalidAllowOriginValue";
    CorsError2["AllowOriginMismatch"] = "AllowOriginMismatch";
    CorsError2["InvalidAllowCredentials"] = "InvalidAllowCredentials";
    CorsError2["CorsDisabledScheme"] = "CorsDisabledScheme";
    CorsError2["PreflightInvalidStatus"] = "PreflightInvalidStatus";
    CorsError2["PreflightDisallowedRedirect"] = "PreflightDisallowedRedirect";
    CorsError2["PreflightWildcardOriginNotAllowed"] = "PreflightWildcardOriginNotAllowed";
    CorsError2["PreflightMissingAllowOriginHeader"] = "PreflightMissingAllowOriginHeader";
    CorsError2["PreflightMultipleAllowOriginValues"] = "PreflightMultipleAllowOriginValues";
    CorsError2["PreflightInvalidAllowOriginValue"] = "PreflightInvalidAllowOriginValue";
    CorsError2["PreflightAllowOriginMismatch"] = "PreflightAllowOriginMismatch";
    CorsError2["PreflightInvalidAllowCredentials"] = "PreflightInvalidAllowCredentials";
    CorsError2["PreflightMissingAllowExternal"] = "PreflightMissingAllowExternal";
    CorsError2["PreflightInvalidAllowExternal"] = "PreflightInvalidAllowExternal";
    CorsError2["PreflightMissingAllowPrivateNetwork"] = "PreflightMissingAllowPrivateNetwork";
    CorsError2["PreflightInvalidAllowPrivateNetwork"] = "PreflightInvalidAllowPrivateNetwork";
    CorsError2["InvalidAllowMethodsPreflightResponse"] = "InvalidAllowMethodsPreflightResponse";
    CorsError2["InvalidAllowHeadersPreflightResponse"] = "InvalidAllowHeadersPreflightResponse";
    CorsError2["MethodDisallowedByPreflightResponse"] = "MethodDisallowedByPreflightResponse";
    CorsError2["HeaderDisallowedByPreflightResponse"] = "HeaderDisallowedByPreflightResponse";
    CorsError2["RedirectContainsCredentials"] = "RedirectContainsCredentials";
    CorsError2["InsecurePrivateNetwork"] = "InsecurePrivateNetwork";
    CorsError2["InvalidPrivateNetworkAccess"] = "InvalidPrivateNetworkAccess";
    CorsError2["UnexpectedPrivateNetworkAccess"] = "UnexpectedPrivateNetworkAccess";
    CorsError2["NoCorsRedirectModeNotFollow"] = "NoCorsRedirectModeNotFollow";
    CorsError2["PreflightMissingPrivateNetworkAccessId"] = "PreflightMissingPrivateNetworkAccessId";
    CorsError2["PreflightMissingPrivateNetworkAccessName"] = "PreflightMissingPrivateNetworkAccessName";
    CorsError2["PrivateNetworkAccessPermissionUnavailable"] = "PrivateNetworkAccessPermissionUnavailable";
    CorsError2["PrivateNetworkAccessPermissionDenied"] = "PrivateNetworkAccessPermissionDenied";
  })(CorsError = Network2.CorsError || (Network2.CorsError = {}));
  let ServiceWorkerResponseSource;
  ((ServiceWorkerResponseSource2) => {
    ServiceWorkerResponseSource2["CacheStorage"] = "cache-storage";
    ServiceWorkerResponseSource2["HttpCache"] = "http-cache";
    ServiceWorkerResponseSource2["FallbackCode"] = "fallback-code";
    ServiceWorkerResponseSource2["Network"] = "network";
  })(ServiceWorkerResponseSource = Network2.ServiceWorkerResponseSource || (Network2.ServiceWorkerResponseSource = {}));
  let TrustTokenParamsRefreshPolicy;
  ((TrustTokenParamsRefreshPolicy2) => {
    TrustTokenParamsRefreshPolicy2["UseCached"] = "UseCached";
    TrustTokenParamsRefreshPolicy2["Refresh"] = "Refresh";
  })(TrustTokenParamsRefreshPolicy = Network2.TrustTokenParamsRefreshPolicy || (Network2.TrustTokenParamsRefreshPolicy = {}));
  let TrustTokenOperationType;
  ((TrustTokenOperationType2) => {
    TrustTokenOperationType2["Issuance"] = "Issuance";
    TrustTokenOperationType2["Redemption"] = "Redemption";
    TrustTokenOperationType2["Signing"] = "Signing";
  })(TrustTokenOperationType = Network2.TrustTokenOperationType || (Network2.TrustTokenOperationType = {}));
  let AlternateProtocolUsage;
  ((AlternateProtocolUsage2) => {
    AlternateProtocolUsage2["AlternativeJobWonWithoutRace"] = "alternativeJobWonWithoutRace";
    AlternateProtocolUsage2["AlternativeJobWonRace"] = "alternativeJobWonRace";
    AlternateProtocolUsage2["MainJobWonRace"] = "mainJobWonRace";
    AlternateProtocolUsage2["MappingMissing"] = "mappingMissing";
    AlternateProtocolUsage2["Broken"] = "broken";
    AlternateProtocolUsage2["DnsAlpnH3JobWonWithoutRace"] = "dnsAlpnH3JobWonWithoutRace";
    AlternateProtocolUsage2["DnsAlpnH3JobWonRace"] = "dnsAlpnH3JobWonRace";
    AlternateProtocolUsage2["UnspecifiedReason"] = "unspecifiedReason";
  })(AlternateProtocolUsage = Network2.AlternateProtocolUsage || (Network2.AlternateProtocolUsage = {}));
  let ServiceWorkerRouterSource;
  ((ServiceWorkerRouterSource2) => {
    ServiceWorkerRouterSource2["Network"] = "network";
    ServiceWorkerRouterSource2["Cache"] = "cache";
    ServiceWorkerRouterSource2["FetchEvent"] = "fetch-event";
    ServiceWorkerRouterSource2["RaceNetworkAndFetchHandler"] = "race-network-and-fetch-handler";
  })(ServiceWorkerRouterSource = Network2.ServiceWorkerRouterSource || (Network2.ServiceWorkerRouterSource = {}));
  let InitiatorType2;
  ((InitiatorType22) => {
    InitiatorType22["Parser"] = "parser";
    InitiatorType22["Script"] = "script";
    InitiatorType22["Preload"] = "preload";
    InitiatorType22["SignedExchange"] = "SignedExchange";
    InitiatorType22["Preflight"] = "preflight";
    InitiatorType22["Other"] = "other";
  })(InitiatorType2 = Network2.InitiatorType || (Network2.InitiatorType = {}));
  let SetCookieBlockedReason;
  ((SetCookieBlockedReason2) => {
    SetCookieBlockedReason2["SecureOnly"] = "SecureOnly";
    SetCookieBlockedReason2["SameSiteStrict"] = "SameSiteStrict";
    SetCookieBlockedReason2["SameSiteLax"] = "SameSiteLax";
    SetCookieBlockedReason2["SameSiteUnspecifiedTreatedAsLax"] = "SameSiteUnspecifiedTreatedAsLax";
    SetCookieBlockedReason2["SameSiteNoneInsecure"] = "SameSiteNoneInsecure";
    SetCookieBlockedReason2["UserPreferences"] = "UserPreferences";
    SetCookieBlockedReason2["ThirdPartyPhaseout"] = "ThirdPartyPhaseout";
    SetCookieBlockedReason2["ThirdPartyBlockedInFirstPartySet"] = "ThirdPartyBlockedInFirstPartySet";
    SetCookieBlockedReason2["SyntaxError"] = "SyntaxError";
    SetCookieBlockedReason2["SchemeNotSupported"] = "SchemeNotSupported";
    SetCookieBlockedReason2["OverwriteSecure"] = "OverwriteSecure";
    SetCookieBlockedReason2["InvalidDomain"] = "InvalidDomain";
    SetCookieBlockedReason2["InvalidPrefix"] = "InvalidPrefix";
    SetCookieBlockedReason2["UnknownError"] = "UnknownError";
    SetCookieBlockedReason2["SchemefulSameSiteStrict"] = "SchemefulSameSiteStrict";
    SetCookieBlockedReason2["SchemefulSameSiteLax"] = "SchemefulSameSiteLax";
    SetCookieBlockedReason2["SchemefulSameSiteUnspecifiedTreatedAsLax"] = "SchemefulSameSiteUnspecifiedTreatedAsLax";
    SetCookieBlockedReason2["SamePartyFromCrossPartyContext"] = "SamePartyFromCrossPartyContext";
    SetCookieBlockedReason2["SamePartyConflictsWithOtherAttributes"] = "SamePartyConflictsWithOtherAttributes";
    SetCookieBlockedReason2["NameValuePairExceedsMaxSize"] = "NameValuePairExceedsMaxSize";
    SetCookieBlockedReason2["DisallowedCharacter"] = "DisallowedCharacter";
    SetCookieBlockedReason2["NoCookieContent"] = "NoCookieContent";
  })(SetCookieBlockedReason = Network2.SetCookieBlockedReason || (Network2.SetCookieBlockedReason = {}));
  let CookieBlockedReason;
  ((CookieBlockedReason2) => {
    CookieBlockedReason2["SecureOnly"] = "SecureOnly";
    CookieBlockedReason2["NotOnPath"] = "NotOnPath";
    CookieBlockedReason2["DomainMismatch"] = "DomainMismatch";
    CookieBlockedReason2["SameSiteStrict"] = "SameSiteStrict";
    CookieBlockedReason2["SameSiteLax"] = "SameSiteLax";
    CookieBlockedReason2["SameSiteUnspecifiedTreatedAsLax"] = "SameSiteUnspecifiedTreatedAsLax";
    CookieBlockedReason2["SameSiteNoneInsecure"] = "SameSiteNoneInsecure";
    CookieBlockedReason2["UserPreferences"] = "UserPreferences";
    CookieBlockedReason2["ThirdPartyPhaseout"] = "ThirdPartyPhaseout";
    CookieBlockedReason2["ThirdPartyBlockedInFirstPartySet"] = "ThirdPartyBlockedInFirstPartySet";
    CookieBlockedReason2["UnknownError"] = "UnknownError";
    CookieBlockedReason2["SchemefulSameSiteStrict"] = "SchemefulSameSiteStrict";
    CookieBlockedReason2["SchemefulSameSiteLax"] = "SchemefulSameSiteLax";
    CookieBlockedReason2["SchemefulSameSiteUnspecifiedTreatedAsLax"] = "SchemefulSameSiteUnspecifiedTreatedAsLax";
    CookieBlockedReason2["SamePartyFromCrossPartyContext"] = "SamePartyFromCrossPartyContext";
    CookieBlockedReason2["NameValuePairExceedsMaxSize"] = "NameValuePairExceedsMaxSize";
    CookieBlockedReason2["PortMismatch"] = "PortMismatch";
    CookieBlockedReason2["SchemeMismatch"] = "SchemeMismatch";
  })(CookieBlockedReason = Network2.CookieBlockedReason || (Network2.CookieBlockedReason = {}));
  let CookieExemptionReason;
  ((CookieExemptionReason2) => {
    CookieExemptionReason2["None"] = "None";
    CookieExemptionReason2["UserSetting"] = "UserSetting";
    CookieExemptionReason2["TPCDMetadata"] = "TPCDMetadata";
    CookieExemptionReason2["TPCDDeprecationTrial"] = "TPCDDeprecationTrial";
    CookieExemptionReason2["TopLevelTPCDDeprecationTrial"] = "TopLevelTPCDDeprecationTrial";
    CookieExemptionReason2["TPCDHeuristics"] = "TPCDHeuristics";
    CookieExemptionReason2["EnterprisePolicy"] = "EnterprisePolicy";
    CookieExemptionReason2["StorageAccess"] = "StorageAccess";
    CookieExemptionReason2["TopLevelStorageAccess"] = "TopLevelStorageAccess";
    CookieExemptionReason2["Scheme"] = "Scheme";
  })(CookieExemptionReason = Network2.CookieExemptionReason || (Network2.CookieExemptionReason = {}));
  let AuthChallengeSource;
  ((AuthChallengeSource2) => {
    AuthChallengeSource2["Server"] = "Server";
    AuthChallengeSource2["Proxy"] = "Proxy";
  })(AuthChallengeSource = Network2.AuthChallengeSource || (Network2.AuthChallengeSource = {}));
  let AuthChallengeResponseResponse;
  ((AuthChallengeResponseResponse2) => {
    AuthChallengeResponseResponse2["Default"] = "Default";
    AuthChallengeResponseResponse2["CancelAuth"] = "CancelAuth";
    AuthChallengeResponseResponse2["ProvideCredentials"] = "ProvideCredentials";
  })(AuthChallengeResponseResponse = Network2.AuthChallengeResponseResponse || (Network2.AuthChallengeResponseResponse = {}));
  let InterceptionStage;
  ((InterceptionStage2) => {
    InterceptionStage2["Request"] = "Request";
    InterceptionStage2["HeadersReceived"] = "HeadersReceived";
  })(InterceptionStage = Network2.InterceptionStage || (Network2.InterceptionStage = {}));
  let SignedExchangeErrorField;
  ((SignedExchangeErrorField2) => {
    SignedExchangeErrorField2["SignatureSig"] = "signatureSig";
    SignedExchangeErrorField2["SignatureIntegrity"] = "signatureIntegrity";
    SignedExchangeErrorField2["SignatureCertUrl"] = "signatureCertUrl";
    SignedExchangeErrorField2["SignatureCertSha256"] = "signatureCertSha256";
    SignedExchangeErrorField2["SignatureValidityUrl"] = "signatureValidityUrl";
    SignedExchangeErrorField2["SignatureTimestamps"] = "signatureTimestamps";
  })(SignedExchangeErrorField = Network2.SignedExchangeErrorField || (Network2.SignedExchangeErrorField = {}));
  let ContentEncoding;
  ((ContentEncoding2) => {
    ContentEncoding2["Deflate"] = "deflate";
    ContentEncoding2["Gzip"] = "gzip";
    ContentEncoding2["Br"] = "br";
    ContentEncoding2["Zstd"] = "zstd";
  })(ContentEncoding = Network2.ContentEncoding || (Network2.ContentEncoding = {}));
  let PrivateNetworkRequestPolicy;
  ((PrivateNetworkRequestPolicy2) => {
    PrivateNetworkRequestPolicy2["Allow"] = "Allow";
    PrivateNetworkRequestPolicy2["BlockFromInsecureToMorePrivate"] = "BlockFromInsecureToMorePrivate";
    PrivateNetworkRequestPolicy2["WarnFromInsecureToMorePrivate"] = "WarnFromInsecureToMorePrivate";
    PrivateNetworkRequestPolicy2["PreflightBlock"] = "PreflightBlock";
    PrivateNetworkRequestPolicy2["PreflightWarn"] = "PreflightWarn";
  })(PrivateNetworkRequestPolicy = Network2.PrivateNetworkRequestPolicy || (Network2.PrivateNetworkRequestPolicy = {}));
  let IPAddressSpace;
  ((IPAddressSpace2) => {
    IPAddressSpace2["Local"] = "Local";
    IPAddressSpace2["Private"] = "Private";
    IPAddressSpace2["Public"] = "Public";
    IPAddressSpace2["Unknown"] = "Unknown";
  })(IPAddressSpace = Network2.IPAddressSpace || (Network2.IPAddressSpace = {}));
  let CrossOriginOpenerPolicyValue;
  ((CrossOriginOpenerPolicyValue2) => {
    CrossOriginOpenerPolicyValue2["SameOrigin"] = "SameOrigin";
    CrossOriginOpenerPolicyValue2["SameOriginAllowPopups"] = "SameOriginAllowPopups";
    CrossOriginOpenerPolicyValue2["RestrictProperties"] = "RestrictProperties";
    CrossOriginOpenerPolicyValue2["UnsafeNone"] = "UnsafeNone";
    CrossOriginOpenerPolicyValue2["SameOriginPlusCoep"] = "SameOriginPlusCoep";
    CrossOriginOpenerPolicyValue2["RestrictPropertiesPlusCoep"] = "RestrictPropertiesPlusCoep";
    CrossOriginOpenerPolicyValue2["NoopenerAllowPopups"] = "NoopenerAllowPopups";
  })(CrossOriginOpenerPolicyValue = Network2.CrossOriginOpenerPolicyValue || (Network2.CrossOriginOpenerPolicyValue = {}));
  let CrossOriginEmbedderPolicyValue;
  ((CrossOriginEmbedderPolicyValue2) => {
    CrossOriginEmbedderPolicyValue2["None"] = "None";
    CrossOriginEmbedderPolicyValue2["Credentialless"] = "Credentialless";
    CrossOriginEmbedderPolicyValue2["RequireCorp"] = "RequireCorp";
  })(CrossOriginEmbedderPolicyValue = Network2.CrossOriginEmbedderPolicyValue || (Network2.CrossOriginEmbedderPolicyValue = {}));
  let ContentSecurityPolicySource;
  ((ContentSecurityPolicySource2) => {
    ContentSecurityPolicySource2["HTTP"] = "HTTP";
    ContentSecurityPolicySource2["Meta"] = "Meta";
  })(ContentSecurityPolicySource = Network2.ContentSecurityPolicySource || (Network2.ContentSecurityPolicySource = {}));
  let ReportStatus;
  ((ReportStatus2) => {
    ReportStatus2["Queued"] = "Queued";
    ReportStatus2["Pending"] = "Pending";
    ReportStatus2["MarkedForRemoval"] = "MarkedForRemoval";
    ReportStatus2["Success"] = "Success";
  })(ReportStatus = Network2.ReportStatus || (Network2.ReportStatus = {}));
  let TrustTokenOperationDoneEventStatus;
  ((TrustTokenOperationDoneEventStatus2) => {
    TrustTokenOperationDoneEventStatus2["Ok"] = "Ok";
    TrustTokenOperationDoneEventStatus2["InvalidArgument"] = "InvalidArgument";
    TrustTokenOperationDoneEventStatus2["MissingIssuerKeys"] = "MissingIssuerKeys";
    TrustTokenOperationDoneEventStatus2["FailedPrecondition"] = "FailedPrecondition";
    TrustTokenOperationDoneEventStatus2["ResourceExhausted"] = "ResourceExhausted";
    TrustTokenOperationDoneEventStatus2["AlreadyExists"] = "AlreadyExists";
    TrustTokenOperationDoneEventStatus2["ResourceLimited"] = "ResourceLimited";
    TrustTokenOperationDoneEventStatus2["Unauthorized"] = "Unauthorized";
    TrustTokenOperationDoneEventStatus2["BadResponse"] = "BadResponse";
    TrustTokenOperationDoneEventStatus2["InternalError"] = "InternalError";
    TrustTokenOperationDoneEventStatus2["UnknownError"] = "UnknownError";
    TrustTokenOperationDoneEventStatus2["FulfilledLocally"] = "FulfilledLocally";
  })(TrustTokenOperationDoneEventStatus = Network2.TrustTokenOperationDoneEventStatus || (Network2.TrustTokenOperationDoneEventStatus = {}));
})(Network || (Network = {}));
var Overlay;
((Overlay2) => {
  let LineStylePattern;
  ((LineStylePattern2) => {
    LineStylePattern2["Dashed"] = "dashed";
    LineStylePattern2["Dotted"] = "dotted";
  })(LineStylePattern = Overlay2.LineStylePattern || (Overlay2.LineStylePattern = {}));
  let ContrastAlgorithm;
  ((ContrastAlgorithm2) => {
    ContrastAlgorithm2["Aa"] = "aa";
    ContrastAlgorithm2["Aaa"] = "aaa";
    ContrastAlgorithm2["Apca"] = "apca";
  })(ContrastAlgorithm = Overlay2.ContrastAlgorithm || (Overlay2.ContrastAlgorithm = {}));
  let ColorFormat;
  ((ColorFormat2) => {
    ColorFormat2["Rgb"] = "rgb";
    ColorFormat2["Hsl"] = "hsl";
    ColorFormat2["Hwb"] = "hwb";
    ColorFormat2["Hex"] = "hex";
  })(ColorFormat = Overlay2.ColorFormat || (Overlay2.ColorFormat = {}));
  let InspectMode;
  ((InspectMode2) => {
    InspectMode2["SearchForNode"] = "searchForNode";
    InspectMode2["SearchForUAShadowDOM"] = "searchForUAShadowDOM";
    InspectMode2["CaptureAreaScreenshot"] = "captureAreaScreenshot";
    InspectMode2["ShowDistances"] = "showDistances";
    InspectMode2["None"] = "none";
  })(InspectMode = Overlay2.InspectMode || (Overlay2.InspectMode = {}));
})(Overlay || (Overlay = {}));
var Page;
((Page2) => {
  let AdFrameType;
  ((AdFrameType2) => {
    AdFrameType2["None"] = "none";
    AdFrameType2["Child"] = "child";
    AdFrameType2["Root"] = "root";
  })(AdFrameType = Page2.AdFrameType || (Page2.AdFrameType = {}));
  let AdFrameExplanation;
  ((AdFrameExplanation2) => {
    AdFrameExplanation2["ParentIsAd"] = "ParentIsAd";
    AdFrameExplanation2["CreatedByAdScript"] = "CreatedByAdScript";
    AdFrameExplanation2["MatchedBlockingRule"] = "MatchedBlockingRule";
  })(AdFrameExplanation = Page2.AdFrameExplanation || (Page2.AdFrameExplanation = {}));
  let SecureContextType;
  ((SecureContextType2) => {
    SecureContextType2["Secure"] = "Secure";
    SecureContextType2["SecureLocalhost"] = "SecureLocalhost";
    SecureContextType2["InsecureScheme"] = "InsecureScheme";
    SecureContextType2["InsecureAncestor"] = "InsecureAncestor";
  })(SecureContextType = Page2.SecureContextType || (Page2.SecureContextType = {}));
  let CrossOriginIsolatedContextType;
  ((CrossOriginIsolatedContextType2) => {
    CrossOriginIsolatedContextType2["Isolated"] = "Isolated";
    CrossOriginIsolatedContextType2["NotIsolated"] = "NotIsolated";
    CrossOriginIsolatedContextType2["NotIsolatedFeatureDisabled"] = "NotIsolatedFeatureDisabled";
  })(CrossOriginIsolatedContextType = Page2.CrossOriginIsolatedContextType || (Page2.CrossOriginIsolatedContextType = {}));
  let GatedAPIFeatures;
  ((GatedAPIFeatures2) => {
    GatedAPIFeatures2["SharedArrayBuffers"] = "SharedArrayBuffers";
    GatedAPIFeatures2["SharedArrayBuffersTransferAllowed"] = "SharedArrayBuffersTransferAllowed";
    GatedAPIFeatures2["PerformanceMeasureMemory"] = "PerformanceMeasureMemory";
    GatedAPIFeatures2["PerformanceProfile"] = "PerformanceProfile";
  })(GatedAPIFeatures = Page2.GatedAPIFeatures || (Page2.GatedAPIFeatures = {}));
  let PermissionsPolicyFeature;
  ((PermissionsPolicyFeature2) => {
    PermissionsPolicyFeature2["Accelerometer"] = "accelerometer";
    PermissionsPolicyFeature2["AllScreensCapture"] = "all-screens-capture";
    PermissionsPolicyFeature2["AmbientLightSensor"] = "ambient-light-sensor";
    PermissionsPolicyFeature2["AttributionReporting"] = "attribution-reporting";
    PermissionsPolicyFeature2["Autoplay"] = "autoplay";
    PermissionsPolicyFeature2["Bluetooth"] = "bluetooth";
    PermissionsPolicyFeature2["BrowsingTopics"] = "browsing-topics";
    PermissionsPolicyFeature2["Camera"] = "camera";
    PermissionsPolicyFeature2["CapturedSurfaceControl"] = "captured-surface-control";
    PermissionsPolicyFeature2["ChDpr"] = "ch-dpr";
    PermissionsPolicyFeature2["ChDeviceMemory"] = "ch-device-memory";
    PermissionsPolicyFeature2["ChDownlink"] = "ch-downlink";
    PermissionsPolicyFeature2["ChEct"] = "ch-ect";
    PermissionsPolicyFeature2["ChPrefersColorScheme"] = "ch-prefers-color-scheme";
    PermissionsPolicyFeature2["ChPrefersReducedMotion"] = "ch-prefers-reduced-motion";
    PermissionsPolicyFeature2["ChPrefersReducedTransparency"] = "ch-prefers-reduced-transparency";
    PermissionsPolicyFeature2["ChRtt"] = "ch-rtt";
    PermissionsPolicyFeature2["ChSaveData"] = "ch-save-data";
    PermissionsPolicyFeature2["ChUa"] = "ch-ua";
    PermissionsPolicyFeature2["ChUaArch"] = "ch-ua-arch";
    PermissionsPolicyFeature2["ChUaBitness"] = "ch-ua-bitness";
    PermissionsPolicyFeature2["ChUaPlatform"] = "ch-ua-platform";
    PermissionsPolicyFeature2["ChUaModel"] = "ch-ua-model";
    PermissionsPolicyFeature2["ChUaMobile"] = "ch-ua-mobile";
    PermissionsPolicyFeature2["ChUaFormFactors"] = "ch-ua-form-factors";
    PermissionsPolicyFeature2["ChUaFullVersion"] = "ch-ua-full-version";
    PermissionsPolicyFeature2["ChUaFullVersionList"] = "ch-ua-full-version-list";
    PermissionsPolicyFeature2["ChUaPlatformVersion"] = "ch-ua-platform-version";
    PermissionsPolicyFeature2["ChUaWow64"] = "ch-ua-wow64";
    PermissionsPolicyFeature2["ChViewportHeight"] = "ch-viewport-height";
    PermissionsPolicyFeature2["ChViewportWidth"] = "ch-viewport-width";
    PermissionsPolicyFeature2["ChWidth"] = "ch-width";
    PermissionsPolicyFeature2["ClipboardRead"] = "clipboard-read";
    PermissionsPolicyFeature2["ClipboardWrite"] = "clipboard-write";
    PermissionsPolicyFeature2["ComputePressure"] = "compute-pressure";
    PermissionsPolicyFeature2["ControlledFrame"] = "controlled-frame";
    PermissionsPolicyFeature2["CrossOriginIsolated"] = "cross-origin-isolated";
    PermissionsPolicyFeature2["DeferredFetch"] = "deferred-fetch";
    PermissionsPolicyFeature2["DeferredFetchMinimal"] = "deferred-fetch-minimal";
    PermissionsPolicyFeature2["DigitalCredentialsGet"] = "digital-credentials-get";
    PermissionsPolicyFeature2["DirectSockets"] = "direct-sockets";
    PermissionsPolicyFeature2["DirectSocketsPrivate"] = "direct-sockets-private";
    PermissionsPolicyFeature2["DisplayCapture"] = "display-capture";
    PermissionsPolicyFeature2["DocumentDomain"] = "document-domain";
    PermissionsPolicyFeature2["EncryptedMedia"] = "encrypted-media";
    PermissionsPolicyFeature2["ExecutionWhileOutOfViewport"] = "execution-while-out-of-viewport";
    PermissionsPolicyFeature2["ExecutionWhileNotRendered"] = "execution-while-not-rendered";
    PermissionsPolicyFeature2["FencedUnpartitionedStorageRead"] = "fenced-unpartitioned-storage-read";
    PermissionsPolicyFeature2["FocusWithoutUserActivation"] = "focus-without-user-activation";
    PermissionsPolicyFeature2["Fullscreen"] = "fullscreen";
    PermissionsPolicyFeature2["Frobulate"] = "frobulate";
    PermissionsPolicyFeature2["Gamepad"] = "gamepad";
    PermissionsPolicyFeature2["Geolocation"] = "geolocation";
    PermissionsPolicyFeature2["Gyroscope"] = "gyroscope";
    PermissionsPolicyFeature2["Hid"] = "hid";
    PermissionsPolicyFeature2["IdentityCredentialsGet"] = "identity-credentials-get";
    PermissionsPolicyFeature2["IdleDetection"] = "idle-detection";
    PermissionsPolicyFeature2["InterestCohort"] = "interest-cohort";
    PermissionsPolicyFeature2["JoinAdInterestGroup"] = "join-ad-interest-group";
    PermissionsPolicyFeature2["KeyboardMap"] = "keyboard-map";
    PermissionsPolicyFeature2["LocalFonts"] = "local-fonts";
    PermissionsPolicyFeature2["Magnetometer"] = "magnetometer";
    PermissionsPolicyFeature2["MediaPlaybackWhileNotVisible"] = "media-playback-while-not-visible";
    PermissionsPolicyFeature2["Microphone"] = "microphone";
    PermissionsPolicyFeature2["Midi"] = "midi";
    PermissionsPolicyFeature2["OtpCredentials"] = "otp-credentials";
    PermissionsPolicyFeature2["Payment"] = "payment";
    PermissionsPolicyFeature2["PictureInPicture"] = "picture-in-picture";
    PermissionsPolicyFeature2["Popins"] = "popins";
    PermissionsPolicyFeature2["PrivateAggregation"] = "private-aggregation";
    PermissionsPolicyFeature2["PrivateStateTokenIssuance"] = "private-state-token-issuance";
    PermissionsPolicyFeature2["PrivateStateTokenRedemption"] = "private-state-token-redemption";
    PermissionsPolicyFeature2["PublickeyCredentialsCreate"] = "publickey-credentials-create";
    PermissionsPolicyFeature2["PublickeyCredentialsGet"] = "publickey-credentials-get";
    PermissionsPolicyFeature2["RunAdAuction"] = "run-ad-auction";
    PermissionsPolicyFeature2["ScreenWakeLock"] = "screen-wake-lock";
    PermissionsPolicyFeature2["Serial"] = "serial";
    PermissionsPolicyFeature2["SharedAutofill"] = "shared-autofill";
    PermissionsPolicyFeature2["SharedStorage"] = "shared-storage";
    PermissionsPolicyFeature2["SharedStorageSelectUrl"] = "shared-storage-select-url";
    PermissionsPolicyFeature2["SmartCard"] = "smart-card";
    PermissionsPolicyFeature2["SpeakerSelection"] = "speaker-selection";
    PermissionsPolicyFeature2["StorageAccess"] = "storage-access";
    PermissionsPolicyFeature2["SubApps"] = "sub-apps";
    PermissionsPolicyFeature2["SyncXhr"] = "sync-xhr";
    PermissionsPolicyFeature2["Unload"] = "unload";
    PermissionsPolicyFeature2["Usb"] = "usb";
    PermissionsPolicyFeature2["UsbUnrestricted"] = "usb-unrestricted";
    PermissionsPolicyFeature2["VerticalScroll"] = "vertical-scroll";
    PermissionsPolicyFeature2["WebAppInstallation"] = "web-app-installation";
    PermissionsPolicyFeature2["WebPrinting"] = "web-printing";
    PermissionsPolicyFeature2["WebShare"] = "web-share";
    PermissionsPolicyFeature2["WindowManagement"] = "window-management";
    PermissionsPolicyFeature2["XrSpatialTracking"] = "xr-spatial-tracking";
  })(PermissionsPolicyFeature = Page2.PermissionsPolicyFeature || (Page2.PermissionsPolicyFeature = {}));
  let PermissionsPolicyBlockReason;
  ((PermissionsPolicyBlockReason2) => {
    PermissionsPolicyBlockReason2["Header"] = "Header";
    PermissionsPolicyBlockReason2["IframeAttribute"] = "IframeAttribute";
    PermissionsPolicyBlockReason2["InFencedFrameTree"] = "InFencedFrameTree";
    PermissionsPolicyBlockReason2["InIsolatedApp"] = "InIsolatedApp";
  })(PermissionsPolicyBlockReason = Page2.PermissionsPolicyBlockReason || (Page2.PermissionsPolicyBlockReason = {}));
  let OriginTrialTokenStatus;
  ((OriginTrialTokenStatus2) => {
    OriginTrialTokenStatus2["Success"] = "Success";
    OriginTrialTokenStatus2["NotSupported"] = "NotSupported";
    OriginTrialTokenStatus2["Insecure"] = "Insecure";
    OriginTrialTokenStatus2["Expired"] = "Expired";
    OriginTrialTokenStatus2["WrongOrigin"] = "WrongOrigin";
    OriginTrialTokenStatus2["InvalidSignature"] = "InvalidSignature";
    OriginTrialTokenStatus2["Malformed"] = "Malformed";
    OriginTrialTokenStatus2["WrongVersion"] = "WrongVersion";
    OriginTrialTokenStatus2["FeatureDisabled"] = "FeatureDisabled";
    OriginTrialTokenStatus2["TokenDisabled"] = "TokenDisabled";
    OriginTrialTokenStatus2["FeatureDisabledForUser"] = "FeatureDisabledForUser";
    OriginTrialTokenStatus2["UnknownTrial"] = "UnknownTrial";
  })(OriginTrialTokenStatus = Page2.OriginTrialTokenStatus || (Page2.OriginTrialTokenStatus = {}));
  let OriginTrialStatus;
  ((OriginTrialStatus2) => {
    OriginTrialStatus2["Enabled"] = "Enabled";
    OriginTrialStatus2["ValidTokenNotProvided"] = "ValidTokenNotProvided";
    OriginTrialStatus2["OSNotSupported"] = "OSNotSupported";
    OriginTrialStatus2["TrialNotAllowed"] = "TrialNotAllowed";
  })(OriginTrialStatus = Page2.OriginTrialStatus || (Page2.OriginTrialStatus = {}));
  let OriginTrialUsageRestriction;
  ((OriginTrialUsageRestriction2) => {
    OriginTrialUsageRestriction2["None"] = "None";
    OriginTrialUsageRestriction2["Subset"] = "Subset";
  })(OriginTrialUsageRestriction = Page2.OriginTrialUsageRestriction || (Page2.OriginTrialUsageRestriction = {}));
  let TransitionType;
  ((TransitionType2) => {
    TransitionType2["Link"] = "link";
    TransitionType2["Typed"] = "typed";
    TransitionType2["Address_bar"] = "address_bar";
    TransitionType2["Auto_bookmark"] = "auto_bookmark";
    TransitionType2["Auto_subframe"] = "auto_subframe";
    TransitionType2["Manual_subframe"] = "manual_subframe";
    TransitionType2["Generated"] = "generated";
    TransitionType2["Auto_toplevel"] = "auto_toplevel";
    TransitionType2["Form_submit"] = "form_submit";
    TransitionType2["Reload"] = "reload";
    TransitionType2["Keyword"] = "keyword";
    TransitionType2["Keyword_generated"] = "keyword_generated";
    TransitionType2["Other"] = "other";
  })(TransitionType = Page2.TransitionType || (Page2.TransitionType = {}));
  let DialogType;
  ((DialogType2) => {
    DialogType2["Alert"] = "alert";
    DialogType2["Confirm"] = "confirm";
    DialogType2["Prompt"] = "prompt";
    DialogType2["Beforeunload"] = "beforeunload";
  })(DialogType = Page2.DialogType || (Page2.DialogType = {}));
  let ClientNavigationReason;
  ((ClientNavigationReason2) => {
    ClientNavigationReason2["AnchorClick"] = "anchorClick";
    ClientNavigationReason2["FormSubmissionGet"] = "formSubmissionGet";
    ClientNavigationReason2["FormSubmissionPost"] = "formSubmissionPost";
    ClientNavigationReason2["HttpHeaderRefresh"] = "httpHeaderRefresh";
    ClientNavigationReason2["InitialFrameNavigation"] = "initialFrameNavigation";
    ClientNavigationReason2["MetaTagRefresh"] = "metaTagRefresh";
    ClientNavigationReason2["Other"] = "other";
    ClientNavigationReason2["PageBlockInterstitial"] = "pageBlockInterstitial";
    ClientNavigationReason2["Reload"] = "reload";
    ClientNavigationReason2["ScriptInitiated"] = "scriptInitiated";
  })(ClientNavigationReason = Page2.ClientNavigationReason || (Page2.ClientNavigationReason = {}));
  let ClientNavigationDisposition;
  ((ClientNavigationDisposition2) => {
    ClientNavigationDisposition2["CurrentTab"] = "currentTab";
    ClientNavigationDisposition2["NewTab"] = "newTab";
    ClientNavigationDisposition2["NewWindow"] = "newWindow";
    ClientNavigationDisposition2["Download"] = "download";
  })(ClientNavigationDisposition = Page2.ClientNavigationDisposition || (Page2.ClientNavigationDisposition = {}));
  let ReferrerPolicy;
  ((ReferrerPolicy2) => {
    ReferrerPolicy2["NoReferrer"] = "noReferrer";
    ReferrerPolicy2["NoReferrerWhenDowngrade"] = "noReferrerWhenDowngrade";
    ReferrerPolicy2["Origin"] = "origin";
    ReferrerPolicy2["OriginWhenCrossOrigin"] = "originWhenCrossOrigin";
    ReferrerPolicy2["SameOrigin"] = "sameOrigin";
    ReferrerPolicy2["StrictOrigin"] = "strictOrigin";
    ReferrerPolicy2["StrictOriginWhenCrossOrigin"] = "strictOriginWhenCrossOrigin";
    ReferrerPolicy2["UnsafeUrl"] = "unsafeUrl";
  })(ReferrerPolicy = Page2.ReferrerPolicy || (Page2.ReferrerPolicy = {}));
  let AutoResponseMode;
  ((AutoResponseMode2) => {
    AutoResponseMode2["None"] = "none";
    AutoResponseMode2["AutoAccept"] = "autoAccept";
    AutoResponseMode2["AutoReject"] = "autoReject";
    AutoResponseMode2["AutoOptOut"] = "autoOptOut";
  })(AutoResponseMode = Page2.AutoResponseMode || (Page2.AutoResponseMode = {}));
  let NavigationType;
  ((NavigationType2) => {
    NavigationType2["Navigation"] = "Navigation";
    NavigationType2["BackForwardCacheRestore"] = "BackForwardCacheRestore";
  })(NavigationType = Page2.NavigationType || (Page2.NavigationType = {}));
  let BackForwardCacheNotRestoredReason;
  ((BackForwardCacheNotRestoredReason2) => {
    BackForwardCacheNotRestoredReason2["NotPrimaryMainFrame"] = "NotPrimaryMainFrame";
    BackForwardCacheNotRestoredReason2["BackForwardCacheDisabled"] = "BackForwardCacheDisabled";
    BackForwardCacheNotRestoredReason2["RelatedActiveContentsExist"] = "RelatedActiveContentsExist";
    BackForwardCacheNotRestoredReason2["HTTPStatusNotOK"] = "HTTPStatusNotOK";
    BackForwardCacheNotRestoredReason2["SchemeNotHTTPOrHTTPS"] = "SchemeNotHTTPOrHTTPS";
    BackForwardCacheNotRestoredReason2["Loading"] = "Loading";
    BackForwardCacheNotRestoredReason2["WasGrantedMediaAccess"] = "WasGrantedMediaAccess";
    BackForwardCacheNotRestoredReason2["DisableForRenderFrameHostCalled"] = "DisableForRenderFrameHostCalled";
    BackForwardCacheNotRestoredReason2["DomainNotAllowed"] = "DomainNotAllowed";
    BackForwardCacheNotRestoredReason2["HTTPMethodNotGET"] = "HTTPMethodNotGET";
    BackForwardCacheNotRestoredReason2["SubframeIsNavigating"] = "SubframeIsNavigating";
    BackForwardCacheNotRestoredReason2["Timeout"] = "Timeout";
    BackForwardCacheNotRestoredReason2["CacheLimit"] = "CacheLimit";
    BackForwardCacheNotRestoredReason2["JavaScriptExecution"] = "JavaScriptExecution";
    BackForwardCacheNotRestoredReason2["RendererProcessKilled"] = "RendererProcessKilled";
    BackForwardCacheNotRestoredReason2["RendererProcessCrashed"] = "RendererProcessCrashed";
    BackForwardCacheNotRestoredReason2["SchedulerTrackedFeatureUsed"] = "SchedulerTrackedFeatureUsed";
    BackForwardCacheNotRestoredReason2["ConflictingBrowsingInstance"] = "ConflictingBrowsingInstance";
    BackForwardCacheNotRestoredReason2["CacheFlushed"] = "CacheFlushed";
    BackForwardCacheNotRestoredReason2["ServiceWorkerVersionActivation"] = "ServiceWorkerVersionActivation";
    BackForwardCacheNotRestoredReason2["SessionRestored"] = "SessionRestored";
    BackForwardCacheNotRestoredReason2["ServiceWorkerPostMessage"] = "ServiceWorkerPostMessage";
    BackForwardCacheNotRestoredReason2["EnteredBackForwardCacheBeforeServiceWorkerHostAdded"] = "EnteredBackForwardCacheBeforeServiceWorkerHostAdded";
    BackForwardCacheNotRestoredReason2["RenderFrameHostReused_SameSite"] = "RenderFrameHostReused_SameSite";
    BackForwardCacheNotRestoredReason2["RenderFrameHostReused_CrossSite"] = "RenderFrameHostReused_CrossSite";
    BackForwardCacheNotRestoredReason2["ServiceWorkerClaim"] = "ServiceWorkerClaim";
    BackForwardCacheNotRestoredReason2["IgnoreEventAndEvict"] = "IgnoreEventAndEvict";
    BackForwardCacheNotRestoredReason2["HaveInnerContents"] = "HaveInnerContents";
    BackForwardCacheNotRestoredReason2["TimeoutPuttingInCache"] = "TimeoutPuttingInCache";
    BackForwardCacheNotRestoredReason2["BackForwardCacheDisabledByLowMemory"] = "BackForwardCacheDisabledByLowMemory";
    BackForwardCacheNotRestoredReason2["BackForwardCacheDisabledByCommandLine"] = "BackForwardCacheDisabledByCommandLine";
    BackForwardCacheNotRestoredReason2["NetworkRequestDatAPIpeDrainedAsBytesConsumer"] = "NetworkRequestDatapipeDrainedAsBytesConsumer";
    BackForwardCacheNotRestoredReason2["NetworkRequestRedirected"] = "NetworkRequestRedirected";
    BackForwardCacheNotRestoredReason2["NetworkRequestTimeout"] = "NetworkRequestTimeout";
    BackForwardCacheNotRestoredReason2["NetworkExceedsBufferLimit"] = "NetworkExceedsBufferLimit";
    BackForwardCacheNotRestoredReason2["NavigationCancelledWhileRestoring"] = "NavigationCancelledWhileRestoring";
    BackForwardCacheNotRestoredReason2["NotMostRecentNavigationEntry"] = "NotMostRecentNavigationEntry";
    BackForwardCacheNotRestoredReason2["BackForwardCacheDisabledForPrerender"] = "BackForwardCacheDisabledForPrerender";
    BackForwardCacheNotRestoredReason2["UserAgentOverrideDiffers"] = "UserAgentOverrideDiffers";
    BackForwardCacheNotRestoredReason2["ForegroundCacheLimit"] = "ForegroundCacheLimit";
    BackForwardCacheNotRestoredReason2["BrowsingInstanceNotSwapped"] = "BrowsingInstanceNotSwapped";
    BackForwardCacheNotRestoredReason2["BackForwardCacheDisabledForDelegate"] = "BackForwardCacheDisabledForDelegate";
    BackForwardCacheNotRestoredReason2["UnloadHandlerExistsInMainFrame"] = "UnloadHandlerExistsInMainFrame";
    BackForwardCacheNotRestoredReason2["UnloadHandlerExistsInSubFrame"] = "UnloadHandlerExistsInSubFrame";
    BackForwardCacheNotRestoredReason2["ServiceWorkerUnregistration"] = "ServiceWorkerUnregistration";
    BackForwardCacheNotRestoredReason2["CacheControlNoStore"] = "CacheControlNoStore";
    BackForwardCacheNotRestoredReason2["CacheControlNoStoreCookieModified"] = "CacheControlNoStoreCookieModified";
    BackForwardCacheNotRestoredReason2["CacheControlNoStoreHTTPOnlyCookieModified"] = "CacheControlNoStoreHTTPOnlyCookieModified";
    BackForwardCacheNotRestoredReason2["NoResponseHead"] = "NoResponseHead";
    BackForwardCacheNotRestoredReason2["Unknown"] = "Unknown";
    BackForwardCacheNotRestoredReason2["ActivationNavigationsDisallowedForBug1234857"] = "ActivationNavigationsDisallowedForBug1234857";
    BackForwardCacheNotRestoredReason2["ErrorDocument"] = "ErrorDocument";
    BackForwardCacheNotRestoredReason2["FencedFramesEmbedder"] = "FencedFramesEmbedder";
    BackForwardCacheNotRestoredReason2["CookieDisabled"] = "CookieDisabled";
    BackForwardCacheNotRestoredReason2["HTTPAuthRequired"] = "HTTPAuthRequired";
    BackForwardCacheNotRestoredReason2["CookieFlushed"] = "CookieFlushed";
    BackForwardCacheNotRestoredReason2["BroadcastChannelOnMessage"] = "BroadcastChannelOnMessage";
    BackForwardCacheNotRestoredReason2["WebViewSettingsChanged"] = "WebViewSettingsChanged";
    BackForwardCacheNotRestoredReason2["WebViewJavaScriptObjectChanged"] = "WebViewJavaScriptObjectChanged";
    BackForwardCacheNotRestoredReason2["WebViewMessageListenerInjected"] = "WebViewMessageListenerInjected";
    BackForwardCacheNotRestoredReason2["WebViewSafeBrowsingAllowlistChanged"] = "WebViewSafeBrowsingAllowlistChanged";
    BackForwardCacheNotRestoredReason2["WebViewDocumentStartJavascriptChanged"] = "WebViewDocumentStartJavascriptChanged";
    BackForwardCacheNotRestoredReason2["WebSocket"] = "WebSocket";
    BackForwardCacheNotRestoredReason2["WebTransport"] = "WebTransport";
    BackForwardCacheNotRestoredReason2["WebRTC"] = "WebRTC";
    BackForwardCacheNotRestoredReason2["MainResourceHasCacheControlNoStore"] = "MainResourceHasCacheControlNoStore";
    BackForwardCacheNotRestoredReason2["MainResourceHasCacheControlNoCache"] = "MainResourceHasCacheControlNoCache";
    BackForwardCacheNotRestoredReason2["SubresourceHasCacheControlNoStore"] = "SubresourceHasCacheControlNoStore";
    BackForwardCacheNotRestoredReason2["SubresourceHasCacheControlNoCache"] = "SubresourceHasCacheControlNoCache";
    BackForwardCacheNotRestoredReason2["ContainsPlugins"] = "ContainsPlugins";
    BackForwardCacheNotRestoredReason2["DocumentLoaded"] = "DocumentLoaded";
    BackForwardCacheNotRestoredReason2["OutstandingNetworkRequestOthers"] = "OutstandingNetworkRequestOthers";
    BackForwardCacheNotRestoredReason2["RequestedMIDIPermission"] = "RequestedMIDIPermission";
    BackForwardCacheNotRestoredReason2["RequestedAudioCapturePermission"] = "RequestedAudioCapturePermission";
    BackForwardCacheNotRestoredReason2["RequestedVideoCapturePermission"] = "RequestedVideoCapturePermission";
    BackForwardCacheNotRestoredReason2["RequestedBackForwardCacheBlockedSensors"] = "RequestedBackForwardCacheBlockedSensors";
    BackForwardCacheNotRestoredReason2["RequestedBackgroundWorkPermission"] = "RequestedBackgroundWorkPermission";
    BackForwardCacheNotRestoredReason2["BroadcastChannel"] = "BroadcastChannel";
    BackForwardCacheNotRestoredReason2["WebXR"] = "WebXR";
    BackForwardCacheNotRestoredReason2["SharedWorker"] = "SharedWorker";
    BackForwardCacheNotRestoredReason2["WebLocks"] = "WebLocks";
    BackForwardCacheNotRestoredReason2["WebHID"] = "WebHID";
    BackForwardCacheNotRestoredReason2["WebShare"] = "WebShare";
    BackForwardCacheNotRestoredReason2["RequestedStorageAccessGrant"] = "RequestedStorageAccessGrant";
    BackForwardCacheNotRestoredReason2["WebNfc"] = "WebNfc";
    BackForwardCacheNotRestoredReason2["OutstandingNetworkRequestFetch"] = "OutstandingNetworkRequestFetch";
    BackForwardCacheNotRestoredReason2["OutstandingNetworkRequestXHR"] = "OutstandingNetworkRequestXHR";
    BackForwardCacheNotRestoredReason2["AppBanner"] = "AppBanner";
    BackForwardCacheNotRestoredReason2["Printing"] = "Printing";
    BackForwardCacheNotRestoredReason2["WebDatabase"] = "WebDatabase";
    BackForwardCacheNotRestoredReason2["PictureInPicture"] = "PictureInPicture";
    BackForwardCacheNotRestoredReason2["SpeechRecognizer"] = "SpeechRecognizer";
    BackForwardCacheNotRestoredReason2["IdleManager"] = "IdleManager";
    BackForwardCacheNotRestoredReason2["PaymentManager"] = "PaymentManager";
    BackForwardCacheNotRestoredReason2["SpeechSynthesis"] = "SpeechSynthesis";
    BackForwardCacheNotRestoredReason2["KeyboardLock"] = "KeyboardLock";
    BackForwardCacheNotRestoredReason2["WebOTPService"] = "WebOTPService";
    BackForwardCacheNotRestoredReason2["OutstandingNetworkRequestDirectSocket"] = "OutstandingNetworkRequestDirectSocket";
    BackForwardCacheNotRestoredReason2["InjectedJavascript"] = "InjectedJavascript";
    BackForwardCacheNotRestoredReason2["InjectedStyleSheet"] = "InjectedStyleSheet";
    BackForwardCacheNotRestoredReason2["KeepaliveRequest"] = "KeepaliveRequest";
    BackForwardCacheNotRestoredReason2["IndexedDBEvent"] = "IndexedDBEvent";
    BackForwardCacheNotRestoredReason2["Dummy"] = "Dummy";
    BackForwardCacheNotRestoredReason2["JsNetworkRequestReceivedCacheControlNoStoreResource"] = "JsNetworkRequestReceivedCacheControlNoStoreResource";
    BackForwardCacheNotRestoredReason2["WebRTCSticky"] = "WebRTCSticky";
    BackForwardCacheNotRestoredReason2["WebTransportSticky"] = "WebTransportSticky";
    BackForwardCacheNotRestoredReason2["WebSocketSticky"] = "WebSocketSticky";
    BackForwardCacheNotRestoredReason2["SmartCard"] = "SmartCard";
    BackForwardCacheNotRestoredReason2["LiveMediaStreamTrack"] = "LiveMediaStreamTrack";
    BackForwardCacheNotRestoredReason2["UnloadHandler"] = "UnloadHandler";
    BackForwardCacheNotRestoredReason2["ParserAborted"] = "ParserAborted";
    BackForwardCacheNotRestoredReason2["ContentSecurityHandler"] = "ContentSecurityHandler";
    BackForwardCacheNotRestoredReason2["ContentWebAuthenticationAPI"] = "ContentWebAuthenticationAPI";
    BackForwardCacheNotRestoredReason2["ContentFileChooser"] = "ContentFileChooser";
    BackForwardCacheNotRestoredReason2["ContentSerial"] = "ContentSerial";
    BackForwardCacheNotRestoredReason2["ContentFileSystemAccess"] = "ContentFileSystemAccess";
    BackForwardCacheNotRestoredReason2["ContentMediaDevicesDispatcherHost"] = "ContentMediaDevicesDispatcherHost";
    BackForwardCacheNotRestoredReason2["ContentWebBluetooth"] = "ContentWebBluetooth";
    BackForwardCacheNotRestoredReason2["ContentWebUSB"] = "ContentWebUSB";
    BackForwardCacheNotRestoredReason2["ContentMediaSessionService"] = "ContentMediaSessionService";
    BackForwardCacheNotRestoredReason2["ContentScreenReader"] = "ContentScreenReader";
    BackForwardCacheNotRestoredReason2["ContentDiscarded"] = "ContentDiscarded";
    BackForwardCacheNotRestoredReason2["EmbedderPopupBlockerTabHelper"] = "EmbedderPopupBlockerTabHelper";
    BackForwardCacheNotRestoredReason2["EmbedderSafeBrowsingTriggeredPopupBlocker"] = "EmbedderSafeBrowsingTriggeredPopupBlocker";
    BackForwardCacheNotRestoredReason2["EmbedderSafeBrowsingThreatDetails"] = "EmbedderSafeBrowsingThreatDetails";
    BackForwardCacheNotRestoredReason2["EmbedderAppBannerManager"] = "EmbedderAppBannerManager";
    BackForwardCacheNotRestoredReason2["EmbedderDomDistillerViewerSource"] = "EmbedderDomDistillerViewerSource";
    BackForwardCacheNotRestoredReason2["EmbedderDomDistillerSelfDeletingRequestDelegate"] = "EmbedderDomDistillerSelfDeletingRequestDelegate";
    BackForwardCacheNotRestoredReason2["EmbedderOomInterventionTabHelper"] = "EmbedderOomInterventionTabHelper";
    BackForwardCacheNotRestoredReason2["EmbedderOfflinePage"] = "EmbedderOfflinePage";
    BackForwardCacheNotRestoredReason2["EmbedderChromePasswordManagerClientBindCredentialManager"] = "EmbedderChromePasswordManagerClientBindCredentialManager";
    BackForwardCacheNotRestoredReason2["EmbedderPermissionRequestManager"] = "EmbedderPermissionRequestManager";
    BackForwardCacheNotRestoredReason2["EmbedderModalDialog"] = "EmbedderModalDialog";
    BackForwardCacheNotRestoredReason2["EmbedderExtensions"] = "EmbedderExtensions";
    BackForwardCacheNotRestoredReason2["EmbedderExtensionMessaging"] = "EmbedderExtensionMessaging";
    BackForwardCacheNotRestoredReason2["EmbedderExtensionMessagingForOpenPort"] = "EmbedderExtensionMessagingForOpenPort";
    BackForwardCacheNotRestoredReason2["EmbedderExtensionSentMessageToCachedFrame"] = "EmbedderExtensionSentMessageToCachedFrame";
    BackForwardCacheNotRestoredReason2["RequestedByWebViewClient"] = "RequestedByWebViewClient";
    BackForwardCacheNotRestoredReason2["PostMessageByWebViewClient"] = "PostMessageByWebViewClient";
  })(BackForwardCacheNotRestoredReason = Page2.BackForwardCacheNotRestoredReason || (Page2.BackForwardCacheNotRestoredReason = {}));
  let BackForwardCacheNotRestoredReasonType;
  ((BackForwardCacheNotRestoredReasonType2) => {
    BackForwardCacheNotRestoredReasonType2["SupportPending"] = "SupportPending";
    BackForwardCacheNotRestoredReasonType2["PageSupportNeeded"] = "PageSupportNeeded";
    BackForwardCacheNotRestoredReasonType2["Circumstantial"] = "Circumstantial";
  })(BackForwardCacheNotRestoredReasonType = Page2.BackForwardCacheNotRestoredReasonType || (Page2.BackForwardCacheNotRestoredReasonType = {}));
  let CaptureScreenshotRequestFormat;
  ((CaptureScreenshotRequestFormat2) => {
    CaptureScreenshotRequestFormat2["Jpeg"] = "jpeg";
    CaptureScreenshotRequestFormat2["Png"] = "png";
    CaptureScreenshotRequestFormat2["Webp"] = "webp";
  })(CaptureScreenshotRequestFormat = Page2.CaptureScreenshotRequestFormat || (Page2.CaptureScreenshotRequestFormat = {}));
  let CaptureSnapshotRequestFormat;
  ((CaptureSnapshotRequestFormat2) => {
    CaptureSnapshotRequestFormat2["MHTML"] = "mhtml";
  })(CaptureSnapshotRequestFormat = Page2.CaptureSnapshotRequestFormat || (Page2.CaptureSnapshotRequestFormat = {}));
  let PrintToPDFRequestTransferMode;
  ((PrintToPDFRequestTransferMode2) => {
    PrintToPDFRequestTransferMode2["ReturnAsBase64"] = "ReturnAsBase64";
    PrintToPDFRequestTransferMode2["ReturnAsStream"] = "ReturnAsStream";
  })(PrintToPDFRequestTransferMode = Page2.PrintToPDFRequestTransferMode || (Page2.PrintToPDFRequestTransferMode = {}));
  let SetDownloadBehaviorRequestBehavior;
  ((SetDownloadBehaviorRequestBehavior2) => {
    SetDownloadBehaviorRequestBehavior2["Deny"] = "deny";
    SetDownloadBehaviorRequestBehavior2["Allow"] = "allow";
    SetDownloadBehaviorRequestBehavior2["Default"] = "default";
  })(SetDownloadBehaviorRequestBehavior = Page2.SetDownloadBehaviorRequestBehavior || (Page2.SetDownloadBehaviorRequestBehavior = {}));
  let SetTouchEmulationEnabledRequestConfiguration;
  ((SetTouchEmulationEnabledRequestConfiguration2) => {
    SetTouchEmulationEnabledRequestConfiguration2["Mobile"] = "mobile";
    SetTouchEmulationEnabledRequestConfiguration2["Desktop"] = "desktop";
  })(SetTouchEmulationEnabledRequestConfiguration = Page2.SetTouchEmulationEnabledRequestConfiguration || (Page2.SetTouchEmulationEnabledRequestConfiguration = {}));
  let StartScreencastRequestFormat;
  ((StartScreencastRequestFormat2) => {
    StartScreencastRequestFormat2["Jpeg"] = "jpeg";
    StartScreencastRequestFormat2["Png"] = "png";
  })(StartScreencastRequestFormat = Page2.StartScreencastRequestFormat || (Page2.StartScreencastRequestFormat = {}));
  let SetWebLifecycleStateRequestState;
  ((SetWebLifecycleStateRequestState2) => {
    SetWebLifecycleStateRequestState2["Frozen"] = "frozen";
    SetWebLifecycleStateRequestState2["Active"] = "active";
  })(SetWebLifecycleStateRequestState = Page2.SetWebLifecycleStateRequestState || (Page2.SetWebLifecycleStateRequestState = {}));
  let FileChooserOpenedEventMode;
  ((FileChooserOpenedEventMode2) => {
    FileChooserOpenedEventMode2["SelectSingle"] = "selectSingle";
    FileChooserOpenedEventMode2["SelectMultiple"] = "selectMultiple";
  })(FileChooserOpenedEventMode = Page2.FileChooserOpenedEventMode || (Page2.FileChooserOpenedEventMode = {}));
  let FrameDetachedEventReason;
  ((FrameDetachedEventReason2) => {
    FrameDetachedEventReason2["Remove"] = "remove";
    FrameDetachedEventReason2["Swap"] = "swap";
  })(FrameDetachedEventReason = Page2.FrameDetachedEventReason || (Page2.FrameDetachedEventReason = {}));
  let DownloadProgressEventState;
  ((DownloadProgressEventState2) => {
    DownloadProgressEventState2["InProgress"] = "inProgress";
    DownloadProgressEventState2["Completed"] = "completed";
    DownloadProgressEventState2["Canceled"] = "canceled";
  })(DownloadProgressEventState = Page2.DownloadProgressEventState || (Page2.DownloadProgressEventState = {}));
  let NavigatedWithinDocumentEventNavigationType;
  ((NavigatedWithinDocumentEventNavigationType2) => {
    NavigatedWithinDocumentEventNavigationType2["Fragment"] = "fragment";
    NavigatedWithinDocumentEventNavigationType2["HistoryAPI"] = "historyApi";
    NavigatedWithinDocumentEventNavigationType2["Other"] = "other";
  })(NavigatedWithinDocumentEventNavigationType = Page2.NavigatedWithinDocumentEventNavigationType || (Page2.NavigatedWithinDocumentEventNavigationType = {}));
})(Page || (Page = {}));
var Performance;
((Performance2) => {
  let EnableRequestTimeDomain;
  ((EnableRequestTimeDomain2) => {
    EnableRequestTimeDomain2["TimeTicks"] = "timeTicks";
    EnableRequestTimeDomain2["ThreadTicks"] = "threadTicks";
  })(EnableRequestTimeDomain = Performance2.EnableRequestTimeDomain || (Performance2.EnableRequestTimeDomain = {}));
  let SetTimeDomainRequestTimeDomain;
  ((SetTimeDomainRequestTimeDomain2) => {
    SetTimeDomainRequestTimeDomain2["TimeTicks"] = "timeTicks";
    SetTimeDomainRequestTimeDomain2["ThreadTicks"] = "threadTicks";
  })(SetTimeDomainRequestTimeDomain = Performance2.SetTimeDomainRequestTimeDomain || (Performance2.SetTimeDomainRequestTimeDomain = {}));
})(Performance || (Performance = {}));
var Security;
((Security2) => {
  let MixedContentType;
  ((MixedContentType2) => {
    MixedContentType2["Blockable"] = "blockable";
    MixedContentType2["OptionallyBlockable"] = "optionally-blockable";
    MixedContentType2["None"] = "none";
  })(MixedContentType = Security2.MixedContentType || (Security2.MixedContentType = {}));
  let SecurityState;
  ((SecurityState2) => {
    SecurityState2["Unknown"] = "unknown";
    SecurityState2["Neutral"] = "neutral";
    SecurityState2["Insecure"] = "insecure";
    SecurityState2["Secure"] = "secure";
    SecurityState2["Info"] = "info";
    SecurityState2["InsecureBroken"] = "insecure-broken";
  })(SecurityState = Security2.SecurityState || (Security2.SecurityState = {}));
  let SafetyTipStatus;
  ((SafetyTipStatus2) => {
    SafetyTipStatus2["BadReputation"] = "badReputation";
    SafetyTipStatus2["Lookalike"] = "lookalike";
  })(SafetyTipStatus = Security2.SafetyTipStatus || (Security2.SafetyTipStatus = {}));
  let CertificateErrorAction;
  ((CertificateErrorAction2) => {
    CertificateErrorAction2["Continue"] = "continue";
    CertificateErrorAction2["Cancel"] = "cancel";
  })(CertificateErrorAction = Security2.CertificateErrorAction || (Security2.CertificateErrorAction = {}));
})(Security || (Security = {}));
var ServiceWorker;
((ServiceWorker2) => {
  let ServiceWorkerVersionRunningStatus;
  ((ServiceWorkerVersionRunningStatus2) => {
    ServiceWorkerVersionRunningStatus2["Stopped"] = "stopped";
    ServiceWorkerVersionRunningStatus2["Starting"] = "starting";
    ServiceWorkerVersionRunningStatus2["Running"] = "running";
    ServiceWorkerVersionRunningStatus2["Stopping"] = "stopping";
  })(ServiceWorkerVersionRunningStatus = ServiceWorker2.ServiceWorkerVersionRunningStatus || (ServiceWorker2.ServiceWorkerVersionRunningStatus = {}));
  let ServiceWorkerVersionStatus;
  ((ServiceWorkerVersionStatus2) => {
    ServiceWorkerVersionStatus2["New"] = "new";
    ServiceWorkerVersionStatus2["Installing"] = "installing";
    ServiceWorkerVersionStatus2["Installed"] = "installed";
    ServiceWorkerVersionStatus2["Activating"] = "activating";
    ServiceWorkerVersionStatus2["Activated"] = "activated";
    ServiceWorkerVersionStatus2["Redundant"] = "redundant";
  })(ServiceWorkerVersionStatus = ServiceWorker2.ServiceWorkerVersionStatus || (ServiceWorker2.ServiceWorkerVersionStatus = {}));
})(ServiceWorker || (ServiceWorker = {}));
var Storage;
((Storage2) => {
  let StorageType;
  ((StorageType2) => {
    StorageType2["Appcache"] = "appcache";
    StorageType2["Cookies"] = "cookies";
    StorageType2["File_systems"] = "file_systems";
    StorageType2["Indexeddb"] = "indexeddb";
    StorageType2["Local_storage"] = "local_storage";
    StorageType2["Shader_cache"] = "shader_cache";
    StorageType2["Websql"] = "websql";
    StorageType2["Service_workers"] = "service_workers";
    StorageType2["Cache_storage"] = "cache_storage";
    StorageType2["Interest_groups"] = "interest_groups";
    StorageType2["Shared_storage"] = "shared_storage";
    StorageType2["Storage_buckets"] = "storage_buckets";
    StorageType2["All"] = "all";
    StorageType2["Other"] = "other";
  })(StorageType = Storage2.StorageType || (Storage2.StorageType = {}));
  let InterestGroupAccessType;
  ((InterestGroupAccessType2) => {
    InterestGroupAccessType2["Join"] = "join";
    InterestGroupAccessType2["Leave"] = "leave";
    InterestGroupAccessType2["Update"] = "update";
    InterestGroupAccessType2["Loaded"] = "loaded";
    InterestGroupAccessType2["Bid"] = "bid";
    InterestGroupAccessType2["Win"] = "win";
    InterestGroupAccessType2["AdditionalBid"] = "additionalBid";
    InterestGroupAccessType2["AdditionalBidWin"] = "additionalBidWin";
    InterestGroupAccessType2["TopLevelBid"] = "topLevelBid";
    InterestGroupAccessType2["TopLevelAdditionalBid"] = "topLevelAdditionalBid";
    InterestGroupAccessType2["Clear"] = "clear";
  })(InterestGroupAccessType = Storage2.InterestGroupAccessType || (Storage2.InterestGroupAccessType = {}));
  let InterestGroupAuctionEventType;
  ((InterestGroupAuctionEventType2) => {
    InterestGroupAuctionEventType2["Started"] = "started";
    InterestGroupAuctionEventType2["ConfigResolved"] = "configResolved";
  })(InterestGroupAuctionEventType = Storage2.InterestGroupAuctionEventType || (Storage2.InterestGroupAuctionEventType = {}));
  let InterestGroupAuctionFetchType;
  ((InterestGroupAuctionFetchType2) => {
    InterestGroupAuctionFetchType2["BidderJs"] = "bidderJs";
    InterestGroupAuctionFetchType2["BidderWasm"] = "bidderWasm";
    InterestGroupAuctionFetchType2["SellerJs"] = "sellerJs";
    InterestGroupAuctionFetchType2["BidderTrustedSignals"] = "bidderTrustedSignals";
    InterestGroupAuctionFetchType2["SellerTrustedSignals"] = "sellerTrustedSignals";
  })(InterestGroupAuctionFetchType = Storage2.InterestGroupAuctionFetchType || (Storage2.InterestGroupAuctionFetchType = {}));
  let SharedStorageAccessType;
  ((SharedStorageAccessType2) => {
    SharedStorageAccessType2["DocumentAddModule"] = "documentAddModule";
    SharedStorageAccessType2["DocumentSelectURL"] = "documentSelectURL";
    SharedStorageAccessType2["DocumentRun"] = "documentRun";
    SharedStorageAccessType2["DocumentSet"] = "documentSet";
    SharedStorageAccessType2["DocumentAppend"] = "documentAppend";
    SharedStorageAccessType2["DocumentDelete"] = "documentDelete";
    SharedStorageAccessType2["DocumentClear"] = "documentClear";
    SharedStorageAccessType2["DocumentGet"] = "documentGet";
    SharedStorageAccessType2["WorkletSet"] = "workletSet";
    SharedStorageAccessType2["WorkletAppend"] = "workletAppend";
    SharedStorageAccessType2["WorkletDelete"] = "workletDelete";
    SharedStorageAccessType2["WorkletClear"] = "workletClear";
    SharedStorageAccessType2["WorkletGet"] = "workletGet";
    SharedStorageAccessType2["WorkletKeys"] = "workletKeys";
    SharedStorageAccessType2["WorkletEntries"] = "workletEntries";
    SharedStorageAccessType2["WorkletLength"] = "workletLength";
    SharedStorageAccessType2["WorkletRemainingBudget"] = "workletRemainingBudget";
    SharedStorageAccessType2["HeaderSet"] = "headerSet";
    SharedStorageAccessType2["HeaderAppend"] = "headerAppend";
    SharedStorageAccessType2["HeaderDelete"] = "headerDelete";
    SharedStorageAccessType2["HeaderClear"] = "headerClear";
  })(SharedStorageAccessType = Storage2.SharedStorageAccessType || (Storage2.SharedStorageAccessType = {}));
  let StorageBucketsDurability;
  ((StorageBucketsDurability2) => {
    StorageBucketsDurability2["Relaxed"] = "relaxed";
    StorageBucketsDurability2["Strict"] = "strict";
  })(StorageBucketsDurability = Storage2.StorageBucketsDurability || (Storage2.StorageBucketsDurability = {}));
  let AttributionReportingSourceType;
  ((AttributionReportingSourceType2) => {
    AttributionReportingSourceType2["Navigation"] = "navigation";
    AttributionReportingSourceType2["Event"] = "event";
  })(AttributionReportingSourceType = Storage2.AttributionReportingSourceType || (Storage2.AttributionReportingSourceType = {}));
  let AttributionReportingTriggerDataMatching;
  ((AttributionReportingTriggerDataMatching2) => {
    AttributionReportingTriggerDataMatching2["Exact"] = "exact";
    AttributionReportingTriggerDataMatching2["Modulus"] = "modulus";
  })(AttributionReportingTriggerDataMatching = Storage2.AttributionReportingTriggerDataMatching || (Storage2.AttributionReportingTriggerDataMatching = {}));
  let AttributionReportingSourceRegistrationResult;
  ((AttributionReportingSourceRegistrationResult2) => {
    AttributionReportingSourceRegistrationResult2["Success"] = "success";
    AttributionReportingSourceRegistrationResult2["InternalError"] = "internalError";
    AttributionReportingSourceRegistrationResult2["InsufficientSourceCapacity"] = "insufficientSourceCapacity";
    AttributionReportingSourceRegistrationResult2["InsufficientUniqueDestinationCapacity"] = "insufficientUniqueDestinationCapacity";
    AttributionReportingSourceRegistrationResult2["ExcessiveReportingOrigins"] = "excessiveReportingOrigins";
    AttributionReportingSourceRegistrationResult2["ProhibitedByBrowserPolicy"] = "prohibitedByBrowserPolicy";
    AttributionReportingSourceRegistrationResult2["SuccessNoised"] = "successNoised";
    AttributionReportingSourceRegistrationResult2["DestinationReportingLimitReached"] = "destinationReportingLimitReached";
    AttributionReportingSourceRegistrationResult2["DestinationGlobalLimitReached"] = "destinationGlobalLimitReached";
    AttributionReportingSourceRegistrationResult2["DestinationBothLimitsReached"] = "destinationBothLimitsReached";
    AttributionReportingSourceRegistrationResult2["ReportingOriginsPerSiteLimitReached"] = "reportingOriginsPerSiteLimitReached";
    AttributionReportingSourceRegistrationResult2["ExceedsMaxChannelCapacity"] = "exceedsMaxChannelCapacity";
    AttributionReportingSourceRegistrationResult2["ExceedsMaxScopesChannelCapacity"] = "exceedsMaxScopesChannelCapacity";
    AttributionReportingSourceRegistrationResult2["ExceedsMaxTriggerStateCardinality"] = "exceedsMaxTriggerStateCardinality";
    AttributionReportingSourceRegistrationResult2["ExceedsMaxEventStatesLimit"] = "exceedsMaxEventStatesLimit";
    AttributionReportingSourceRegistrationResult2["DestinationPerDayReportingLimitReached"] = "destinationPerDayReportingLimitReached";
  })(AttributionReportingSourceRegistrationResult = Storage2.AttributionReportingSourceRegistrationResult || (Storage2.AttributionReportingSourceRegistrationResult = {}));
  let AttributionReportingSourceRegistrationTimeConfig;
  ((AttributionReportingSourceRegistrationTimeConfig2) => {
    AttributionReportingSourceRegistrationTimeConfig2["Include"] = "include";
    AttributionReportingSourceRegistrationTimeConfig2["Exclude"] = "exclude";
  })(AttributionReportingSourceRegistrationTimeConfig = Storage2.AttributionReportingSourceRegistrationTimeConfig || (Storage2.AttributionReportingSourceRegistrationTimeConfig = {}));
  let AttributionReportingEventLevelResult;
  ((AttributionReportingEventLevelResult2) => {
    AttributionReportingEventLevelResult2["Success"] = "success";
    AttributionReportingEventLevelResult2["SuccessDroppedLowerPriority"] = "successDroppedLowerPriority";
    AttributionReportingEventLevelResult2["InternalError"] = "internalError";
    AttributionReportingEventLevelResult2["NoCapacityForAttributionDestination"] = "noCapacityForAttributionDestination";
    AttributionReportingEventLevelResult2["NoMatchingSources"] = "noMatchingSources";
    AttributionReportingEventLevelResult2["Deduplicated"] = "deduplicated";
    AttributionReportingEventLevelResult2["ExcessiveAttributions"] = "excessiveAttributions";
    AttributionReportingEventLevelResult2["PriorityTooLow"] = "priorityTooLow";
    AttributionReportingEventLevelResult2["NeverAttributedSource"] = "neverAttributedSource";
    AttributionReportingEventLevelResult2["ExcessiveReportingOrigins"] = "excessiveReportingOrigins";
    AttributionReportingEventLevelResult2["NoMatchingSourceFilterData"] = "noMatchingSourceFilterData";
    AttributionReportingEventLevelResult2["ProhibitedByBrowserPolicy"] = "prohibitedByBrowserPolicy";
    AttributionReportingEventLevelResult2["NoMatchingConfigurations"] = "noMatchingConfigurations";
    AttributionReportingEventLevelResult2["ExcessiveReports"] = "excessiveReports";
    AttributionReportingEventLevelResult2["FalselyAttributedSource"] = "falselyAttributedSource";
    AttributionReportingEventLevelResult2["ReportWindowPassed"] = "reportWindowPassed";
    AttributionReportingEventLevelResult2["NotRegistered"] = "notRegistered";
    AttributionReportingEventLevelResult2["ReportWindowNotStarted"] = "reportWindowNotStarted";
    AttributionReportingEventLevelResult2["NoMatchingTriggerData"] = "noMatchingTriggerData";
  })(AttributionReportingEventLevelResult = Storage2.AttributionReportingEventLevelResult || (Storage2.AttributionReportingEventLevelResult = {}));
  let AttributionReportingAggregatableResult;
  ((AttributionReportingAggregatableResult2) => {
    AttributionReportingAggregatableResult2["Success"] = "success";
    AttributionReportingAggregatableResult2["InternalError"] = "internalError";
    AttributionReportingAggregatableResult2["NoCapacityForAttributionDestination"] = "noCapacityForAttributionDestination";
    AttributionReportingAggregatableResult2["NoMatchingSources"] = "noMatchingSources";
    AttributionReportingAggregatableResult2["ExcessiveAttributions"] = "excessiveAttributions";
    AttributionReportingAggregatableResult2["ExcessiveReportingOrigins"] = "excessiveReportingOrigins";
    AttributionReportingAggregatableResult2["NoHistograms"] = "noHistograms";
    AttributionReportingAggregatableResult2["InsufficientBudget"] = "insufficientBudget";
    AttributionReportingAggregatableResult2["InsufficientNamedBudget"] = "insufficientNamedBudget";
    AttributionReportingAggregatableResult2["NoMatchingSourceFilterData"] = "noMatchingSourceFilterData";
    AttributionReportingAggregatableResult2["NotRegistered"] = "notRegistered";
    AttributionReportingAggregatableResult2["ProhibitedByBrowserPolicy"] = "prohibitedByBrowserPolicy";
    AttributionReportingAggregatableResult2["Deduplicated"] = "deduplicated";
    AttributionReportingAggregatableResult2["ReportWindowPassed"] = "reportWindowPassed";
    AttributionReportingAggregatableResult2["ExcessiveReports"] = "excessiveReports";
  })(AttributionReportingAggregatableResult = Storage2.AttributionReportingAggregatableResult || (Storage2.AttributionReportingAggregatableResult = {}));
})(Storage || (Storage = {}));
var SystemInfo;
((SystemInfo2) => {
  let SubsamplingFormat;
  ((SubsamplingFormat2) => {
    SubsamplingFormat2["Yuv420"] = "yuv420";
    SubsamplingFormat2["Yuv422"] = "yuv422";
    SubsamplingFormat2["Yuv444"] = "yuv444";
  })(SubsamplingFormat = SystemInfo2.SubsamplingFormat || (SystemInfo2.SubsamplingFormat = {}));
  let ImageType;
  ((ImageType2) => {
    ImageType2["Jpeg"] = "jpeg";
    ImageType2["Webp"] = "webp";
    ImageType2["Unknown"] = "unknown";
  })(ImageType = SystemInfo2.ImageType || (SystemInfo2.ImageType = {}));
})(SystemInfo || (SystemInfo = {}));
var Tracing;
((Tracing2) => {
  let TraceConfigRecordMode;
  ((TraceConfigRecordMode2) => {
    TraceConfigRecordMode2["RecordUntilFull"] = "recordUntilFull";
    TraceConfigRecordMode2["RecordContinuously"] = "recordContinuously";
    TraceConfigRecordMode2["RecordAsMuchAsPossible"] = "recordAsMuchAsPossible";
    TraceConfigRecordMode2["EchoToConsole"] = "echoToConsole";
  })(TraceConfigRecordMode = Tracing2.TraceConfigRecordMode || (Tracing2.TraceConfigRecordMode = {}));
  let StreamFormat;
  ((StreamFormat2) => {
    StreamFormat2["Json"] = "json";
    StreamFormat2["Proto"] = "proto";
  })(StreamFormat = Tracing2.StreamFormat || (Tracing2.StreamFormat = {}));
  let StreamCompression;
  ((StreamCompression2) => {
    StreamCompression2["None"] = "none";
    StreamCompression2["Gzip"] = "gzip";
  })(StreamCompression = Tracing2.StreamCompression || (Tracing2.StreamCompression = {}));
  let MemoryDumpLevelOfDetail;
  ((MemoryDumpLevelOfDetail2) => {
    MemoryDumpLevelOfDetail2["Background"] = "background";
    MemoryDumpLevelOfDetail2["Light"] = "light";
    MemoryDumpLevelOfDetail2["Detailed"] = "detailed";
  })(MemoryDumpLevelOfDetail = Tracing2.MemoryDumpLevelOfDetail || (Tracing2.MemoryDumpLevelOfDetail = {}));
  let TracingBackend;
  ((TracingBackend2) => {
    TracingBackend2["Auto"] = "auto";
    TracingBackend2["Chrome"] = "chrome";
    TracingBackend2["System"] = "system";
  })(TracingBackend = Tracing2.TracingBackend || (Tracing2.TracingBackend = {}));
  let StartRequestTransferMode;
  ((StartRequestTransferMode2) => {
    StartRequestTransferMode2["ReportEvents"] = "ReportEvents";
    StartRequestTransferMode2["ReturnAsStream"] = "ReturnAsStream";
  })(StartRequestTransferMode = Tracing2.StartRequestTransferMode || (Tracing2.StartRequestTransferMode = {}));
})(Tracing || (Tracing = {}));
var Fetch;
((Fetch2) => {
  let RequestStage;
  ((RequestStage2) => {
    RequestStage2["Request"] = "Request";
    RequestStage2["Response"] = "Response";
  })(RequestStage = Fetch2.RequestStage || (Fetch2.RequestStage = {}));
  let AuthChallengeSource;
  ((AuthChallengeSource2) => {
    AuthChallengeSource2["Server"] = "Server";
    AuthChallengeSource2["Proxy"] = "Proxy";
  })(AuthChallengeSource = Fetch2.AuthChallengeSource || (Fetch2.AuthChallengeSource = {}));
  let AuthChallengeResponseResponse;
  ((AuthChallengeResponseResponse2) => {
    AuthChallengeResponseResponse2["Default"] = "Default";
    AuthChallengeResponseResponse2["CancelAuth"] = "CancelAuth";
    AuthChallengeResponseResponse2["ProvideCredentials"] = "ProvideCredentials";
  })(AuthChallengeResponseResponse = Fetch2.AuthChallengeResponseResponse || (Fetch2.AuthChallengeResponseResponse = {}));
})(Fetch || (Fetch = {}));
var WebAudio;
((WebAudio2) => {
  let ContextType;
  ((ContextType2) => {
    ContextType2["Realtime"] = "realtime";
    ContextType2["Offline"] = "offline";
  })(ContextType = WebAudio2.ContextType || (WebAudio2.ContextType = {}));
  let ContextState;
  ((ContextState2) => {
    ContextState2["Suspended"] = "suspended";
    ContextState2["Running"] = "running";
    ContextState2["Closed"] = "closed";
    ContextState2["Interrupted"] = "interrupted";
  })(ContextState = WebAudio2.ContextState || (WebAudio2.ContextState = {}));
  let ChannelCountMode;
  ((ChannelCountMode2) => {
    ChannelCountMode2["ClampedMax"] = "clamped-max";
    ChannelCountMode2["Explicit"] = "explicit";
    ChannelCountMode2["Max"] = "max";
  })(ChannelCountMode = WebAudio2.ChannelCountMode || (WebAudio2.ChannelCountMode = {}));
  let ChannelInterpretation;
  ((ChannelInterpretation2) => {
    ChannelInterpretation2["Discrete"] = "discrete";
    ChannelInterpretation2["Speakers"] = "speakers";
  })(ChannelInterpretation = WebAudio2.ChannelInterpretation || (WebAudio2.ChannelInterpretation = {}));
  let AutomationRate;
  ((AutomationRate2) => {
    AutomationRate2["ARate"] = "a-rate";
    AutomationRate2["KRate"] = "k-rate";
  })(AutomationRate = WebAudio2.AutomationRate || (WebAudio2.AutomationRate = {}));
})(WebAudio || (WebAudio = {}));
var WebAuthn;
((WebAuthn2) => {
  let AuthenticatorProtocol;
  ((AuthenticatorProtocol2) => {
    AuthenticatorProtocol2["U2f"] = "u2f";
    AuthenticatorProtocol2["Ctap2"] = "ctap2";
  })(AuthenticatorProtocol = WebAuthn2.AuthenticatorProtocol || (WebAuthn2.AuthenticatorProtocol = {}));
  let Ctap2Version;
  ((Ctap2Version2) => {
    Ctap2Version2["Ctap2_0"] = "ctap2_0";
    Ctap2Version2["Ctap2_1"] = "ctap2_1";
  })(Ctap2Version = WebAuthn2.Ctap2Version || (WebAuthn2.Ctap2Version = {}));
  let AuthenticatorTransport;
  ((AuthenticatorTransport2) => {
    AuthenticatorTransport2["Usb"] = "usb";
    AuthenticatorTransport2["Nfc"] = "nfc";
    AuthenticatorTransport2["Ble"] = "ble";
    AuthenticatorTransport2["Cable"] = "cable";
    AuthenticatorTransport2["Internal"] = "internal";
  })(AuthenticatorTransport = WebAuthn2.AuthenticatorTransport || (WebAuthn2.AuthenticatorTransport = {}));
})(WebAuthn || (WebAuthn = {}));
var Media;
((Media2) => {
  let PlayerMessageLevel;
  ((PlayerMessageLevel2) => {
    PlayerMessageLevel2["Error"] = "error";
    PlayerMessageLevel2["Warning"] = "warning";
    PlayerMessageLevel2["Info"] = "info";
    PlayerMessageLevel2["Debug"] = "debug";
  })(PlayerMessageLevel = Media2.PlayerMessageLevel || (Media2.PlayerMessageLevel = {}));
})(Media || (Media = {}));
var Preload;
((Preload2) => {
  let RuleSetErrorType;
  ((RuleSetErrorType2) => {
    RuleSetErrorType2["SourceIsNotJsonObject"] = "SourceIsNotJsonObject";
    RuleSetErrorType2["InvalidRulesSkipped"] = "InvalidRulesSkipped";
  })(RuleSetErrorType = Preload2.RuleSetErrorType || (Preload2.RuleSetErrorType = {}));
  let SpeculationAction;
  ((SpeculationAction2) => {
    SpeculationAction2["Prefetch"] = "Prefetch";
    SpeculationAction2["Prerender"] = "Prerender";
  })(SpeculationAction = Preload2.SpeculationAction || (Preload2.SpeculationAction = {}));
  let SpeculationTargetHint;
  ((SpeculationTargetHint2) => {
    SpeculationTargetHint2["Blank"] = "Blank";
    SpeculationTargetHint2["Self"] = "Self";
  })(SpeculationTargetHint = Preload2.SpeculationTargetHint || (Preload2.SpeculationTargetHint = {}));
  let PrerenderFinalStatus;
  ((PrerenderFinalStatus2) => {
    PrerenderFinalStatus2["Activated"] = "Activated";
    PrerenderFinalStatus2["Destroyed"] = "Destroyed";
    PrerenderFinalStatus2["LowEndDevice"] = "LowEndDevice";
    PrerenderFinalStatus2["InvalidSchemeRedirect"] = "InvalidSchemeRedirect";
    PrerenderFinalStatus2["InvalidSchemeNavigation"] = "InvalidSchemeNavigation";
    PrerenderFinalStatus2["NavigationRequestBlockedByCsp"] = "NavigationRequestBlockedByCsp";
    PrerenderFinalStatus2["MainFrameNavigation"] = "MainFrameNavigation";
    PrerenderFinalStatus2["MojoBinderPolicy"] = "MojoBinderPolicy";
    PrerenderFinalStatus2["RendererProcessCrashed"] = "RendererProcessCrashed";
    PrerenderFinalStatus2["RendererProcessKilled"] = "RendererProcessKilled";
    PrerenderFinalStatus2["Download"] = "Download";
    PrerenderFinalStatus2["TriggerDestroyed"] = "TriggerDestroyed";
    PrerenderFinalStatus2["NavigationNotCommitted"] = "NavigationNotCommitted";
    PrerenderFinalStatus2["NavigationBadHttpStatus"] = "NavigationBadHttpStatus";
    PrerenderFinalStatus2["ClientCertRequested"] = "ClientCertRequested";
    PrerenderFinalStatus2["NavigationRequestNetworkError"] = "NavigationRequestNetworkError";
    PrerenderFinalStatus2["CancelAllHostsForTesting"] = "CancelAllHostsForTesting";
    PrerenderFinalStatus2["DidFailLoad"] = "DidFailLoad";
    PrerenderFinalStatus2["Stop"] = "Stop";
    PrerenderFinalStatus2["SslCertificateError"] = "SslCertificateError";
    PrerenderFinalStatus2["LoginAuthRequested"] = "LoginAuthRequested";
    PrerenderFinalStatus2["UaChangeRequiresReload"] = "UaChangeRequiresReload";
    PrerenderFinalStatus2["BlockedByClient"] = "BlockedByClient";
    PrerenderFinalStatus2["AudioOutputDeviceRequested"] = "AudioOutputDeviceRequested";
    PrerenderFinalStatus2["MixedContent"] = "MixedContent";
    PrerenderFinalStatus2["TriggerBackgrounded"] = "TriggerBackgrounded";
    PrerenderFinalStatus2["MemoryLimitExceeded"] = "MemoryLimitExceeded";
    PrerenderFinalStatus2["DataSaverEnabled"] = "DataSaverEnabled";
    PrerenderFinalStatus2["TriggerUrlHasEffectiveUrl"] = "TriggerUrlHasEffectiveUrl";
    PrerenderFinalStatus2["ActivatedBeforeStarted"] = "ActivatedBeforeStarted";
    PrerenderFinalStatus2["InactivePageRestriction"] = "InactivePageRestriction";
    PrerenderFinalStatus2["StartFailed"] = "StartFailed";
    PrerenderFinalStatus2["TimeoutBackgrounded"] = "TimeoutBackgrounded";
    PrerenderFinalStatus2["CrossSiteRedirectInInitialNavigation"] = "CrossSiteRedirectInInitialNavigation";
    PrerenderFinalStatus2["CrossSiteNavigationInInitialNavigation"] = "CrossSiteNavigationInInitialNavigation";
    PrerenderFinalStatus2["SameSiteCrossOriginRedirectNotOptInInInitialNavigation"] = "SameSiteCrossOriginRedirectNotOptInInInitialNavigation";
    PrerenderFinalStatus2["SameSiteCrossOriginNavigationNotOptInInInitialNavigation"] = "SameSiteCrossOriginNavigationNotOptInInInitialNavigation";
    PrerenderFinalStatus2["ActivationNavigationParameterMismatch"] = "ActivationNavigationParameterMismatch";
    PrerenderFinalStatus2["ActivatedInBackground"] = "ActivatedInBackground";
    PrerenderFinalStatus2["EmbedderHostDisallowed"] = "EmbedderHostDisallowed";
    PrerenderFinalStatus2["ActivationNavigationDestroyedBeforeSuccess"] = "ActivationNavigationDestroyedBeforeSuccess";
    PrerenderFinalStatus2["TabClosedByUserGesture"] = "TabClosedByUserGesture";
    PrerenderFinalStatus2["TabClosedWithoutUserGesture"] = "TabClosedWithoutUserGesture";
    PrerenderFinalStatus2["PrimaryMainFrameRendererProcessCrashed"] = "PrimaryMainFrameRendererProcessCrashed";
    PrerenderFinalStatus2["PrimaryMainFrameRendererProcessKilled"] = "PrimaryMainFrameRendererProcessKilled";
    PrerenderFinalStatus2["ActivationFramePolicyNotCompatible"] = "ActivationFramePolicyNotCompatible";
    PrerenderFinalStatus2["PreloadingDisabled"] = "PreloadingDisabled";
    PrerenderFinalStatus2["BatterySaverEnabled"] = "BatterySaverEnabled";
    PrerenderFinalStatus2["ActivatedDuringMainFrameNavigation"] = "ActivatedDuringMainFrameNavigation";
    PrerenderFinalStatus2["PreloadingUnsupportedByWebContents"] = "PreloadingUnsupportedByWebContents";
    PrerenderFinalStatus2["CrossSiteRedirectInMainFrameNavigation"] = "CrossSiteRedirectInMainFrameNavigation";
    PrerenderFinalStatus2["CrossSiteNavigationInMainFrameNavigation"] = "CrossSiteNavigationInMainFrameNavigation";
    PrerenderFinalStatus2["SameSiteCrossOriginRedirectNotOptInInMainFrameNavigation"] = "SameSiteCrossOriginRedirectNotOptInInMainFrameNavigation";
    PrerenderFinalStatus2["SameSiteCrossOriginNavigationNotOptInInMainFrameNavigation"] = "SameSiteCrossOriginNavigationNotOptInInMainFrameNavigation";
    PrerenderFinalStatus2["MemoryPressureOnTrigger"] = "MemoryPressureOnTrigger";
    PrerenderFinalStatus2["MemoryPressureAfterTriggered"] = "MemoryPressureAfterTriggered";
    PrerenderFinalStatus2["PrerenderingDisabledByDevTools"] = "PrerenderingDisabledByDevTools";
    PrerenderFinalStatus2["SpeculationRuleRemoved"] = "SpeculationRuleRemoved";
    PrerenderFinalStatus2["ActivatedWithAuxiliaryBrowsingContexts"] = "ActivatedWithAuxiliaryBrowsingContexts";
    PrerenderFinalStatus2["MaxNumOfRunningEagerPrerendersExceeded"] = "MaxNumOfRunningEagerPrerendersExceeded";
    PrerenderFinalStatus2["MaxNumOfRunningNonEagerPrerendersExceeded"] = "MaxNumOfRunningNonEagerPrerendersExceeded";
    PrerenderFinalStatus2["MaxNumOfRunningEmbedderPrerendersExceeded"] = "MaxNumOfRunningEmbedderPrerendersExceeded";
    PrerenderFinalStatus2["PrerenderingUrlHasEffectiveUrl"] = "PrerenderingUrlHasEffectiveUrl";
    PrerenderFinalStatus2["RedirectedPrerenderingUrlHasEffectiveUrl"] = "RedirectedPrerenderingUrlHasEffectiveUrl";
    PrerenderFinalStatus2["ActivationUrlHasEffectiveUrl"] = "ActivationUrlHasEffectiveUrl";
    PrerenderFinalStatus2["JavaScriptInterfaceAdded"] = "JavaScriptInterfaceAdded";
    PrerenderFinalStatus2["JavaScriptInterfaceRemoved"] = "JavaScriptInterfaceRemoved";
    PrerenderFinalStatus2["AllPrerenderingCanceled"] = "AllPrerenderingCanceled";
    PrerenderFinalStatus2["WindowClosed"] = "WindowClosed";
    PrerenderFinalStatus2["SlowNetwork"] = "SlowNetwork";
    PrerenderFinalStatus2["OtherPrerenderedPageActivated"] = "OtherPrerenderedPageActivated";
    PrerenderFinalStatus2["V8OptimizerDisabled"] = "V8OptimizerDisabled";
    PrerenderFinalStatus2["PrerenderFailedDuringPrefetch"] = "PrerenderFailedDuringPrefetch";
  })(PrerenderFinalStatus = Preload2.PrerenderFinalStatus || (Preload2.PrerenderFinalStatus = {}));
  let PreloadingStatus2;
  ((PreloadingStatus22) => {
    PreloadingStatus22["Pending"] = "Pending";
    PreloadingStatus22["Running"] = "Running";
    PreloadingStatus22["Ready"] = "Ready";
    PreloadingStatus22["Success"] = "Success";
    PreloadingStatus22["Failure"] = "Failure";
    PreloadingStatus22["NotSupported"] = "NotSupported";
  })(PreloadingStatus2 = Preload2.PreloadingStatus || (Preload2.PreloadingStatus = {}));
  let PrefetchStatus;
  ((PrefetchStatus2) => {
    PrefetchStatus2["PrefetchAllowed"] = "PrefetchAllowed";
    PrefetchStatus2["PrefetchFailedIneligibleRedirect"] = "PrefetchFailedIneligibleRedirect";
    PrefetchStatus2["PrefetchFailedInvalidRedirect"] = "PrefetchFailedInvalidRedirect";
    PrefetchStatus2["PrefetchFailedMIMENotSupported"] = "PrefetchFailedMIMENotSupported";
    PrefetchStatus2["PrefetchFailedNetError"] = "PrefetchFailedNetError";
    PrefetchStatus2["PrefetchFailedNon2XX"] = "PrefetchFailedNon2XX";
    PrefetchStatus2["PrefetchEvictedAfterCandidateRemoved"] = "PrefetchEvictedAfterCandidateRemoved";
    PrefetchStatus2["PrefetchEvictedForNewerPrefetch"] = "PrefetchEvictedForNewerPrefetch";
    PrefetchStatus2["PrefetchHeldback"] = "PrefetchHeldback";
    PrefetchStatus2["PrefetchIneligibleRetryAfter"] = "PrefetchIneligibleRetryAfter";
    PrefetchStatus2["PrefetchIsPrivacyDecoy"] = "PrefetchIsPrivacyDecoy";
    PrefetchStatus2["PrefetchIsStale"] = "PrefetchIsStale";
    PrefetchStatus2["PrefetchNotEligibleBrowserContextOffTheRecord"] = "PrefetchNotEligibleBrowserContextOffTheRecord";
    PrefetchStatus2["PrefetchNotEligibleDataSaverEnabled"] = "PrefetchNotEligibleDataSaverEnabled";
    PrefetchStatus2["PrefetchNotEligibleExistingProxy"] = "PrefetchNotEligibleExistingProxy";
    PrefetchStatus2["PrefetchNotEligibleHostIsNonUnique"] = "PrefetchNotEligibleHostIsNonUnique";
    PrefetchStatus2["PrefetchNotEligibleNonDefaultStoragePartition"] = "PrefetchNotEligibleNonDefaultStoragePartition";
    PrefetchStatus2["PrefetchNotEligibleSameSiteCrossOriginPrefetchRequiredProxy"] = "PrefetchNotEligibleSameSiteCrossOriginPrefetchRequiredProxy";
    PrefetchStatus2["PrefetchNotEligibleSchemeIsNotHttps"] = "PrefetchNotEligibleSchemeIsNotHttps";
    PrefetchStatus2["PrefetchNotEligibleUserHasCookies"] = "PrefetchNotEligibleUserHasCookies";
    PrefetchStatus2["PrefetchNotEligibleUserHasServiceWorker"] = "PrefetchNotEligibleUserHasServiceWorker";
    PrefetchStatus2["PrefetchNotEligibleBatterySaverEnabled"] = "PrefetchNotEligibleBatterySaverEnabled";
    PrefetchStatus2["PrefetchNotEligiblePreloadingDisabled"] = "PrefetchNotEligiblePreloadingDisabled";
    PrefetchStatus2["PrefetchNotFinishedInTime"] = "PrefetchNotFinishedInTime";
    PrefetchStatus2["PrefetchNotStarted"] = "PrefetchNotStarted";
    PrefetchStatus2["PrefetchNotUsedCookiesChanged"] = "PrefetchNotUsedCookiesChanged";
    PrefetchStatus2["PrefetchProxyNotAvailable"] = "PrefetchProxyNotAvailable";
    PrefetchStatus2["PrefetchResponseUsed"] = "PrefetchResponseUsed";
    PrefetchStatus2["PrefetchSuccessfulButNotUsed"] = "PrefetchSuccessfulButNotUsed";
    PrefetchStatus2["PrefetchNotUsedProbeFailed"] = "PrefetchNotUsedProbeFailed";
  })(PrefetchStatus = Preload2.PrefetchStatus || (Preload2.PrefetchStatus = {}));
})(Preload || (Preload = {}));
var FedCm;
((FedCm2) => {
  let LoginState;
  ((LoginState2) => {
    LoginState2["SignIn"] = "SignIn";
    LoginState2["SignUp"] = "SignUp";
  })(LoginState = FedCm2.LoginState || (FedCm2.LoginState = {}));
  let DialogType;
  ((DialogType2) => {
    DialogType2["AccountChooser"] = "AccountChooser";
    DialogType2["AutoReauthn"] = "AutoReauthn";
    DialogType2["ConfirmIdpLogin"] = "ConfirmIdpLogin";
    DialogType2["Error"] = "Error";
  })(DialogType = FedCm2.DialogType || (FedCm2.DialogType = {}));
  let DialogButton;
  ((DialogButton2) => {
    DialogButton2["ConfirmIdpLoginContinue"] = "ConfirmIdpLoginContinue";
    DialogButton2["ErrorGotIt"] = "ErrorGotIt";
    DialogButton2["ErrorMoreDetails"] = "ErrorMoreDetails";
  })(DialogButton = FedCm2.DialogButton || (FedCm2.DialogButton = {}));
  let AccountUrlType;
  ((AccountUrlType2) => {
    AccountUrlType2["TermsOfService"] = "TermsOfService";
    AccountUrlType2["PrivacyPolicy"] = "PrivacyPolicy";
  })(AccountUrlType = FedCm2.AccountUrlType || (FedCm2.AccountUrlType = {}));
})(FedCm || (FedCm = {}));
var PWA;
((PWA2) => {
  let DisplayMode;
  ((DisplayMode2) => {
    DisplayMode2["Standalone"] = "standalone";
    DisplayMode2["Browser"] = "browser";
  })(DisplayMode = PWA2.DisplayMode || (PWA2.DisplayMode = {}));
})(PWA || (PWA = {}));
var BluetoothEmulation;
((BluetoothEmulation2) => {
  let CentralState;
  ((CentralState2) => {
    CentralState2["Absent"] = "absent";
    CentralState2["PoweredOff"] = "powered-off";
    CentralState2["PoweredOn"] = "powered-on";
  })(CentralState = BluetoothEmulation2.CentralState || (BluetoothEmulation2.CentralState = {}));
})(BluetoothEmulation || (BluetoothEmulation = {}));
var Debugger;
((Debugger2) => {
  let ScopeType;
  ((ScopeType2) => {
    ScopeType2["Global"] = "global";
    ScopeType2["Local"] = "local";
    ScopeType2["With"] = "with";
    ScopeType2["Closure"] = "closure";
    ScopeType2["Catch"] = "catch";
    ScopeType2["Block"] = "block";
    ScopeType2["Script"] = "script";
    ScopeType2["Eval"] = "eval";
    ScopeType2["Module"] = "module";
    ScopeType2["WasmExpressionStack"] = "wasm-expression-stack";
  })(ScopeType = Debugger2.ScopeType || (Debugger2.ScopeType = {}));
  let BreakLocationType;
  ((BreakLocationType2) => {
    BreakLocationType2["DebuggerStatement"] = "debuggerStatement";
    BreakLocationType2["Call"] = "call";
    BreakLocationType2["Return"] = "return";
  })(BreakLocationType = Debugger2.BreakLocationType || (Debugger2.BreakLocationType = {}));
  let ScriptLanguage;
  ((ScriptLanguage2) => {
    ScriptLanguage2["JavaScript"] = "JavaScript";
    ScriptLanguage2["WebAssembly"] = "WebAssembly";
  })(ScriptLanguage = Debugger2.ScriptLanguage || (Debugger2.ScriptLanguage = {}));
  let DebugSymbolsType;
  ((DebugSymbolsType2) => {
    DebugSymbolsType2["SourceMap"] = "SourceMap";
    DebugSymbolsType2["EmbeddedDWARF"] = "EmbeddedDWARF";
    DebugSymbolsType2["ExternalDWARF"] = "ExternalDWARF";
  })(DebugSymbolsType = Debugger2.DebugSymbolsType || (Debugger2.DebugSymbolsType = {}));
  let ContinueToLocationRequestTargetCallFrames;
  ((ContinueToLocationRequestTargetCallFrames2) => {
    ContinueToLocationRequestTargetCallFrames2["Any"] = "any";
    ContinueToLocationRequestTargetCallFrames2["Current"] = "current";
  })(ContinueToLocationRequestTargetCallFrames = Debugger2.ContinueToLocationRequestTargetCallFrames || (Debugger2.ContinueToLocationRequestTargetCallFrames = {}));
  let RestartFrameRequestMode;
  ((RestartFrameRequestMode2) => {
    RestartFrameRequestMode2["StepInto"] = "StepInto";
  })(RestartFrameRequestMode = Debugger2.RestartFrameRequestMode || (Debugger2.RestartFrameRequestMode = {}));
  let SetInstrumentationBreakpointRequestInstrumentation;
  ((SetInstrumentationBreakpointRequestInstrumentation2) => {
    SetInstrumentationBreakpointRequestInstrumentation2["BeforeScriptExecution"] = "beforeScriptExecution";
    SetInstrumentationBreakpointRequestInstrumentation2["BeforeScriptWithSourceMapExecution"] = "beforeScriptWithSourceMapExecution";
  })(SetInstrumentationBreakpointRequestInstrumentation = Debugger2.SetInstrumentationBreakpointRequestInstrumentation || (Debugger2.SetInstrumentationBreakpointRequestInstrumentation = {}));
  let SetPauseOnExceptionsRequestState;
  ((SetPauseOnExceptionsRequestState2) => {
    SetPauseOnExceptionsRequestState2["None"] = "none";
    SetPauseOnExceptionsRequestState2["Caught"] = "caught";
    SetPauseOnExceptionsRequestState2["Uncaught"] = "uncaught";
    SetPauseOnExceptionsRequestState2["All"] = "all";
  })(SetPauseOnExceptionsRequestState = Debugger2.SetPauseOnExceptionsRequestState || (Debugger2.SetPauseOnExceptionsRequestState = {}));
  let SetScriptSourceResponseStatus;
  ((SetScriptSourceResponseStatus2) => {
    SetScriptSourceResponseStatus2["Ok"] = "Ok";
    SetScriptSourceResponseStatus2["CompileError"] = "CompileError";
    SetScriptSourceResponseStatus2["BlockedByActiveGenerator"] = "BlockedByActiveGenerator";
    SetScriptSourceResponseStatus2["BlockedByActiveFunction"] = "BlockedByActiveFunction";
    SetScriptSourceResponseStatus2["BlockedByTopLevelEsModuleChange"] = "BlockedByTopLevelEsModuleChange";
  })(SetScriptSourceResponseStatus = Debugger2.SetScriptSourceResponseStatus || (Debugger2.SetScriptSourceResponseStatus = {}));
  let PausedEventReason;
  ((PausedEventReason2) => {
    PausedEventReason2["Ambiguous"] = "ambiguous";
    PausedEventReason2["Assert"] = "assert";
    PausedEventReason2["CSPViolation"] = "CSPViolation";
    PausedEventReason2["DebugCommand"] = "debugCommand";
    PausedEventReason2["DOM"] = "DOM";
    PausedEventReason2["EventListener"] = "EventListener";
    PausedEventReason2["Exception"] = "exception";
    PausedEventReason2["Instrumentation"] = "instrumentation";
    PausedEventReason2["OOM"] = "OOM";
    PausedEventReason2["Other"] = "other";
    PausedEventReason2["PromiseRejection"] = "promiseRejection";
    PausedEventReason2["XHR"] = "XHR";
    PausedEventReason2["Step"] = "step";
  })(PausedEventReason = Debugger2.PausedEventReason || (Debugger2.PausedEventReason = {}));
})(Debugger || (Debugger = {}));
var Runtime;
((Runtime22) => {
  let SerializationOptionsSerialization;
  ((SerializationOptionsSerialization2) => {
    SerializationOptionsSerialization2["Deep"] = "deep";
    SerializationOptionsSerialization2["Json"] = "json";
    SerializationOptionsSerialization2["IdOnly"] = "idOnly";
  })(SerializationOptionsSerialization = Runtime22.SerializationOptionsSerialization || (Runtime22.SerializationOptionsSerialization = {}));
  let DeepSerializedValueType;
  ((DeepSerializedValueType2) => {
    DeepSerializedValueType2["Undefined"] = "undefined";
    DeepSerializedValueType2["Null"] = "null";
    DeepSerializedValueType2["String"] = "string";
    DeepSerializedValueType2["Number"] = "number";
    DeepSerializedValueType2["Boolean"] = "boolean";
    DeepSerializedValueType2["Bigint"] = "bigint";
    DeepSerializedValueType2["Regexp"] = "regexp";
    DeepSerializedValueType2["Date"] = "date";
    DeepSerializedValueType2["Symbol"] = "symbol";
    DeepSerializedValueType2["Array"] = "array";
    DeepSerializedValueType2["Object"] = "object";
    DeepSerializedValueType2["Function"] = "function";
    DeepSerializedValueType2["Map"] = "map";
    DeepSerializedValueType2["Set"] = "set";
    DeepSerializedValueType2["Weakmap"] = "weakmap";
    DeepSerializedValueType2["Weakset"] = "weakset";
    DeepSerializedValueType2["Error"] = "error";
    DeepSerializedValueType2["Proxy"] = "proxy";
    DeepSerializedValueType2["Promise"] = "promise";
    DeepSerializedValueType2["Typedarray"] = "typedarray";
    DeepSerializedValueType2["Arraybuffer"] = "arraybuffer";
    DeepSerializedValueType2["Node"] = "node";
    DeepSerializedValueType2["Window"] = "window";
    DeepSerializedValueType2["Generator"] = "generator";
  })(DeepSerializedValueType = Runtime22.DeepSerializedValueType || (Runtime22.DeepSerializedValueType = {}));
  let RemoteObjectType;
  ((RemoteObjectType2) => {
    RemoteObjectType2["Object"] = "object";
    RemoteObjectType2["Function"] = "function";
    RemoteObjectType2["Undefined"] = "undefined";
    RemoteObjectType2["String"] = "string";
    RemoteObjectType2["Number"] = "number";
    RemoteObjectType2["Boolean"] = "boolean";
    RemoteObjectType2["Symbol"] = "symbol";
    RemoteObjectType2["Bigint"] = "bigint";
  })(RemoteObjectType = Runtime22.RemoteObjectType || (Runtime22.RemoteObjectType = {}));
  let RemoteObjectSubtype;
  ((RemoteObjectSubtype2) => {
    RemoteObjectSubtype2["Array"] = "array";
    RemoteObjectSubtype2["Null"] = "null";
    RemoteObjectSubtype2["Node"] = "node";
    RemoteObjectSubtype2["Regexp"] = "regexp";
    RemoteObjectSubtype2["Date"] = "date";
    RemoteObjectSubtype2["Map"] = "map";
    RemoteObjectSubtype2["Set"] = "set";
    RemoteObjectSubtype2["Weakmap"] = "weakmap";
    RemoteObjectSubtype2["Weakset"] = "weakset";
    RemoteObjectSubtype2["Iterator"] = "iterator";
    RemoteObjectSubtype2["Generator"] = "generator";
    RemoteObjectSubtype2["Error"] = "error";
    RemoteObjectSubtype2["Proxy"] = "proxy";
    RemoteObjectSubtype2["Promise"] = "promise";
    RemoteObjectSubtype2["Typedarray"] = "typedarray";
    RemoteObjectSubtype2["Arraybuffer"] = "arraybuffer";
    RemoteObjectSubtype2["Dataview"] = "dataview";
    RemoteObjectSubtype2["Webassemblymemory"] = "webassemblymemory";
    RemoteObjectSubtype2["Wasmvalue"] = "wasmvalue";
  })(RemoteObjectSubtype = Runtime22.RemoteObjectSubtype || (Runtime22.RemoteObjectSubtype = {}));
  let ObjectPreviewType;
  ((ObjectPreviewType2) => {
    ObjectPreviewType2["Object"] = "object";
    ObjectPreviewType2["Function"] = "function";
    ObjectPreviewType2["Undefined"] = "undefined";
    ObjectPreviewType2["String"] = "string";
    ObjectPreviewType2["Number"] = "number";
    ObjectPreviewType2["Boolean"] = "boolean";
    ObjectPreviewType2["Symbol"] = "symbol";
    ObjectPreviewType2["Bigint"] = "bigint";
  })(ObjectPreviewType = Runtime22.ObjectPreviewType || (Runtime22.ObjectPreviewType = {}));
  let ObjectPreviewSubtype;
  ((ObjectPreviewSubtype2) => {
    ObjectPreviewSubtype2["Array"] = "array";
    ObjectPreviewSubtype2["Null"] = "null";
    ObjectPreviewSubtype2["Node"] = "node";
    ObjectPreviewSubtype2["Regexp"] = "regexp";
    ObjectPreviewSubtype2["Date"] = "date";
    ObjectPreviewSubtype2["Map"] = "map";
    ObjectPreviewSubtype2["Set"] = "set";
    ObjectPreviewSubtype2["Weakmap"] = "weakmap";
    ObjectPreviewSubtype2["Weakset"] = "weakset";
    ObjectPreviewSubtype2["Iterator"] = "iterator";
    ObjectPreviewSubtype2["Generator"] = "generator";
    ObjectPreviewSubtype2["Error"] = "error";
    ObjectPreviewSubtype2["Proxy"] = "proxy";
    ObjectPreviewSubtype2["Promise"] = "promise";
    ObjectPreviewSubtype2["Typedarray"] = "typedarray";
    ObjectPreviewSubtype2["Arraybuffer"] = "arraybuffer";
    ObjectPreviewSubtype2["Dataview"] = "dataview";
    ObjectPreviewSubtype2["Webassemblymemory"] = "webassemblymemory";
    ObjectPreviewSubtype2["Wasmvalue"] = "wasmvalue";
  })(ObjectPreviewSubtype = Runtime22.ObjectPreviewSubtype || (Runtime22.ObjectPreviewSubtype = {}));
  let PropertyPreviewType;
  ((PropertyPreviewType2) => {
    PropertyPreviewType2["Object"] = "object";
    PropertyPreviewType2["Function"] = "function";
    PropertyPreviewType2["Undefined"] = "undefined";
    PropertyPreviewType2["String"] = "string";
    PropertyPreviewType2["Number"] = "number";
    PropertyPreviewType2["Boolean"] = "boolean";
    PropertyPreviewType2["Symbol"] = "symbol";
    PropertyPreviewType2["Accessor"] = "accessor";
    PropertyPreviewType2["Bigint"] = "bigint";
  })(PropertyPreviewType = Runtime22.PropertyPreviewType || (Runtime22.PropertyPreviewType = {}));
  let PropertyPreviewSubtype;
  ((PropertyPreviewSubtype2) => {
    PropertyPreviewSubtype2["Array"] = "array";
    PropertyPreviewSubtype2["Null"] = "null";
    PropertyPreviewSubtype2["Node"] = "node";
    PropertyPreviewSubtype2["Regexp"] = "regexp";
    PropertyPreviewSubtype2["Date"] = "date";
    PropertyPreviewSubtype2["Map"] = "map";
    PropertyPreviewSubtype2["Set"] = "set";
    PropertyPreviewSubtype2["Weakmap"] = "weakmap";
    PropertyPreviewSubtype2["Weakset"] = "weakset";
    PropertyPreviewSubtype2["Iterator"] = "iterator";
    PropertyPreviewSubtype2["Generator"] = "generator";
    PropertyPreviewSubtype2["Error"] = "error";
    PropertyPreviewSubtype2["Proxy"] = "proxy";
    PropertyPreviewSubtype2["Promise"] = "promise";
    PropertyPreviewSubtype2["Typedarray"] = "typedarray";
    PropertyPreviewSubtype2["Arraybuffer"] = "arraybuffer";
    PropertyPreviewSubtype2["Dataview"] = "dataview";
    PropertyPreviewSubtype2["Webassemblymemory"] = "webassemblymemory";
    PropertyPreviewSubtype2["Wasmvalue"] = "wasmvalue";
  })(PropertyPreviewSubtype = Runtime22.PropertyPreviewSubtype || (Runtime22.PropertyPreviewSubtype = {}));
  let ConsoleAPICalledEventType;
  ((ConsoleAPICalledEventType2) => {
    ConsoleAPICalledEventType2["Log"] = "log";
    ConsoleAPICalledEventType2["Debug"] = "debug";
    ConsoleAPICalledEventType2["Info"] = "info";
    ConsoleAPICalledEventType2["Error"] = "error";
    ConsoleAPICalledEventType2["Warning"] = "warning";
    ConsoleAPICalledEventType2["Dir"] = "dir";
    ConsoleAPICalledEventType2["DirXML"] = "dirxml";
    ConsoleAPICalledEventType2["Table"] = "table";
    ConsoleAPICalledEventType2["Trace"] = "trace";
    ConsoleAPICalledEventType2["Clear"] = "clear";
    ConsoleAPICalledEventType2["StartGroup"] = "startGroup";
    ConsoleAPICalledEventType2["StartGroupCollapsed"] = "startGroupCollapsed";
    ConsoleAPICalledEventType2["EndGroup"] = "endGroup";
    ConsoleAPICalledEventType2["Assert"] = "assert";
    ConsoleAPICalledEventType2["Profile"] = "profile";
    ConsoleAPICalledEventType2["ProfileEnd"] = "profileEnd";
    ConsoleAPICalledEventType2["Count"] = "count";
    ConsoleAPICalledEventType2["TimeEnd"] = "timeEnd";
  })(ConsoleAPICalledEventType = Runtime22.ConsoleAPICalledEventType || (Runtime22.ConsoleAPICalledEventType = {}));
})(Runtime || (Runtime = {}));

// gen/front_end/generated/SupportedCSSProperties.js
var generatedProperties = [
  {
    "longhands": [
      "animation-duration",
      "animation-timing-function",
      "animation-delay",
      "animation-iteration-count",
      "animation-direction",
      "animation-fill-mode",
      "animation-play-state",
      "animation-name",
      "animation-timeline",
      "animation-range-start",
      "animation-range-end"
    ],
    "name": "-alternative-animation-with-timeline"
  },
  {
    "inherited": true,
    "name": "-webkit-border-horizontal-spacing"
  },
  {
    "name": "-webkit-border-image"
  },
  {
    "inherited": true,
    "name": "-webkit-border-vertical-spacing"
  },
  {
    "keywords": [
      "stretch",
      "start",
      "center",
      "end",
      "baseline"
    ],
    "name": "-webkit-box-align"
  },
  {
    "keywords": [
      "slice",
      "clone"
    ],
    "name": "-webkit-box-decoration-break"
  },
  {
    "keywords": [
      "normal",
      "reverse"
    ],
    "name": "-webkit-box-direction"
  },
  {
    "name": "-webkit-box-flex"
  },
  {
    "name": "-webkit-box-ordinal-group"
  },
  {
    "keywords": [
      "horizontal",
      "vertical"
    ],
    "name": "-webkit-box-orient"
  },
  {
    "keywords": [
      "start",
      "center",
      "end",
      "justify"
    ],
    "name": "-webkit-box-pack"
  },
  {
    "name": "-webkit-box-reflect"
  },
  {
    "longhands": [
      "break-after"
    ],
    "name": "-webkit-column-break-after"
  },
  {
    "longhands": [
      "break-before"
    ],
    "name": "-webkit-column-break-before"
  },
  {
    "longhands": [
      "break-inside"
    ],
    "name": "-webkit-column-break-inside"
  },
  {
    "inherited": true,
    "name": "-webkit-font-smoothing"
  },
  {
    "inherited": true,
    "keywords": [
      "auto",
      "loose",
      "normal",
      "strict",
      "after-white-space",
      "anywhere"
    ],
    "name": "-webkit-line-break"
  },
  {
    "keywords": [
      "none"
    ],
    "name": "-webkit-line-clamp"
  },
  {
    "inherited": true,
    "name": "-webkit-locale"
  },
  {
    "longhands": [
      "-webkit-mask-box-image-source",
      "-webkit-mask-box-image-slice",
      "-webkit-mask-box-image-width",
      "-webkit-mask-box-image-outset",
      "-webkit-mask-box-image-repeat"
    ],
    "name": "-webkit-mask-box-image"
  },
  {
    "name": "-webkit-mask-box-image-outset"
  },
  {
    "name": "-webkit-mask-box-image-repeat"
  },
  {
    "name": "-webkit-mask-box-image-slice"
  },
  {
    "name": "-webkit-mask-box-image-source"
  },
  {
    "name": "-webkit-mask-box-image-width"
  },
  {
    "name": "-webkit-mask-position-x"
  },
  {
    "name": "-webkit-mask-position-y"
  },
  {
    "name": "-webkit-perspective-origin-x"
  },
  {
    "name": "-webkit-perspective-origin-y"
  },
  {
    "inherited": true,
    "keywords": [
      "economy",
      "exact"
    ],
    "name": "-webkit-print-color-adjust"
  },
  {
    "inherited": true,
    "keywords": [
      "logical",
      "visual"
    ],
    "name": "-webkit-rtl-ordering"
  },
  {
    "inherited": true,
    "name": "-webkit-ruby-position"
  },
  {
    "inherited": true,
    "name": "-webkit-tap-highlight-color"
  },
  {
    "inherited": true,
    "name": "-webkit-text-combine"
  },
  {
    "inherited": true,
    "name": "-webkit-text-decorations-in-effect"
  },
  {
    "inherited": true,
    "name": "-webkit-text-fill-color"
  },
  {
    "inherited": true,
    "name": "-webkit-text-orientation"
  },
  {
    "inherited": true,
    "keywords": [
      "none",
      "disc",
      "circle",
      "square"
    ],
    "name": "-webkit-text-security"
  },
  {
    "inherited": true,
    "longhands": [
      "-webkit-text-stroke-width",
      "-webkit-text-stroke-color"
    ],
    "name": "-webkit-text-stroke"
  },
  {
    "inherited": true,
    "name": "-webkit-text-stroke-color"
  },
  {
    "inherited": true,
    "name": "-webkit-text-stroke-width"
  },
  {
    "name": "-webkit-transform-origin-x"
  },
  {
    "name": "-webkit-transform-origin-y"
  },
  {
    "name": "-webkit-transform-origin-z"
  },
  {
    "keywords": [
      "auto",
      "none",
      "element"
    ],
    "name": "-webkit-user-drag"
  },
  {
    "inherited": true,
    "keywords": [
      "read-only",
      "read-write",
      "read-write-plaintext-only"
    ],
    "name": "-webkit-user-modify"
  },
  {
    "inherited": true,
    "name": "-webkit-writing-mode"
  },
  {
    "inherited": true,
    "keywords": [
      "auto",
      "currentcolor"
    ],
    "name": "accent-color"
  },
  {
    "name": "additive-symbols"
  },
  {
    "name": "align-content"
  },
  {
    "name": "align-items"
  },
  {
    "name": "align-self"
  },
  {
    "keywords": [
      "auto",
      "baseline",
      "alphabetic",
      "ideographic",
      "middle",
      "central",
      "mathematical",
      "before-edge",
      "text-before-edge",
      "after-edge",
      "text-after-edge",
      "hanging"
    ],
    "name": "alignment-baseline"
  },
  {
    "longhands": [
      "-webkit-border-horizontal-spacing",
      "-webkit-border-vertical-spacing",
      "-webkit-box-align",
      "-webkit-box-decoration-break",
      "-webkit-box-direction",
      "-webkit-box-flex",
      "-webkit-box-ordinal-group",
      "-webkit-box-orient",
      "-webkit-box-pack",
      "-webkit-box-reflect",
      "-webkit-font-smoothing",
      "-webkit-line-break",
      "-webkit-line-clamp",
      "-webkit-locale",
      "-webkit-mask-box-image-outset",
      "-webkit-mask-box-image-repeat",
      "-webkit-mask-box-image-slice",
      "-webkit-mask-box-image-source",
      "-webkit-mask-box-image-width",
      "-webkit-mask-position-x",
      "-webkit-mask-position-y",
      "-webkit-print-color-adjust",
      "-webkit-rtl-ordering",
      "-webkit-ruby-position",
      "-webkit-tap-highlight-color",
      "-webkit-text-combine",
      "-webkit-text-decorations-in-effect",
      "-webkit-text-fill-color",
      "-webkit-text-orientation",
      "-webkit-text-security",
      "-webkit-text-stroke-color",
      "-webkit-text-stroke-width",
      "-webkit-user-drag",
      "-webkit-writing-mode",
      "accent-color",
      "additive-symbols",
      "align-content",
      "align-items",
      "align-self",
      "alignment-baseline",
      "anchor-name",
      "anchor-scope",
      "animation-composition",
      "animation-delay",
      "animation-direction",
      "animation-duration",
      "animation-fill-mode",
      "animation-iteration-count",
      "animation-name",
      "animation-play-state",
      "animation-range-end",
      "animation-range-start",
      "animation-timeline",
      "animation-timing-function",
      "app-region",
      "appearance",
      "ascent-override",
      "aspect-ratio",
      "backdrop-filter",
      "backface-visibility",
      "background-attachment",
      "background-blend-mode",
      "background-clip",
      "background-color",
      "background-image",
      "background-origin",
      "background-position-x",
      "background-position-y",
      "background-repeat",
      "background-size",
      "base-palette",
      "baseline-shift",
      "baseline-source",
      "block-size",
      "border-block-end-color",
      "border-block-end-style",
      "border-block-end-width",
      "border-block-start-color",
      "border-block-start-style",
      "border-block-start-width",
      "border-bottom-color",
      "border-bottom-left-radius",
      "border-bottom-right-radius",
      "border-bottom-style",
      "border-bottom-width",
      "border-collapse",
      "border-end-end-radius",
      "border-end-start-radius",
      "border-image-outset",
      "border-image-repeat",
      "border-image-slice",
      "border-image-source",
      "border-image-width",
      "border-inline-end-color",
      "border-inline-end-style",
      "border-inline-end-width",
      "border-inline-start-color",
      "border-inline-start-style",
      "border-inline-start-width",
      "border-left-color",
      "border-left-style",
      "border-left-width",
      "border-right-color",
      "border-right-style",
      "border-right-width",
      "border-start-end-radius",
      "border-start-start-radius",
      "border-top-color",
      "border-top-left-radius",
      "border-top-right-radius",
      "border-top-style",
      "border-top-width",
      "bottom",
      "box-decoration-break",
      "box-shadow",
      "box-sizing",
      "break-after",
      "break-before",
      "break-inside",
      "buffered-rendering",
      "caption-side",
      "caret-animation",
      "caret-color",
      "clear",
      "clip",
      "clip-path",
      "clip-rule",
      "color",
      "color-interpolation",
      "color-interpolation-filters",
      "color-rendering",
      "color-scheme",
      "column-count",
      "column-fill",
      "column-gap",
      "column-rule-color",
      "column-rule-style",
      "column-rule-width",
      "column-span",
      "column-width",
      "contain",
      "contain-intrinsic-block-size",
      "contain-intrinsic-height",
      "contain-intrinsic-inline-size",
      "contain-intrinsic-width",
      "container-name",
      "container-type",
      "content",
      "content-visibility",
      "counter-increment",
      "counter-reset",
      "counter-set",
      "cursor",
      "cx",
      "cy",
      "d",
      "descent-override",
      "display",
      "dominant-baseline",
      "dynamic-range-limit",
      "empty-cells",
      "fallback",
      "field-sizing",
      "fill",
      "fill-opacity",
      "fill-rule",
      "filter",
      "flex-basis",
      "flex-direction",
      "flex-grow",
      "flex-shrink",
      "flex-wrap",
      "float",
      "flood-color",
      "flood-opacity",
      "font-display",
      "font-family",
      "font-feature-settings",
      "font-kerning",
      "font-optical-sizing",
      "font-palette",
      "font-size",
      "font-size-adjust",
      "font-stretch",
      "font-style",
      "font-synthesis-small-caps",
      "font-synthesis-style",
      "font-synthesis-weight",
      "font-variant-alternates",
      "font-variant-caps",
      "font-variant-east-asian",
      "font-variant-emoji",
      "font-variant-ligatures",
      "font-variant-numeric",
      "font-variant-position",
      "font-variation-settings",
      "font-weight",
      "forced-color-adjust",
      "grid-auto-columns",
      "grid-auto-flow",
      "grid-auto-rows",
      "grid-column-end",
      "grid-column-start",
      "grid-row-end",
      "grid-row-start",
      "grid-template-areas",
      "grid-template-columns",
      "grid-template-rows",
      "height",
      "hyphenate-character",
      "hyphenate-limit-chars",
      "hyphens",
      "image-orientation",
      "image-rendering",
      "inherits",
      "initial-letter",
      "initial-value",
      "inline-size",
      "inset-block-end",
      "inset-block-start",
      "inset-inline-end",
      "inset-inline-start",
      "interactivity",
      "interpolate-size",
      "isolation",
      "justify-content",
      "justify-items",
      "justify-self",
      "left",
      "letter-spacing",
      "lighting-color",
      "line-break",
      "line-clamp",
      "line-gap-override",
      "line-height",
      "list-style-image",
      "list-style-position",
      "list-style-type",
      "margin-block-end",
      "margin-block-start",
      "margin-bottom",
      "margin-inline-end",
      "margin-inline-start",
      "margin-left",
      "margin-right",
      "margin-top",
      "marker-end",
      "marker-mid",
      "marker-start",
      "mask-clip",
      "mask-composite",
      "mask-image",
      "mask-mode",
      "mask-origin",
      "mask-repeat",
      "mask-size",
      "mask-type",
      "masonry-slack",
      "masonry-template-tracks",
      "masonry-track-end",
      "masonry-track-start",
      "math-depth",
      "math-shift",
      "math-style",
      "max-block-size",
      "max-height",
      "max-inline-size",
      "max-width",
      "min-block-size",
      "min-height",
      "min-inline-size",
      "min-width",
      "mix-blend-mode",
      "navigation",
      "negative",
      "object-fit",
      "object-position",
      "object-view-box",
      "offset-anchor",
      "offset-distance",
      "offset-path",
      "offset-position",
      "offset-rotate",
      "opacity",
      "order",
      "origin-trial-test-property",
      "orphans",
      "outline-color",
      "outline-offset",
      "outline-style",
      "outline-width",
      "overflow-anchor",
      "overflow-block",
      "overflow-clip-margin",
      "overflow-inline",
      "overflow-wrap",
      "overflow-x",
      "overflow-y",
      "overlay",
      "override-colors",
      "overscroll-behavior-block",
      "overscroll-behavior-inline",
      "overscroll-behavior-x",
      "overscroll-behavior-y",
      "pad",
      "padding-block-end",
      "padding-block-start",
      "padding-bottom",
      "padding-inline-end",
      "padding-inline-start",
      "padding-left",
      "padding-right",
      "padding-top",
      "page",
      "page-orientation",
      "paint-order",
      "perspective",
      "perspective-origin",
      "pointer-events",
      "popover-hide-delay",
      "popover-show-delay",
      "position",
      "position-anchor",
      "position-area",
      "position-try-fallbacks",
      "position-try-order",
      "position-visibility",
      "prefix",
      "quotes",
      "r",
      "range",
      "reading-flow",
      "resize",
      "right",
      "rotate",
      "row-gap",
      "ruby-align",
      "ruby-position",
      "rx",
      "ry",
      "scale",
      "scroll-behavior",
      "scroll-margin-block-end",
      "scroll-margin-block-start",
      "scroll-margin-bottom",
      "scroll-margin-inline-end",
      "scroll-margin-inline-start",
      "scroll-margin-left",
      "scroll-margin-right",
      "scroll-margin-top",
      "scroll-marker-group",
      "scroll-padding-block-end",
      "scroll-padding-block-start",
      "scroll-padding-bottom",
      "scroll-padding-inline-end",
      "scroll-padding-inline-start",
      "scroll-padding-left",
      "scroll-padding-right",
      "scroll-padding-top",
      "scroll-snap-align",
      "scroll-snap-stop",
      "scroll-snap-type",
      "scroll-start-block",
      "scroll-start-inline",
      "scroll-start-target",
      "scroll-start-x",
      "scroll-start-y",
      "scroll-timeline-axis",
      "scroll-timeline-name",
      "scrollbar-color",
      "scrollbar-gutter",
      "scrollbar-width",
      "shape-image-threshold",
      "shape-margin",
      "shape-outside",
      "shape-rendering",
      "size",
      "size-adjust",
      "speak",
      "speak-as",
      "src",
      "stop-color",
      "stop-opacity",
      "stroke",
      "stroke-dasharray",
      "stroke-dashoffset",
      "stroke-linecap",
      "stroke-linejoin",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke-width",
      "suffix",
      "symbols",
      "syntax",
      "system",
      "tab-size",
      "table-layout",
      "text-align",
      "text-align-last",
      "text-anchor",
      "text-autospace",
      "text-box-edge",
      "text-box-trim",
      "text-combine-upright",
      "text-decoration-color",
      "text-decoration-line",
      "text-decoration-skip-ink",
      "text-decoration-style",
      "text-decoration-thickness",
      "text-emphasis-color",
      "text-emphasis-position",
      "text-emphasis-style",
      "text-indent",
      "text-orientation",
      "text-overflow",
      "text-rendering",
      "text-shadow",
      "text-size-adjust",
      "text-spacing-trim",
      "text-transform",
      "text-underline-offset",
      "text-underline-position",
      "text-wrap-mode",
      "text-wrap-style",
      "timeline-scope",
      "top",
      "touch-action",
      "transform",
      "transform-box",
      "transform-origin",
      "transform-style",
      "transition-behavior",
      "transition-delay",
      "transition-duration",
      "transition-property",
      "transition-timing-function",
      "translate",
      "types",
      "unicode-range",
      "user-select",
      "vector-effect",
      "vertical-align",
      "view-timeline-axis",
      "view-timeline-inset",
      "view-timeline-name",
      "view-transition-capture-mode",
      "view-transition-class",
      "view-transition-group",
      "view-transition-name",
      "visibility",
      "white-space-collapse",
      "widows",
      "width",
      "will-change",
      "word-break",
      "word-spacing",
      "writing-mode",
      "x",
      "y",
      "z-index",
      "zoom"
    ],
    "name": "all"
  },
  {
    "keywords": [
      "none"
    ],
    "name": "anchor-name"
  },
  {
    "keywords": [
      "none",
      "all"
    ],
    "name": "anchor-scope"
  },
  {
    "longhands": [
      "animation-duration",
      "animation-timing-function",
      "animation-delay",
      "animation-iteration-count",
      "animation-direction",
      "animation-fill-mode",
      "animation-play-state",
      "animation-name"
    ],
    "name": "animation"
  },
  {
    "keywords": [
      "replace",
      "add",
      "accumulate"
    ],
    "name": "animation-composition"
  },
  {
    "name": "animation-delay"
  },
  {
    "keywords": [
      "normal",
      "reverse",
      "alternate",
      "alternate-reverse"
    ],
    "name": "animation-direction"
  },
  {
    "name": "animation-duration"
  },
  {
    "keywords": [
      "none",
      "forwards",
      "backwards",
      "both"
    ],
    "name": "animation-fill-mode"
  },
  {
    "keywords": [
      "infinite"
    ],
    "name": "animation-iteration-count"
  },
  {
    "keywords": [
      "none"
    ],
    "name": "animation-name"
  },
  {
    "keywords": [
      "running",
      "paused"
    ],
    "name": "animation-play-state"
  },
  {
    "longhands": [
      "animation-range-start",
      "animation-range-end"
    ],
    "name": "animation-range"
  },
  {
    "name": "animation-range-end"
  },
  {
    "name": "animation-range-start"
  },
  {
    "keywords": [
      "none",
      "auto"
    ],
    "name": "animation-timeline"
  },
  {
    "keywords": [
      "linear",
      "ease",
      "ease-in",
      "ease-out",
      "ease-in-out",
      "jump-both",
      "jump-end",
      "jump-none",
      "jump-start",
      "step-start",
      "step-end"
    ],
    "name": "animation-timing-function"
  },
  {
    "keywords": [
      "none",
      "drag",
      "no-drag"
    ],
    "name": "app-region"
  },
  {
    "name": "appearance"
  },
  {
    "name": "ascent-override"
  },
  {
    "keywords": [
      "auto"
    ],
    "name": "aspect-ratio"
  },
  {
    "keywords": [
      "none"
    ],
    "name": "backdrop-filter"
  },
  {
    "keywords": [
      "visible",
      "hidden"
    ],
    "name": "backface-visibility"
  },
  {
    "longhands": [
      "background-image",
      "background-position-x",
      "background-position-y",
      "background-size",
      "background-repeat",
      "background-attachment",
      "background-origin",
      "background-clip",
      "background-color"
    ],
    "name": "background"
  },
  {
    "keywords": [
      "scroll",
      "fixed",
      "local"
    ],
    "name": "background-attachment"
  },
  {
    "keywords": [
      "normal",
      "multiply",
      "screen",
      "overlay",
      "darken",
      "lighten",
      "color-dodge",
      "color-burn",
      "hard-light",
      "soft-light",
      "difference",
      "exclusion",
      "hue",
      "saturation",
      "color",
      "luminosity"
    ],
    "name": "background-blend-mode"
  },
  {
    "keywords": [
      "border-box",
      "padding-box",
      "content-box",
      "text"
    ],
    "name": "background-clip"
  },
  {
    "keywords": [
      "currentcolor"
    ],
    "name": "background-color"
  },
  {
    "keywords": [
      "auto",
      "none"
    ],
    "name": "background-image"
  },
  {
    "keywords": [
      "border-box",
      "padding-box",
      "content-box"
    ],
    "name": "background-origin"
  },
  {
    "longhands": [
      "background-position-x",
      "background-position-y"
    ],
    "name": "background-position"
  },
  {
    "name": "background-position-x"
  },
  {
    "name": "background-position-y"
  },
  {
    "name": "background-repeat"
  },
  {
    "keywords": [
      "auto",
      "cover",
      "contain"
    ],
    "name": "background-size"
  },
  {
    "name": "base-palette"
  },
  {
    "keywords": [
      "baseline",
      "sub",
      "super"
    ],
    "name": "baseline-shift"
  },
  {
    "keywords": [
      "auto",
      "first",
      "last"
    ],
    "name": "baseline-source"
  },
  {
    "keywords": [
      "auto"
    ],
    "name": "block-size"
  },
  {
    "longhands": [
      "border-top-color",
      "border-top-style",
      "border-top-width",
      "border-right-color",
      "border-right-style",
      "border-right-width",
      "border-bottom-color",
      "border-bottom-style",
      "border-bottom-width",
      "border-left-color",
      "border-left-style",
      "border-left-width",
      "border-image-source",
      "border-image-slice",
      "border-image-width",
      "border-image-outset",
      "border-image-repeat"
    ],
    "name": "border"
  },
  {
    "longhands": [
      "border-block-start-color",
      "border-block-start-style",
      "border-block-start-width",
      "border-block-end-color",
      "border-block-end-style",
      "border-block-end-width"
    ],
    "name": "border-block"
  },
  {
    "longhands": [
      "border-block-start-color",
      "border-block-end-color"
    ],
    "name": "border-block-color"
  },
  {
    "longhands": [
      "border-block-end-width",
      "border-block-end-style",
      "border-block-end-color"
    ],
    "name": "border-block-end"
  },
  {
    "name": "border-block-end-color"
  },
  {
    "name": "border-block-end-style"
  },
  {
    "name": "border-block-end-width"
  },
  {
    "longhands": [
      "border-block-start-width",
      "border-block-start-style",
      "border-block-start-color"
    ],
    "name": "border-block-start"
  },
  {
    "name": "border-block-start-color"
  },
  {
    "name": "border-block-start-style"
  },
  {
    "name": "border-block-start-width"
  },
  {
    "longhands": [
      "border-block-start-style",
      "border-block-end-style"
    ],
    "name": "border-block-style"
  },
  {
    "longhands": [
      "border-block-start-width",
      "border-block-end-width"
    ],
    "name": "border-block-width"
  },
  {
    "longhands": [
      "border-bottom-width",
      "border-bottom-style",
      "border-bottom-color"
    ],
    "name": "border-bottom"
  },
  {
    "keywords": [
      "currentcolor"
    ],
    "name": "border-bottom-color"
  },
  {
    "name": "border-bottom-left-radius"
  },
  {
    "name": "border-bottom-right-radius"
  },
  {
    "keywords": [
      "none",
      "hidden",
      "inset",
      "groove",
      "outset",
      "ridge",
      "dotted",
      "dashed",
      "solid",
      "double"
    ],
    "name": "border-bottom-style"
  },
  {
    "keywords": [
      "thin",
      "medium",
      "thick"
    ],
    "name": "border-bottom-width"
  },
  {
    "inherited": true,
    "keywords": [
      "separate",
      "collapse"
    ],
    "name": "border-collapse"
  },
  {
    "longhands": [
      "border-top-color",
      "border-right-color",
      "border-bottom-color",
      "border-left-color"
    ],
    "name": "border-color"
  },
  {
    "name": "border-end-end-radius"
  },
  {
    "name": "border-end-start-radius"
  },
  {
    "longhands": [
      "border-image-source",
      "border-image-slice",
      "border-image-width",
      "border-image-outset",
      "border-image-repeat"
    ],
    "name": "border-image"
  },
  {
    "name": "border-image-outset"
  },
  {
    "keywords": [
      "stretch",
      "repeat",
      "round",
      "space"
    ],
    "name": "border-image-repeat"
  },
  {
    "name": "border-image-slice"
  },
  {
    "keywords": [
      "none"
    ],
    "name": "border-image-source"
  },
  {
    "keywords": [
      "auto"
    ],
    "name": "border-image-width"
  },
  {
    "longhands": [
      "border-inline-start-color",
      "border-inline-start-style",
      "border-inline-start-width",
      "border-inline-end-color",
      "border-inline-end-style",
      "border-inline-end-width"
    ],
    "name": "border-inline"
  },
  {
    "longhands": [
      "border-inline-start-color",
      "border-inline-end-color"
    ],
    "name": "border-inline-color"
  },
  {
    "longhands": [
      "border-inline-end-width",
      "border-inline-end-style",
      "border-inline-end-color"
    ],
    "name": "border-inline-end"
  },
  {
    "name": "border-inline-end-color"
  },
  {
    "name": "border-inline-end-style"
  },
  {
    "name": "border-inline-end-width"
  },
  {
    "longhands": [
      "border-inline-start-width",
      "border-inline-start-style",
      "border-inline-start-color"
    ],
    "name": "border-inline-start"
  },
  {
    "name": "border-inline-start-color"
  },
  {
    "name": "border-inline-start-style"
  },
  {
    "name": "border-inline-start-width"
  },
  {
    "longhands": [
      "border-inline-start-style",
      "border-inline-end-style"
    ],
    "name": "border-inline-style"
  },
  {
    "longhands": [
      "border-inline-start-width",
      "border-inline-end-width"
    ],
    "name": "border-inline-width"
  },
  {
    "longhands": [
      "border-left-width",
      "border-left-style",
      "border-left-color"
    ],
    "name": "border-left"
  },
  {
    "keywords": [
      "currentcolor"
    ],
    "name": "border-left-color"
  },
  {
    "keywords": [
      "none",
      "hidden",
      "inset",
      "groove",
      "outset",
      "ridge",
      "dotted",
      "dashed",
      "solid",
      "double"
    ],
    "name": "border-left-style"
  },
  {
    "keywords": [
      "thin",
      "medium",
      "thick"
    ],
    "name": "border-left-width"
  },
  {
    "longhands": [
      "border-top-left-radius",
      "border-top-right-radius",
      "border-bottom-right-radius",
      "border-bottom-left-radius"
    ],
    "name": "border-radius"
  },
  {
    "longhands": [
      "border-right-width",
      "border-right-style",
      "border-right-color"
    ],
    "name": "border-right"
  },
  {
    "keywords": [
      "currentcolor"
    ],
    "name": "border-right-color"
  },
  {
    "keywords": [
      "none",
      "hidden",
      "inset",
      "groove",
      "outset",
      "ridge",
      "dotted",
      "dashed",
      "solid",
      "double"
    ],
    "name": "border-right-style"
  },
  {
    "keywords": [
      "thin",
      "medium",
      "thick"
    ],
    "name": "border-right-width"
  },
  {
    "inherited": true,
    "longhands": [
      "-webkit-border-horizontal-spacing",
      "-webkit-border-vertical-spacing"
    ],
    "name": "border-spacing"
  },
  {
    "name": "border-start-end-radius"
  },
  {
    "name": "border-start-start-radius"
  },
  {
    "keywords": [
      "none"
    ],
    "longhands": [
      "border-top-style",
      "border-right-style",
      "border-bottom-style",
      "border-left-style"
    ],
    "name": "border-style"
  },
  {
    "longhands": [
      "border-top-width",
      "border-top-style",
      "border-top-color"
    ],
    "name": "border-top"
  },
  {
    "keywords": [
      "currentcolor"
    ],
    "name": "border-top-color"
  },
  {
    "name": "border-top-left-radius"
  },
  {
    "name": "border-top-right-radius"
  },
  {
    "keywords": [
      "none",
      "hidden",
      "inset",
      "groove",
      "outset",
      "ridge",
      "dotted",
      "dashed",
      "solid",
      "double"
    ],
    "name": "border-top-style"
  },
  {
    "keywords": [
      "thin",
      "medium",
      "thick"
    ],
    "name": "border-top-width"
  },
  {
    "longhands": [
      "border-top-width",
      "border-right-width",
      "border-bottom-width",
      "border-left-width"
    ],
    "name": "border-width"
  },
  {
    "keywords": [
      "auto"
    ],
    "name": "bottom"
  },
  {
    "keywords": [
      "slice",
      "clone"
    ],
    "name": "box-decoration-break"
  },
  {
    "keywords": [
      "none"
    ],
    "name": "box-shadow"
  },
  {
    "keywords": [
      "content-box",
      "border-box"
    ],
    "name": "box-sizing"
  },
  {
    "keywords": [
      "auto",
      "avoid",
      "avoid-column",
      "avoid-page",
      "column",
      "left",
      "page",
      "recto",
      "right",
      "verso"
    ],
    "name": "break-after"
  },
  {
    "keywords": [
      "auto",
      "avoid",
      "avoid-column",
      "avoid-page",
      "column",
      "left",
      "page",
      "recto",
      "right",
      "verso"
    ],
    "name": "break-before"
  },
  {
    "keywords": [
      "auto",
      "avoid",
      "avoid-column",
      "avoid-page"
    ],
    "name": "break-inside"
  },
  {
    "keywords": [
      "auto",
      "dynamic",
      "static"
    ],
    "name": "buffered-rendering"
  },
  {
    "inherited": true,
    "keywords": [
      "top",
      "bottom"
    ],
    "name": "caption-side"
  },
  {
    "inherited": true,
    "keywords": [
      "auto",
      "manual"
    ],
    "name": "caret-animation"
  },
  {
    "inherited": true,
    "keywords": [
      "auto",
      "currentcolor"
    ],
    "name": "caret-color"
  },
  {
    "keywords": [
      "none",
      "left",
      "right",
      "both",
      "inline-start",
      "inline-end"
    ],
    "name": "clear"
  },
  {
    "keywords": [
      "auto"
    ],
    "name": "clip"
  },
  {
    "keywords": [
      "border-box",
      "padding-box",
      "content-box",
      "margin-box",
      "fill-box",
      "stroke-box",
      "view-box",
      "none"
    ],
    "name": "clip-path"
  },
  {
    "inherited": true,
    "keywords": [
      "nonzero",
      "evenodd"
    ],
    "name": "clip-rule"
  },
  {
    "inherited": true,
    "keywords": [
      "currentcolor"
    ],
    "name": "color"
  },
  {
    "inherited": true,
    "keywords": [
      "auto",
      "srgb",
      "linearrgb"
    ],
    "name": "color-interpolation"
  },
  {
    "inherited": true,
    "keywords": [
      "auto",
      "srgb",
      "linearrgb"
    ],
    "name": "color-interpolation-filters"
  },
  {
    "inherited": true,
    "keywords": [
      "auto",
      "optimizespeed",
      "optimizequality"
    ],
    "name": "color-rendering"
  },
  {
    "inherited": true,
    "name": "color-scheme"
  },
  {
    "keywords": [
      "auto"
    ],
    "name": "column-count"
  },
  {
    "keywords": [
      "balance",
      "auto"
    ],
    "name": "column-fill"
  },
  {
    "keywords": [
      "normal"
    ],
    "name": "column-gap"
  },
  {
    "longhands": [
      "column-rule-width",
      "column-rule-style",
      "column-rule-color"
    ],
    "name": "column-rule"
  },
  {
    "keywords": [
      "currentcolor"
    ],
    "name": "column-rule-color"
  },
  {
    "keywords": [
      "none",
      "hidden",
      "inset",
      "groove",
      "outset",
      "ridge",
      "dotted",
      "dashed",
      "solid",
      "double"
    ],
    "name": "column-rule-style"
  },
  {
    "keywords": [
      "thin",
      "medium",
      "thick"
    ],
    "name": "column-rule-width"
  },
  {
    "keywords": [
      "none",
      "all"
    ],
    "name": "column-span"
  },
  {
    "keywords": [
      "auto"
    ],
    "name": "column-width"
  },
  {
    "longhands": [
      "column-width",
      "column-count"
    ],
    "name": "columns"
  },
  {
    "keywords": [
      "none",
      "strict",
      "content",
      "size",
      "layout",
      "style",
      "paint",
      "inline-size",
      "block-size"
    ],
    "name": "contain"
  },
  {
    "name": "contain-intrinsic-block-size"
  },
  {
    "keywords": [
      "none"
    ],
    "name": "contain-intrinsic-height"
  },
  {
    "name": "contain-intrinsic-inline-size"
  },
  {
    "longhands": [
      "contain-intrinsic-width",
      "contain-intrinsic-height"
    ],
    "name": "contain-intrinsic-size"
  },
  {
    "keywords": [
      "none"
    ],
    "name": "contain-intrinsic-width"
  },
  {
    "longhands": [
      "container-name",
      "container-type"
    ],
    "name": "container"
  },
  {
    "keywords": [
      "none"
    ],
    "name": "container-name"
  },
  {
    "keywords": [
      "normal",
      "inline-size",
      "size",
      "scroll-state"
    ],
    "name": "container-type"
  },
  {
    "name": "content"
  },
  {
    "keywords": [
      "visible",
      "auto",
      "hidden"
    ],
    "name": "content-visibility"
  },
  {
    "keywords": [
      "none"
    ],
    "name": "counter-increment"
  },
  {
    "keywords": [
      "none"
    ],
    "name": "counter-reset"
  },
  {
    "keywords": [
      "none"
    ],
    "name": "counter-set"
  },
  {
    "inherited": true,
    "keywords": [
      "auto",
      "default",
      "none",
      "context-menu",
      "help",
      "pointer",
      "progress",
      "wait",
      "cell",
      "crosshair",
      "text",
      "vertical-text",
      "alias",
      "copy",
      "move",
      "no-drop",
      "not-allowed",
      "e-resize",
      "n-resize",
      "ne-resize",
      "nw-resize",
      "s-resize",
      "se-resize",
      "sw-resize",
      "w-resize",
      "ew-resize",
      "ns-resize",
      "nesw-resize",
      "nwse-resize",
      "col-resize",
      "row-resize",
      "all-scroll",
      "zoom-in",
      "zoom-out",
      "grab",
      "grabbing"
    ],
    "name": "cursor"
  },
  {
    "name": "cx"
  },
  {
    "name": "cy"
  },
  {
    "keywords": [
      "none"
    ],
    "name": "d"
  },
  {
    "name": "descent-override"
  },
  {
    "inherited": true,
    "keywords": [
      "ltr",
      "rtl"
    ],
    "name": "direction"
  },
  {
    "keywords": [
      "inline",
      "block",
      "list-item",
      "inline-block",
      "table",
      "inline-table",
      "table-row-group",
      "table-header-group",
      "table-footer-group",
      "table-row",
      "table-column-group",
      "table-column",
      "table-cell",
      "table-caption",
      "-webkit-box",
      "-webkit-inline-box",
      "flex",
      "inline-flex",
      "grid",
      "inline-grid",
      "contents",
      "flow-root",
      "none",
      "flow",
      "math",
      "ruby",
      "ruby-text",
      "masonry",
      "inline-masonry"
    ],
    "name": "display"
  },
  {
    "inherited": true,
    "keywords": [
      "auto",
      "alphabetic",
      "ideographic",
      "middle",
      "central",
      "mathematical",
      "hanging",
      "use-script",
      "no-change",
      "reset-size",
      "text-after-edge",
      "text-before-edge"
    ],
    "name": "dominant-baseline"
  },
  {
    "inherited": true,
    "keywords": [
      "standard",
      "high",
      "constrained-high"
    ],
    "name": "dynamic-range-limit"
  },
  {
    "inherited": true,
    "keywords": [
      "show",
      "hide"
    ],
    "name": "empty-cells"
  },
  {
    "name": "fallback"
  },
  {
    "keywords": [
      "fixed",
      "content"
    ],
    "name": "field-sizing"
  },
  {
    "inherited": true,
    "name": "fill"
  },
  {
    "inherited": true,
    "name": "fill-opacity"
  },
  {
    "inherited": true,
    "keywords": [
      "nonzero",
      "evenodd"
    ],
    "name": "fill-rule"
  },
  {
    "keywords": [
      "none"
    ],
    "name": "filter"
  },
  {
    "longhands": [
      "flex-grow",
      "flex-shrink",
      "flex-basis"
    ],
    "name": "flex"
  },
  {
    "keywords": [
      "auto",
      "fit-content",
      "min-content",
      "max-content",
      "content"
    ],
    "name": "flex-basis"
  },
  {
    "keywords": [
      "row",
      "row-reverse",
      "column",
      "column-reverse"
    ],
    "name": "flex-direction"
  },
  {
    "longhands": [
      "flex-direction",
      "flex-wrap"
    ],
    "name": "flex-flow"
  },
  {
    "name": "flex-grow"
  },
  {
    "name": "flex-shrink"
  },
  {
    "keywords": [
      "nowrap",
      "wrap",
      "wrap-reverse"
    ],
    "name": "flex-wrap"
  },
  {
    "keywords": [
      "none",
      "left",
      "right",
      "inline-start",
      "inline-end"
    ],
    "name": "float"
  },
  {
    "keywords": [
      "currentcolor"
    ],
    "name": "flood-color"
  },
  {
    "name": "flood-opacity"
  },
  {
    "inherited": true,
    "longhands": [
      "font-style",
      "font-variant-ligatures",
      "font-variant-caps",
      "font-variant-numeric",
      "font-variant-east-asian",
      "font-variant-alternates",
      "font-variant-position",
      "font-variant-emoji",
      "font-weight",
      "font-stretch",
      "font-size",
      "line-height",
      "font-family",
      "font-optical-sizing",
      "font-size-adjust",
      "font-kerning",
      "font-feature-settings",
      "font-variation-settings"
    ],
    "name": "font"
  },
  {
    "name": "font-display"
  },
  {
    "inherited": true,
    "name": "font-family"
  },
  {
    "inherited": true,
    "keywords": [
      "normal"
    ],
    "name": "font-feature-settings"
  },
  {
    "inherited": true,
    "keywords": [
      "auto",
      "normal",
      "none"
    ],
    "name": "font-kerning"
  },
  {
    "inherited": true,
    "keywords": [
      "auto",
      "none"
    ],
    "name": "font-optical-sizing"
  },
  {
    "inherited": true,
    "keywords": [
      "normal",
      "light",
      "dark"
    ],
    "name": "font-palette"
  },
  {
    "inherited": true,
    "keywords": [
      "xx-small",
      "x-small",
      "small",
      "medium",
      "large",
      "x-large",
      "xx-large",
      "xxx-large",
      "larger",
      "smaller",
      "-webkit-xxx-large"
    ],
    "name": "font-size"
  },
  {
    "inherited": true,
    "keywords": [
      "none",
      "ex-height",
      "cap-height",
      "ch-width",
      "ic-width",
      "ic-height",
      "from-font"
    ],
    "name": "font-size-adjust"
  },
  {
    "inherited": true,
    "keywords": [
      "normal",
      "ultra-condensed",
      "extra-condensed",
      "condensed",
      "semi-condensed",
      "semi-expanded",
      "expanded",
      "extra-expanded",
      "ultra-expanded"
    ],
    "name": "font-stretch"
  },
  {
    "inherited": true,
    "keywords": [
      "normal",
      "italic",
      "oblique"
    ],
    "name": "font-style"
  },
  {
    "inherited": true,
    "longhands": [
      "font-synthesis-weight",
      "font-synthesis-style",
      "font-synthesis-small-caps"
    ],
    "name": "font-synthesis"
  },
  {
    "inherited": true,
    "keywords": [
      "auto",
      "none"
    ],
    "name": "font-synthesis-small-caps"
  },
  {
    "inherited": true,
    "keywords": [
      "auto",
      "none"
    ],
    "name": "font-synthesis-style"
  },
  {
    "inherited": true,
    "keywords": [
      "auto",
      "none"
    ],
    "name": "font-synthesis-weight"
  },
  {
    "inherited": true,
    "longhands": [
      "font-variant-ligatures",
      "font-variant-caps",
      "font-variant-alternates",
      "font-variant-numeric",
      "font-variant-east-asian",
      "font-variant-position",
      "font-variant-emoji"
    ],
    "name": "font-variant"
  },
  {
    "inherited": true,
    "keywords": [
      "normal"
    ],
    "name": "font-variant-alternates"
  },
  {
    "inherited": true,
    "keywords": [
      "normal",
      "small-caps",
      "all-small-caps",
      "petite-caps",
      "all-petite-caps",
      "unicase",
      "titling-caps"
    ],
    "name": "font-variant-caps"
  },
  {
    "inherited": true,
    "keywords": [
      "normal",
      "jis78",
      "jis83",
      "jis90",
      "jis04",
      "simplified",
      "traditional",
      "full-width",
      "proportional-width",
      "ruby"
    ],
    "name": "font-variant-east-asian"
  },
  {
    "inherited": true,
    "keywords": [
      "normal",
      "text",
      "emoji",
      "unicode"
    ],
    "name": "font-variant-emoji"
  },
  {
    "inherited": true,
    "keywords": [
      "normal",
      "none",
      "common-ligatures",
      "no-common-ligatures",
      "discretionary-ligatures",
      "no-discretionary-ligatures",
      "historical-ligatures",
      "no-historical-ligatures",
      "contextual",
      "no-contextual"
    ],
    "name": "font-variant-ligatures"
  },
  {
    "inherited": true,
    "keywords": [
      "normal",
      "lining-nums",
      "oldstyle-nums",
      "proportional-nums",
      "tabular-nums",
      "diagonal-fractions",
      "stacked-fractions",
      "ordinal",
      "slashed-zero"
    ],
    "name": "font-variant-numeric"
  },
  {
    "inherited": true,
    "keywords": [
      "normal",
      "sub",
      "super"
    ],
    "name": "font-variant-position"
  },
  {
    "inherited": true,
    "keywords": [
      "normal"
    ],
    "name": "font-variation-settings"
  },
  {
    "inherited": true,
    "keywords": [
      "normal",
      "bold",
      "bolder",
      "lighter"
    ],
    "name": "font-weight"
  },
  {
    "inherited": true,
    "keywords": [
      "auto",
      "none",
      "preserve-parent-color"
    ],
    "name": "forced-color-adjust"
  },
  {
    "longhands": [
      "row-gap",
      "column-gap"
    ],
    "name": "gap"
  },
  {
    "longhands": [
      "grid-template-rows",
      "grid-template-columns",
      "grid-template-areas",
      "grid-auto-flow",
      "grid-auto-rows",
      "grid-auto-columns"
    ],
    "name": "grid"
  },
  {
    "longhands": [
      "grid-row-start",
      "grid-column-start",
      "grid-row-end",
      "grid-column-end"
    ],
    "name": "grid-area"
  },
  {
    "keywords": [
      "auto",
      "min-content",
      "max-content"
    ],
    "name": "grid-auto-columns"
  },
  {
    "keywords": [
      "row",
      "column"
    ],
    "name": "grid-auto-flow"
  },
  {
    "keywords": [
      "auto",
      "min-content",
      "max-content"
    ],
    "name": "grid-auto-rows"
  },
  {
    "longhands": [
      "grid-column-start",
      "grid-column-end"
    ],
    "name": "grid-column"
  },
  {
    "keywords": [
      "auto"
    ],
    "name": "grid-column-end"
  },
  {
    "keywords": [
      "auto"
    ],
    "name": "grid-column-start"
  },
  {
    "longhands": [
      "grid-row-start",
      "grid-row-end"
    ],
    "name": "grid-row"
  },
  {
    "keywords": [
      "auto"
    ],
    "name": "grid-row-end"
  },
  {
    "keywords": [
      "auto"
    ],
    "name": "grid-row-start"
  },
  {
    "longhands": [
      "grid-template-rows",
      "grid-template-columns",
      "grid-template-areas"
    ],
    "name": "grid-template"
  },
  {
    "keywords": [
      "none"
    ],
    "name": "grid-template-areas"
  },
  {
    "keywords": [
      "none"
    ],
    "name": "grid-template-columns"
  },
  {
    "keywords": [
      "none"
    ],
    "name": "grid-template-rows"
  },
  {
    "keywords": [
      "auto",
      "fit-content",
      "min-content",
      "max-content"
    ],
    "name": "height"
  },
  {
    "inherited": true,
    "name": "hyphenate-character"
  },
  {
    "inherited": true,
    "keywords": [
      "auto"
    ],
    "name": "hyphenate-limit-chars"
  },
  {
    "inherited": true,
    "keywords": [
      "none",
      "manual",
      "auto"
    ],
    "name": "hyphens"
  },
  {
    "inherited": true,
    "name": "image-orientation"
  },
  {
    "inherited": true,
    "keywords": [
      "auto",
      "optimizespeed",
      "optimizequality",
      "-webkit-optimize-contrast",
      "pixelated"
    ],
    "name": "image-rendering"
  },
  {
    "name": "inherits"
  },
  {
    "inherited": false,
    "keywords": [
      "drop",
      "normal",
      "raise"
    ],
    "name": "initial-letter"
  },
  {
    "name": "initial-value"
  },
  {
    "keywords": [
      "auto"
    ],
    "name": "inline-size"
  },
  {
    "longhands": [
      "top",
      "right",
      "bottom",
      "left"
    ],
    "name": "inset"
  },
  {
    "longhands": [
      "inset-block-start",
      "inset-block-end"
    ],
    "name": "inset-block"
  },
  {
    "name": "inset-block-end"
  },
  {
    "name": "inset-block-start"
  },
  {
    "longhands": [
      "inset-inline-start",
      "inset-inline-end"
    ],
    "name": "inset-inline"
  },
  {
    "name": "inset-inline-end"
  },
  {
    "name": "inset-inline-start"
  },
  {
    "inherited": true,
    "keywords": [
      "auto",
      "inert"
    ],
    "name": "interactivity"
  },
  {
    "inherited": true,
    "keywords": [
      "numeric-only",
      "allow-keywords"
    ],
    "name": "interpolate-size"
  },
  {
    "keywords": [
      "auto",
      "isolate"
    ],
    "name": "isolation"
  },
  {
    "name": "justify-content"
  },
  {
    "name": "justify-items"
  },
  {
    "name": "justify-self"
  },
  {
    "keywords": [
      "auto"
    ],
    "name": "left"
  },
  {
    "inherited": true,
    "keywords": [
      "normal"
    ],
    "name": "letter-spacing"
  },
  {
    "keywords": [
      "currentcolor"
    ],
    "name": "lighting-color"
  },
  {
    "inherited": true,
    "keywords": [
      "auto",
      "loose",
      "normal",
      "strict",
      "anywhere"
    ],
    "name": "line-break"
  },
  {
    "keywords": [
      "none",
      "auto"
    ],
    "name": "line-clamp"
  },
  {
    "name": "line-gap-override"
  },
  {
    "inherited": true,
    "keywords": [
      "normal"
    ],
    "name": "line-height"
  },
  {
    "inherited": true,
    "longhands": [
      "list-style-position",
      "list-style-image",
      "list-style-type"
    ],
    "name": "list-style"
  },
  {
    "inherited": true,
    "keywords": [
      "none"
    ],
    "name": "list-style-image"
  },
  {
    "inherited": true,
    "keywords": [
      "outside",
      "inside"
    ],
    "name": "list-style-position"
  },
  {
    "inherited": true,
    "keywords": [
      "disc",
      "circle",
      "square",
      "disclosure-open",
      "disclosure-closed",
      "decimal",
      "none"
    ],
    "name": "list-style-type"
  },
  {
    "longhands": [
      "margin-top",
      "margin-right",
      "margin-bottom",
      "margin-left"
    ],
    "name": "margin"
  },
  {
    "longhands": [
      "margin-block-start",
      "margin-block-end"
    ],
    "name": "margin-block"
  },
  {
    "keywords": [
      "auto"
    ],
    "name": "margin-block-end"
  },
  {
    "keywords": [
      "auto"
    ],
    "name": "margin-block-start"
  },
  {
    "keywords": [
      "auto"
    ],
    "name": "margin-bottom"
  },
  {
    "longhands": [
      "margin-inline-start",
      "margin-inline-end"
    ],
    "name": "margin-inline"
  },
  {
    "keywords": [
      "auto"
    ],
    "name": "margin-inline-end"
  },
  {
    "keywords": [
      "auto"
    ],
    "name": "margin-inline-start"
  },
  {
    "keywords": [
      "auto"
    ],
    "name": "margin-left"
  },
  {
    "keywords": [
      "auto"
    ],
    "name": "margin-right"
  },
  {
    "keywords": [
      "auto"
    ],
    "name": "margin-top"
  },
  {
    "inherited": true,
    "longhands": [
      "marker-start",
      "marker-mid",
      "marker-end"
    ],
    "name": "marker"
  },
  {
    "inherited": true,
    "keywords": [
      "none"
    ],
    "name": "marker-end"
  },
  {
    "inherited": true,
    "keywords": [
      "none"
    ],
    "name": "marker-mid"
  },
  {
    "inherited": true,
    "keywords": [
      "none"
    ],
    "name": "marker-start"
  },
  {
    "longhands": [
      "mask-image",
      "-webkit-mask-position-x",
      "-webkit-mask-position-y",
      "mask-size",
      "mask-repeat",
      "mask-origin",
      "mask-clip",
      "mask-composite",
      "mask-mode"
    ],
    "name": "mask"
  },
  {
    "name": "mask-clip"
  },
  {
    "name": "mask-composite"
  },
  {
    "name": "mask-image"
  },
  {
    "name": "mask-mode"
  },
  {
    "name": "mask-origin"
  },
  {
    "longhands": [
      "-webkit-mask-position-x",
      "-webkit-mask-position-y"
    ],
    "name": "mask-position"
  },
  {
    "name": "mask-repeat"
  },
  {
    "name": "mask-size"
  },
  {
    "keywords": [
      "luminance",
      "alpha"
    ],
    "name": "mask-type"
  },
  {
    "keywords": [
      "normal"
    ],
    "name": "masonry-slack"
  },
  {
    "name": "masonry-template-tracks"
  },
  {
    "longhands": [
      "masonry-track-start",
      "masonry-track-end"
    ],
    "name": "masonry-track"
  },
  {
    "keywords": [
      "auto"
    ],
    "name": "masonry-track-end"
  },
  {
    "keywords": [
      "auto"
    ],
    "name": "masonry-track-start"
  },
  {
    "inherited": true,
    "name": "math-depth"
  },
  {
    "inherited": true,
    "keywords": [
      "normal",
      "compact"
    ],
    "name": "math-shift"
  },
  {
    "inherited": true,
    "keywords": [
      "normal",
      "compact"
    ],
    "name": "math-style"
  },
  {
    "keywords": [
      "none"
    ],
    "name": "max-block-size"
  },
  {
    "keywords": [
      "none"
    ],
    "name": "max-height"
  },
  {
    "keywords": [
      "none"
    ],
    "name": "max-inline-size"
  },
  {
    "keywords": [
      "none"
    ],
    "name": "max-width"
  },
  {
    "name": "min-block-size"
  },
  {
    "name": "min-height"
  },
  {
    "name": "min-inline-size"
  },
  {
    "name": "min-width"
  },
  {
    "keywords": [
      "normal",
      "multiply",
      "screen",
      "overlay",
      "darken",
      "lighten",
      "color-dodge",
      "color-burn",
      "hard-light",
      "soft-light",
      "difference",
      "exclusion",
      "hue",
      "saturation",
      "color",
      "luminosity",
      "plus-lighter"
    ],
    "name": "mix-blend-mode"
  },
  {
    "name": "navigation"
  },
  {
    "name": "negative"
  },
  {
    "keywords": [
      "fill",
      "contain",
      "cover",
      "none",
      "scale-down"
    ],
    "name": "object-fit"
  },
  {
    "name": "object-position"
  },
  {
    "keywords": [
      "none"
    ],
    "name": "object-view-box"
  },
  {
    "longhands": [
      "offset-position",
      "offset-path",
      "offset-distance",
      "offset-rotate",
      "offset-anchor"
    ],
    "name": "offset"
  },
  {
    "keywords": [
      "auto"
    ],
    "name": "offset-anchor"
  },
  {
    "name": "offset-distance"
  },
  {
    "keywords": [
      "none"
    ],
    "name": "offset-path"
  },
  {
    "keywords": [
      "auto",
      "normal"
    ],
    "name": "offset-position"
  },
  {
    "keywords": [
      "auto",
      "reverse"
    ],
    "name": "offset-rotate"
  },
  {
    "name": "opacity"
  },
  {
    "name": "order"
  },
  {
    "keywords": [
      "normal",
      "none"
    ],
    "name": "origin-trial-test-property"
  },
  {
    "inherited": true,
    "name": "orphans"
  },
  {
    "longhands": [
      "outline-color",
      "outline-style",
      "outline-width"
    ],
    "name": "outline"
  },
  {
    "keywords": [
      "currentcolor"
    ],
    "name": "outline-color"
  },
  {
    "name": "outline-offset"
  },
  {
    "keywords": [
      "none",
      "hidden",
      "inset",
      "groove",
      "outset",
      "ridge",
      "dotted",
      "dashed",
      "solid",
      "double"
    ],
    "name": "outline-style"
  },
  {
    "keywords": [
      "thin",
      "medium",
      "thick"
    ],
    "name": "outline-width"
  },
  {
    "longhands": [
      "overflow-x",
      "overflow-y"
    ],
    "name": "overflow"
  },
  {
    "inherited": false,
    "keywords": [
      "visible",
      "none",
      "auto"
    ],
    "name": "overflow-anchor"
  },
  {
    "name": "overflow-block"
  },
  {
    "keywords": [
      "border-box",
      "content-box",
      "padding-box"
    ],
    "name": "overflow-clip-margin"
  },
  {
    "name": "overflow-inline"
  },
  {
    "inherited": true,
    "keywords": [
      "normal",
      "break-word",
      "anywhere"
    ],
    "name": "overflow-wrap"
  },
  {
    "keywords": [
      "visible",
      "hidden",
      "scroll",
      "auto",
      "overlay",
      "clip"
    ],
    "name": "overflow-x"
  },
  {
    "keywords": [
      "visible",
      "hidden",
      "scroll",
      "auto",
      "overlay",
      "clip"
    ],
    "name": "overflow-y"
  },
  {
    "keywords": [
      "none",
      "auto"
    ],
    "name": "overlay"
  },
  {
    "name": "override-colors"
  },
  {
    "longhands": [
      "overscroll-behavior-x",
      "overscroll-behavior-y"
    ],
    "name": "overscroll-behavior"
  },
  {
    "name": "overscroll-behavior-block"
  },
  {
    "name": "overscroll-behavior-inline"
  },
  {
    "keywords": [
      "auto",
      "contain",
      "none"
    ],
    "name": "overscroll-behavior-x"
  },
  {
    "keywords": [
      "auto",
      "contain",
      "none"
    ],
    "name": "overscroll-behavior-y"
  },
  {
    "name": "pad"
  },
  {
    "longhands": [
      "padding-top",
      "padding-right",
      "padding-bottom",
      "padding-left"
    ],
    "name": "padding"
  },
  {
    "longhands": [
      "padding-block-start",
      "padding-block-end"
    ],
    "name": "padding-block"
  },
  {
    "name": "padding-block-end"
  },
  {
    "name": "padding-block-start"
  },
  {
    "name": "padding-bottom"
  },
  {
    "longhands": [
      "padding-inline-start",
      "padding-inline-end"
    ],
    "name": "padding-inline"
  },
  {
    "name": "padding-inline-end"
  },
  {
    "name": "padding-inline-start"
  },
  {
    "name": "padding-left"
  },
  {
    "name": "padding-right"
  },
  {
    "name": "padding-top"
  },
  {
    "keywords": [
      "auto"
    ],
    "name": "page"
  },
  {
    "longhands": [
      "break-after"
    ],
    "name": "page-break-after"
  },
  {
    "longhands": [
      "break-before"
    ],
    "name": "page-break-before"
  },
  {
    "longhands": [
      "break-inside"
    ],
    "name": "page-break-inside"
  },
  {
    "name": "page-orientation"
  },
  {
    "inherited": true,
    "keywords": [
      "normal",
      "fill",
      "stroke",
      "markers"
    ],
    "name": "paint-order"
  },
  {
    "keywords": [
      "none"
    ],
    "name": "perspective"
  },
  {
    "name": "perspective-origin"
  },
  {
    "longhands": [
      "align-content",
      "justify-content"
    ],
    "name": "place-content"
  },
  {
    "longhands": [
      "align-items",
      "justify-items"
    ],
    "name": "place-items"
  },
  {
    "longhands": [
      "align-self",
      "justify-self"
    ],
    "name": "place-self"
  },
  {
    "inherited": true,
    "keywords": [
      "none",
      "auto",
      "stroke",
      "fill",
      "painted",
      "visible",
      "visiblestroke",
      "visiblefill",
      "visiblepainted",
      "bounding-box",
      "all"
    ],
    "name": "pointer-events"
  },
  {
    "name": "popover-hide-delay"
  },
  {
    "name": "popover-show-delay"
  },
  {
    "keywords": [
      "static",
      "relative",
      "absolute",
      "fixed",
      "sticky"
    ],
    "name": "position"
  },
  {
    "keywords": [
      "auto"
    ],
    "name": "position-anchor"
  },
  {
    "keywords": [
      "none",
      "top",
      "bottom",
      "center",
      "left",
      "right",
      "x-start",
      "x-end",
      "y-start",
      "y-end",
      "start",
      "end",
      "self-start",
      "self-end",
      "all"
    ],
    "name": "position-area"
  },
  {
    "longhands": [
      "position-try-order",
      "position-try-fallbacks"
    ],
    "name": "position-try"
  },
  {
    "keywords": [
      "none",
      "flip-block",
      "flip-inline",
      "flip-start"
    ],
    "name": "position-try-fallbacks"
  },
  {
    "keywords": [
      "normal",
      "most-width",
      "most-height",
      "most-block-size",
      "most-inline-size"
    ],
    "name": "position-try-order"
  },
  {
    "keywords": [
      "always",
      "anchors-visible",
      "no-overflow"
    ],
    "name": "position-visibility"
  },
  {
    "name": "prefix"
  },
  {
    "inherited": true,
    "keywords": [
      "auto",
      "none"
    ],
    "name": "quotes"
  },
  {
    "name": "r"
  },
  {
    "name": "range"
  },
  {
    "keywords": [
      "normal",
      "flex-visual",
      "flex-flow",
      "grid-rows",
      "grid-columns",
      "grid-order"
    ],
    "name": "reading-flow"
  },
  {
    "keywords": [
      "none",
      "both",
      "horizontal",
      "vertical",
      "block",
      "inline"
    ],
    "name": "resize"
  },
  {
    "keywords": [
      "auto"
    ],
    "name": "right"
  },
  {
    "name": "rotate"
  },
  {
    "keywords": [
      "normal"
    ],
    "name": "row-gap"
  },
  {
    "inherited": true,
    "keywords": [
      "space-around",
      "start",
      "center",
      "space-between"
    ],
    "name": "ruby-align"
  },
  {
    "inherited": true,
    "keywords": [
      "over",
      "under"
    ],
    "name": "ruby-position"
  },
  {
    "keywords": [
      "auto"
    ],
    "name": "rx"
  },
  {
    "keywords": [
      "auto"
    ],
    "name": "ry"
  },
  {
    "name": "scale"
  },
  {
    "keywords": [
      "auto",
      "smooth"
    ],
    "name": "scroll-behavior"
  },
  {
    "longhands": [
      "scroll-margin-top",
      "scroll-margin-right",
      "scroll-margin-bottom",
      "scroll-margin-left"
    ],
    "name": "scroll-margin"
  },
  {
    "longhands": [
      "scroll-margin-block-start",
      "scroll-margin-block-end"
    ],
    "name": "scroll-margin-block"
  },
  {
    "name": "scroll-margin-block-end"
  },
  {
    "name": "scroll-margin-block-start"
  },
  {
    "name": "scroll-margin-bottom"
  },
  {
    "longhands": [
      "scroll-margin-inline-start",
      "scroll-margin-inline-end"
    ],
    "name": "scroll-margin-inline"
  },
  {
    "name": "scroll-margin-inline-end"
  },
  {
    "name": "scroll-margin-inline-start"
  },
  {
    "name": "scroll-margin-left"
  },
  {
    "name": "scroll-margin-right"
  },
  {
    "name": "scroll-margin-top"
  },
  {
    "keywords": [
      "none",
      "after",
      "before"
    ],
    "name": "scroll-marker-group"
  },
  {
    "longhands": [
      "scroll-padding-top",
      "scroll-padding-right",
      "scroll-padding-bottom",
      "scroll-padding-left"
    ],
    "name": "scroll-padding"
  },
  {
    "longhands": [
      "scroll-padding-block-start",
      "scroll-padding-block-end"
    ],
    "name": "scroll-padding-block"
  },
  {
    "keywords": [
      "auto"
    ],
    "name": "scroll-padding-block-end"
  },
  {
    "keywords": [
      "auto"
    ],
    "name": "scroll-padding-block-start"
  },
  {
    "keywords": [
      "auto"
    ],
    "name": "scroll-padding-bottom"
  },
  {
    "longhands": [
      "scroll-padding-inline-start",
      "scroll-padding-inline-end"
    ],
    "name": "scroll-padding-inline"
  },
  {
    "keywords": [
      "auto"
    ],
    "name": "scroll-padding-inline-end"
  },
  {
    "keywords": [
      "auto"
    ],
    "name": "scroll-padding-inline-start"
  },
  {
    "keywords": [
      "auto"
    ],
    "name": "scroll-padding-left"
  },
  {
    "keywords": [
      "auto"
    ],
    "name": "scroll-padding-right"
  },
  {
    "keywords": [
      "auto"
    ],
    "name": "scroll-padding-top"
  },
  {
    "keywords": [
      "none",
      "start",
      "end",
      "center"
    ],
    "name": "scroll-snap-align"
  },
  {
    "keywords": [
      "normal",
      "always"
    ],
    "name": "scroll-snap-stop"
  },
  {
    "keywords": [
      "none",
      "x",
      "y",
      "block",
      "inline",
      "both",
      "mandatory",
      "proximity"
    ],
    "name": "scroll-snap-type"
  },
  {
    "longhands": [
      "scroll-start-block",
      "scroll-start-inline"
    ],
    "name": "scroll-start"
  },
  {
    "name": "scroll-start-block"
  },
  {
    "name": "scroll-start-inline"
  },
  {
    "keywords": [
      "none",
      "auto"
    ],
    "name": "scroll-start-target"
  },
  {
    "name": "scroll-start-x"
  },
  {
    "name": "scroll-start-y"
  },
  {
    "longhands": [
      "scroll-timeline-name",
      "scroll-timeline-axis"
    ],
    "name": "scroll-timeline"
  },
  {
    "name": "scroll-timeline-axis"
  },
  {
    "name": "scroll-timeline-name"
  },
  {
    "inherited": true,
    "keywords": [
      "auto"
    ],
    "name": "scrollbar-color"
  },
  {
    "inherited": false,
    "keywords": [
      "auto",
      "stable",
      "both-edges"
    ],
    "name": "scrollbar-gutter"
  },
  {
    "inherited": false,
    "keywords": [
      "auto",
      "thin",
      "none"
    ],
    "name": "scrollbar-width"
  },
  {
    "name": "shape-image-threshold"
  },
  {
    "keywords": [
      "none"
    ],
    "name": "shape-margin"
  },
  {
    "keywords": [
      "none"
    ],
    "name": "shape-outside"
  },
  {
    "inherited": true,
    "keywords": [
      "auto",
      "optimizespeed",
      "crispedges",
      "geometricprecision"
    ],
    "name": "shape-rendering"
  },
  {
    "name": "size"
  },
  {
    "name": "size-adjust"
  },
  {
    "inherited": true,
    "keywords": [
      "none",
      "normal",
      "spell-out",
      "digits",
      "literal-punctuation",
      "no-punctuation"
    ],
    "name": "speak"
  },
  {
    "name": "speak-as"
  },
  {
    "name": "src"
  },
  {
    "keywords": [
      "currentcolor"
    ],
    "name": "stop-color"
  },
  {
    "name": "stop-opacity"
  },
  {
    "inherited": true,
    "name": "stroke"
  },
  {
    "inherited": true,
    "keywords": [
      "none"
    ],
    "name": "stroke-dasharray"
  },
  {
    "inherited": true,
    "name": "stroke-dashoffset"
  },
  {
    "inherited": true,
    "keywords": [
      "butt",
      "round",
      "square"
    ],
    "name": "stroke-linecap"
  },
  {
    "inherited": true,
    "keywords": [
      "miter",
      "bevel",
      "round"
    ],
    "name": "stroke-linejoin"
  },
  {
    "inherited": true,
    "name": "stroke-miterlimit"
  },
  {
    "inherited": true,
    "name": "stroke-opacity"
  },
  {
    "inherited": true,
    "name": "stroke-width"
  },
  {
    "name": "suffix"
  },
  {
    "name": "symbols"
  },
  {
    "name": "syntax"
  },
  {
    "name": "system"
  },
  {
    "inherited": true,
    "name": "tab-size"
  },
  {
    "keywords": [
      "auto",
      "fixed"
    ],
    "name": "table-layout"
  },
  {
    "inherited": true,
    "keywords": [
      "left",
      "right",
      "center",
      "justify",
      "-webkit-left",
      "-webkit-right",
      "-webkit-center",
      "start",
      "end"
    ],
    "name": "text-align"
  },
  {
    "inherited": true,
    "keywords": [
      "auto",
      "start",
      "end",
      "left",
      "right",
      "center",
      "justify"
    ],
    "name": "text-align-last"
  },
  {
    "inherited": true,
    "keywords": [
      "start",
      "middle",
      "end"
    ],
    "name": "text-anchor"
  },
  {
    "inherited": true,
    "keywords": [
      "normal",
      "no-autospace"
    ],
    "name": "text-autospace"
  },
  {
    "longhands": [
      "text-box-trim",
      "text-box-edge"
    ],
    "name": "text-box"
  },
  {
    "inherited": true,
    "name": "text-box-edge"
  },
  {
    "keywords": [
      "none",
      "trim-start",
      "trim-end",
      "trim-both"
    ],
    "name": "text-box-trim"
  },
  {
    "inherited": true,
    "keywords": [
      "none",
      "all"
    ],
    "name": "text-combine-upright"
  },
  {
    "longhands": [
      "text-decoration-line",
      "text-decoration-thickness",
      "text-decoration-style",
      "text-decoration-color"
    ],
    "name": "text-decoration"
  },
  {
    "keywords": [
      "currentcolor"
    ],
    "name": "text-decoration-color"
  },
  {
    "keywords": [
      "none",
      "underline",
      "overline",
      "line-through",
      "blink",
      "spelling-error",
      "grammar-error"
    ],
    "name": "text-decoration-line"
  },
  {
    "inherited": true,
    "keywords": [
      "none",
      "auto"
    ],
    "name": "text-decoration-skip-ink"
  },
  {
    "keywords": [
      "solid",
      "double",
      "dotted",
      "dashed",
      "wavy"
    ],
    "name": "text-decoration-style"
  },
  {
    "inherited": false,
    "keywords": [
      "auto",
      "from-font"
    ],
    "name": "text-decoration-thickness"
  },
  {
    "inherited": true,
    "longhands": [
      "text-emphasis-style",
      "text-emphasis-color"
    ],
    "name": "text-emphasis"
  },
  {
    "inherited": true,
    "keywords": [
      "currentcolor"
    ],
    "name": "text-emphasis-color"
  },
  {
    "inherited": true,
    "name": "text-emphasis-position"
  },
  {
    "inherited": true,
    "name": "text-emphasis-style"
  },
  {
    "inherited": true,
    "name": "text-indent"
  },
  {
    "inherited": true,
    "keywords": [
      "sideways",
      "mixed",
      "upright"
    ],
    "name": "text-orientation"
  },
  {
    "keywords": [
      "clip",
      "ellipsis"
    ],
    "name": "text-overflow"
  },
  {
    "inherited": true,
    "keywords": [
      "auto",
      "optimizespeed",
      "optimizelegibility",
      "geometricprecision"
    ],
    "name": "text-rendering"
  },
  {
    "inherited": true,
    "keywords": [
      "none"
    ],
    "name": "text-shadow"
  },
  {
    "inherited": true,
    "keywords": [
      "none",
      "auto"
    ],
    "name": "text-size-adjust"
  },
  {
    "inherited": true,
    "longhands": [
      "text-autospace",
      "text-spacing-trim"
    ],
    "name": "text-spacing"
  },
  {
    "inherited": true,
    "keywords": [
      "normal",
      "space-all",
      "space-first",
      "trim-start"
    ],
    "name": "text-spacing-trim"
  },
  {
    "inherited": true,
    "keywords": [
      "capitalize",
      "uppercase",
      "lowercase",
      "none",
      "math-auto"
    ],
    "name": "text-transform"
  },
  {
    "inherited": true,
    "keywords": [
      "auto"
    ],
    "name": "text-underline-offset"
  },
  {
    "inherited": true,
    "keywords": [
      "auto",
      "from-font",
      "under",
      "left",
      "right"
    ],
    "name": "text-underline-position"
  },
  {
    "inherited": true,
    "longhands": [
      "text-wrap-mode",
      "text-wrap-style"
    ],
    "name": "text-wrap"
  },
  {
    "inherited": true,
    "keywords": [
      "wrap",
      "nowrap"
    ],
    "name": "text-wrap-mode"
  },
  {
    "inherited": true,
    "keywords": [
      "auto",
      "balance",
      "pretty",
      "stable"
    ],
    "name": "text-wrap-style"
  },
  {
    "name": "timeline-scope"
  },
  {
    "keywords": [
      "auto"
    ],
    "name": "top"
  },
  {
    "keywords": [
      "auto",
      "none",
      "pan-x",
      "pan-left",
      "pan-right",
      "pan-y",
      "pan-up",
      "pan-down",
      "pinch-zoom",
      "manipulation"
    ],
    "name": "touch-action"
  },
  {
    "keywords": [
      "none"
    ],
    "name": "transform"
  },
  {
    "keywords": [
      "content-box",
      "border-box",
      "fill-box",
      "stroke-box",
      "view-box"
    ],
    "name": "transform-box"
  },
  {
    "name": "transform-origin"
  },
  {
    "keywords": [
      "flat",
      "preserve-3d"
    ],
    "name": "transform-style"
  },
  {
    "longhands": [
      "transition-property",
      "transition-duration",
      "transition-timing-function",
      "transition-delay",
      "transition-behavior"
    ],
    "name": "transition"
  },
  {
    "keywords": [
      "normal",
      "allow-discrete"
    ],
    "name": "transition-behavior"
  },
  {
    "name": "transition-delay"
  },
  {
    "name": "transition-duration"
  },
  {
    "keywords": [
      "none"
    ],
    "name": "transition-property"
  },
  {
    "keywords": [
      "linear",
      "ease",
      "ease-in",
      "ease-out",
      "ease-in-out",
      "jump-both",
      "jump-end",
      "jump-none",
      "jump-start",
      "step-start",
      "step-end"
    ],
    "name": "transition-timing-function"
  },
  {
    "name": "translate"
  },
  {
    "name": "types"
  },
  {
    "keywords": [
      "normal",
      "embed",
      "bidi-override",
      "isolate",
      "plaintext",
      "isolate-override"
    ],
    "name": "unicode-bidi"
  },
  {
    "name": "unicode-range"
  },
  {
    "inherited": true,
    "keywords": [
      "auto",
      "none",
      "text",
      "all",
      "contain"
    ],
    "name": "user-select"
  },
  {
    "keywords": [
      "none",
      "non-scaling-stroke"
    ],
    "name": "vector-effect"
  },
  {
    "keywords": [
      "baseline",
      "sub",
      "super",
      "text-top",
      "text-bottom",
      "middle"
    ],
    "name": "vertical-align"
  },
  {
    "longhands": [
      "view-timeline-name",
      "view-timeline-axis",
      "view-timeline-inset"
    ],
    "name": "view-timeline"
  },
  {
    "name": "view-timeline-axis"
  },
  {
    "name": "view-timeline-inset"
  },
  {
    "name": "view-timeline-name"
  },
  {
    "keywords": [
      "flat",
      "layered"
    ],
    "name": "view-transition-capture-mode"
  },
  {
    "keywords": [
      "none"
    ],
    "name": "view-transition-class"
  },
  {
    "keywords": [
      "normal",
      "contain",
      "nearest"
    ],
    "name": "view-transition-group"
  },
  {
    "keywords": [
      "none",
      "auto"
    ],
    "name": "view-transition-name"
  },
  {
    "inherited": true,
    "keywords": [
      "visible",
      "hidden",
      "collapse"
    ],
    "name": "visibility"
  },
  {
    "inherited": true,
    "longhands": [
      "white-space-collapse",
      "text-wrap-mode"
    ],
    "name": "white-space"
  },
  {
    "inherited": true,
    "keywords": [
      "collapse",
      "preserve",
      "preserve-breaks",
      "break-spaces"
    ],
    "name": "white-space-collapse"
  },
  {
    "inherited": true,
    "name": "widows"
  },
  {
    "keywords": [
      "auto",
      "fit-content",
      "min-content",
      "max-content"
    ],
    "name": "width"
  },
  {
    "keywords": [
      "auto"
    ],
    "name": "will-change"
  },
  {
    "inherited": true,
    "keywords": [
      "normal",
      "break-all",
      "keep-all",
      "break-word",
      "auto-phrase"
    ],
    "name": "word-break"
  },
  {
    "inherited": true,
    "keywords": [
      "normal"
    ],
    "name": "word-spacing"
  },
  {
    "inherited": true,
    "keywords": [
      "horizontal-tb",
      "vertical-rl",
      "vertical-lr",
      "sideways-rl",
      "sideways-lr"
    ],
    "name": "writing-mode"
  },
  {
    "name": "x"
  },
  {
    "name": "y"
  },
  {
    "keywords": [
      "auto"
    ],
    "name": "z-index"
  },
  {
    "name": "zoom"
  }
];
var generatedPropertyValues = {
  "-webkit-box-align": {
    "values": [
      "stretch",
      "start",
      "center",
      "end",
      "baseline"
    ]
  },
  "-webkit-box-decoration-break": {
    "values": [
      "slice",
      "clone"
    ]
  },
  "-webkit-box-direction": {
    "values": [
      "normal",
      "reverse"
    ]
  },
  "-webkit-box-orient": {
    "values": [
      "horizontal",
      "vertical"
    ]
  },
  "-webkit-box-pack": {
    "values": [
      "start",
      "center",
      "end",
      "justify"
    ]
  },
  "-webkit-line-break": {
    "values": [
      "auto",
      "loose",
      "normal",
      "strict",
      "after-white-space",
      "anywhere"
    ]
  },
  "-webkit-line-clamp": {
    "values": [
      "none"
    ]
  },
  "-webkit-print-color-adjust": {
    "values": [
      "economy",
      "exact"
    ]
  },
  "-webkit-rtl-ordering": {
    "values": [
      "logical",
      "visual"
    ]
  },
  "-webkit-text-security": {
    "values": [
      "none",
      "disc",
      "circle",
      "square"
    ]
  },
  "-webkit-user-drag": {
    "values": [
      "auto",
      "none",
      "element"
    ]
  },
  "-webkit-user-modify": {
    "values": [
      "read-only",
      "read-write",
      "read-write-plaintext-only"
    ]
  },
  "accent-color": {
    "values": [
      "auto",
      "currentcolor"
    ]
  },
  "alignment-baseline": {
    "values": [
      "auto",
      "baseline",
      "alphabetic",
      "ideographic",
      "middle",
      "central",
      "mathematical",
      "before-edge",
      "text-before-edge",
      "after-edge",
      "text-after-edge",
      "hanging"
    ]
  },
  "anchor-name": {
    "values": [
      "none"
    ]
  },
  "anchor-scope": {
    "values": [
      "none",
      "all"
    ]
  },
  "animation-composition": {
    "values": [
      "replace",
      "add",
      "accumulate"
    ]
  },
  "animation-direction": {
    "values": [
      "normal",
      "reverse",
      "alternate",
      "alternate-reverse"
    ]
  },
  "animation-fill-mode": {
    "values": [
      "none",
      "forwards",
      "backwards",
      "both"
    ]
  },
  "animation-iteration-count": {
    "values": [
      "infinite"
    ]
  },
  "animation-name": {
    "values": [
      "none"
    ]
  },
  "animation-play-state": {
    "values": [
      "running",
      "paused"
    ]
  },
  "animation-timeline": {
    "values": [
      "none",
      "auto"
    ]
  },
  "animation-timing-function": {
    "values": [
      "linear",
      "ease",
      "ease-in",
      "ease-out",
      "ease-in-out",
      "jump-both",
      "jump-end",
      "jump-none",
      "jump-start",
      "step-start",
      "step-end"
    ]
  },
  "app-region": {
    "values": [
      "none",
      "drag",
      "no-drag"
    ]
  },
  "aspect-ratio": {
    "values": [
      "auto"
    ]
  },
  "backdrop-filter": {
    "values": [
      "none"
    ]
  },
  "backface-visibility": {
    "values": [
      "visible",
      "hidden"
    ]
  },
  "background-attachment": {
    "values": [
      "scroll",
      "fixed",
      "local"
    ]
  },
  "background-blend-mode": {
    "values": [
      "normal",
      "multiply",
      "screen",
      "overlay",
      "darken",
      "lighten",
      "color-dodge",
      "color-burn",
      "hard-light",
      "soft-light",
      "difference",
      "exclusion",
      "hue",
      "saturation",
      "color",
      "luminosity"
    ]
  },
  "background-clip": {
    "values": [
      "border-box",
      "padding-box",
      "content-box",
      "text"
    ]
  },
  "background-color": {
    "values": [
      "currentcolor"
    ]
  },
  "background-image": {
    "values": [
      "auto",
      "none"
    ]
  },
  "background-origin": {
    "values": [
      "border-box",
      "padding-box",
      "content-box"
    ]
  },
  "background-size": {
    "values": [
      "auto",
      "cover",
      "contain"
    ]
  },
  "baseline-shift": {
    "values": [
      "baseline",
      "sub",
      "super"
    ]
  },
  "baseline-source": {
    "values": [
      "auto",
      "first",
      "last"
    ]
  },
  "block-size": {
    "values": [
      "auto"
    ]
  },
  "border-bottom-color": {
    "values": [
      "currentcolor"
    ]
  },
  "border-bottom-style": {
    "values": [
      "none",
      "hidden",
      "inset",
      "groove",
      "outset",
      "ridge",
      "dotted",
      "dashed",
      "solid",
      "double"
    ]
  },
  "border-bottom-width": {
    "values": [
      "thin",
      "medium",
      "thick"
    ]
  },
  "border-collapse": {
    "values": [
      "separate",
      "collapse"
    ]
  },
  "border-image-repeat": {
    "values": [
      "stretch",
      "repeat",
      "round",
      "space"
    ]
  },
  "border-image-source": {
    "values": [
      "none"
    ]
  },
  "border-image-width": {
    "values": [
      "auto"
    ]
  },
  "border-left-color": {
    "values": [
      "currentcolor"
    ]
  },
  "border-left-style": {
    "values": [
      "none",
      "hidden",
      "inset",
      "groove",
      "outset",
      "ridge",
      "dotted",
      "dashed",
      "solid",
      "double"
    ]
  },
  "border-left-width": {
    "values": [
      "thin",
      "medium",
      "thick"
    ]
  },
  "border-right-color": {
    "values": [
      "currentcolor"
    ]
  },
  "border-right-style": {
    "values": [
      "none",
      "hidden",
      "inset",
      "groove",
      "outset",
      "ridge",
      "dotted",
      "dashed",
      "solid",
      "double"
    ]
  },
  "border-right-width": {
    "values": [
      "thin",
      "medium",
      "thick"
    ]
  },
  "border-style": {
    "values": [
      "none"
    ]
  },
  "border-top-color": {
    "values": [
      "currentcolor"
    ]
  },
  "border-top-style": {
    "values": [
      "none",
      "hidden",
      "inset",
      "groove",
      "outset",
      "ridge",
      "dotted",
      "dashed",
      "solid",
      "double"
    ]
  },
  "border-top-width": {
    "values": [
      "thin",
      "medium",
      "thick"
    ]
  },
  "bottom": {
    "values": [
      "auto"
    ]
  },
  "box-decoration-break": {
    "values": [
      "slice",
      "clone"
    ]
  },
  "box-shadow": {
    "values": [
      "none"
    ]
  },
  "box-sizing": {
    "values": [
      "content-box",
      "border-box"
    ]
  },
  "break-after": {
    "values": [
      "auto",
      "avoid",
      "avoid-column",
      "avoid-page",
      "column",
      "left",
      "page",
      "recto",
      "right",
      "verso"
    ]
  },
  "break-before": {
    "values": [
      "auto",
      "avoid",
      "avoid-column",
      "avoid-page",
      "column",
      "left",
      "page",
      "recto",
      "right",
      "verso"
    ]
  },
  "break-inside": {
    "values": [
      "auto",
      "avoid",
      "avoid-column",
      "avoid-page"
    ]
  },
  "buffered-rendering": {
    "values": [
      "auto",
      "dynamic",
      "static"
    ]
  },
  "caption-side": {
    "values": [
      "top",
      "bottom"
    ]
  },
  "caret-animation": {
    "values": [
      "auto",
      "manual"
    ]
  },
  "caret-color": {
    "values": [
      "auto",
      "currentcolor"
    ]
  },
  "clear": {
    "values": [
      "none",
      "left",
      "right",
      "both",
      "inline-start",
      "inline-end"
    ]
  },
  "clip": {
    "values": [
      "auto"
    ]
  },
  "clip-path": {
    "values": [
      "border-box",
      "padding-box",
      "content-box",
      "margin-box",
      "fill-box",
      "stroke-box",
      "view-box",
      "none"
    ]
  },
  "clip-rule": {
    "values": [
      "nonzero",
      "evenodd"
    ]
  },
  "color": {
    "values": [
      "currentcolor"
    ]
  },
  "color-interpolation": {
    "values": [
      "auto",
      "srgb",
      "linearrgb"
    ]
  },
  "color-interpolation-filters": {
    "values": [
      "auto",
      "srgb",
      "linearrgb"
    ]
  },
  "color-rendering": {
    "values": [
      "auto",
      "optimizespeed",
      "optimizequality"
    ]
  },
  "column-count": {
    "values": [
      "auto"
    ]
  },
  "column-fill": {
    "values": [
      "balance",
      "auto"
    ]
  },
  "column-gap": {
    "values": [
      "normal"
    ]
  },
  "column-rule-color": {
    "values": [
      "currentcolor"
    ]
  },
  "column-rule-style": {
    "values": [
      "none",
      "hidden",
      "inset",
      "groove",
      "outset",
      "ridge",
      "dotted",
      "dashed",
      "solid",
      "double"
    ]
  },
  "column-rule-width": {
    "values": [
      "thin",
      "medium",
      "thick"
    ]
  },
  "column-span": {
    "values": [
      "none",
      "all"
    ]
  },
  "column-width": {
    "values": [
      "auto"
    ]
  },
  "contain": {
    "values": [
      "none",
      "strict",
      "content",
      "size",
      "layout",
      "style",
      "paint",
      "inline-size",
      "block-size"
    ]
  },
  "contain-intrinsic-height": {
    "values": [
      "none"
    ]
  },
  "contain-intrinsic-width": {
    "values": [
      "none"
    ]
  },
  "container-name": {
    "values": [
      "none"
    ]
  },
  "container-type": {
    "values": [
      "normal",
      "inline-size",
      "size",
      "scroll-state"
    ]
  },
  "content-visibility": {
    "values": [
      "visible",
      "auto",
      "hidden"
    ]
  },
  "counter-increment": {
    "values": [
      "none"
    ]
  },
  "counter-reset": {
    "values": [
      "none"
    ]
  },
  "counter-set": {
    "values": [
      "none"
    ]
  },
  "cursor": {
    "values": [
      "auto",
      "default",
      "none",
      "context-menu",
      "help",
      "pointer",
      "progress",
      "wait",
      "cell",
      "crosshair",
      "text",
      "vertical-text",
      "alias",
      "copy",
      "move",
      "no-drop",
      "not-allowed",
      "e-resize",
      "n-resize",
      "ne-resize",
      "nw-resize",
      "s-resize",
      "se-resize",
      "sw-resize",
      "w-resize",
      "ew-resize",
      "ns-resize",
      "nesw-resize",
      "nwse-resize",
      "col-resize",
      "row-resize",
      "all-scroll",
      "zoom-in",
      "zoom-out",
      "grab",
      "grabbing"
    ]
  },
  "d": {
    "values": [
      "none"
    ]
  },
  "direction": {
    "values": [
      "ltr",
      "rtl"
    ]
  },
  "display": {
    "values": [
      "inline",
      "block",
      "list-item",
      "inline-block",
      "table",
      "inline-table",
      "table-row-group",
      "table-header-group",
      "table-footer-group",
      "table-row",
      "table-column-group",
      "table-column",
      "table-cell",
      "table-caption",
      "-webkit-box",
      "-webkit-inline-box",
      "flex",
      "inline-flex",
      "grid",
      "inline-grid",
      "contents",
      "flow-root",
      "none",
      "flow",
      "math",
      "ruby",
      "ruby-text",
      "masonry",
      "inline-masonry"
    ]
  },
  "dominant-baseline": {
    "values": [
      "auto",
      "alphabetic",
      "ideographic",
      "middle",
      "central",
      "mathematical",
      "hanging",
      "use-script",
      "no-change",
      "reset-size",
      "text-after-edge",
      "text-before-edge"
    ]
  },
  "dynamic-range-limit": {
    "values": [
      "standard",
      "high",
      "constrained-high"
    ]
  },
  "empty-cells": {
    "values": [
      "show",
      "hide"
    ]
  },
  "field-sizing": {
    "values": [
      "fixed",
      "content"
    ]
  },
  "fill-rule": {
    "values": [
      "nonzero",
      "evenodd"
    ]
  },
  "filter": {
    "values": [
      "none"
    ]
  },
  "flex-basis": {
    "values": [
      "auto",
      "fit-content",
      "min-content",
      "max-content",
      "content"
    ]
  },
  "flex-direction": {
    "values": [
      "row",
      "row-reverse",
      "column",
      "column-reverse"
    ]
  },
  "flex-wrap": {
    "values": [
      "nowrap",
      "wrap",
      "wrap-reverse"
    ]
  },
  "float": {
    "values": [
      "none",
      "left",
      "right",
      "inline-start",
      "inline-end"
    ]
  },
  "flood-color": {
    "values": [
      "currentcolor"
    ]
  },
  "font-feature-settings": {
    "values": [
      "normal"
    ]
  },
  "font-kerning": {
    "values": [
      "auto",
      "normal",
      "none"
    ]
  },
  "font-optical-sizing": {
    "values": [
      "auto",
      "none"
    ]
  },
  "font-palette": {
    "values": [
      "normal",
      "light",
      "dark"
    ]
  },
  "font-size": {
    "values": [
      "xx-small",
      "x-small",
      "small",
      "medium",
      "large",
      "x-large",
      "xx-large",
      "xxx-large",
      "larger",
      "smaller",
      "-webkit-xxx-large"
    ]
  },
  "font-size-adjust": {
    "values": [
      "none",
      "ex-height",
      "cap-height",
      "ch-width",
      "ic-width",
      "ic-height",
      "from-font"
    ]
  },
  "font-stretch": {
    "values": [
      "normal",
      "ultra-condensed",
      "extra-condensed",
      "condensed",
      "semi-condensed",
      "semi-expanded",
      "expanded",
      "extra-expanded",
      "ultra-expanded"
    ]
  },
  "font-style": {
    "values": [
      "normal",
      "italic",
      "oblique"
    ]
  },
  "font-synthesis-small-caps": {
    "values": [
      "auto",
      "none"
    ]
  },
  "font-synthesis-style": {
    "values": [
      "auto",
      "none"
    ]
  },
  "font-synthesis-weight": {
    "values": [
      "auto",
      "none"
    ]
  },
  "font-variant-alternates": {
    "values": [
      "normal"
    ]
  },
  "font-variant-caps": {
    "values": [
      "normal",
      "small-caps",
      "all-small-caps",
      "petite-caps",
      "all-petite-caps",
      "unicase",
      "titling-caps"
    ]
  },
  "font-variant-east-asian": {
    "values": [
      "normal",
      "jis78",
      "jis83",
      "jis90",
      "jis04",
      "simplified",
      "traditional",
      "full-width",
      "proportional-width",
      "ruby"
    ]
  },
  "font-variant-emoji": {
    "values": [
      "normal",
      "text",
      "emoji",
      "unicode"
    ]
  },
  "font-variant-ligatures": {
    "values": [
      "normal",
      "none",
      "common-ligatures",
      "no-common-ligatures",
      "discretionary-ligatures",
      "no-discretionary-ligatures",
      "historical-ligatures",
      "no-historical-ligatures",
      "contextual",
      "no-contextual"
    ]
  },
  "font-variant-numeric": {
    "values": [
      "normal",
      "lining-nums",
      "oldstyle-nums",
      "proportional-nums",
      "tabular-nums",
      "diagonal-fractions",
      "stacked-fractions",
      "ordinal",
      "slashed-zero"
    ]
  },
  "font-variant-position": {
    "values": [
      "normal",
      "sub",
      "super"
    ]
  },
  "font-variation-settings": {
    "values": [
      "normal"
    ]
  },
  "font-weight": {
    "values": [
      "normal",
      "bold",
      "bolder",
      "lighter"
    ]
  },
  "forced-color-adjust": {
    "values": [
      "auto",
      "none",
      "preserve-parent-color"
    ]
  },
  "grid-auto-columns": {
    "values": [
      "auto",
      "min-content",
      "max-content"
    ]
  },
  "grid-auto-flow": {
    "values": [
      "row",
      "column"
    ]
  },
  "grid-auto-rows": {
    "values": [
      "auto",
      "min-content",
      "max-content"
    ]
  },
  "grid-column-end": {
    "values": [
      "auto"
    ]
  },
  "grid-column-start": {
    "values": [
      "auto"
    ]
  },
  "grid-row-end": {
    "values": [
      "auto"
    ]
  },
  "grid-row-start": {
    "values": [
      "auto"
    ]
  },
  "grid-template-areas": {
    "values": [
      "none"
    ]
  },
  "grid-template-columns": {
    "values": [
      "none"
    ]
  },
  "grid-template-rows": {
    "values": [
      "none"
    ]
  },
  "height": {
    "values": [
      "auto",
      "fit-content",
      "min-content",
      "max-content"
    ]
  },
  "hyphenate-limit-chars": {
    "values": [
      "auto"
    ]
  },
  "hyphens": {
    "values": [
      "none",
      "manual",
      "auto"
    ]
  },
  "image-rendering": {
    "values": [
      "auto",
      "optimizespeed",
      "optimizequality",
      "-webkit-optimize-contrast",
      "pixelated"
    ]
  },
  "initial-letter": {
    "values": [
      "drop",
      "normal",
      "raise"
    ]
  },
  "inline-size": {
    "values": [
      "auto"
    ]
  },
  "interactivity": {
    "values": [
      "auto",
      "inert"
    ]
  },
  "interpolate-size": {
    "values": [
      "numeric-only",
      "allow-keywords"
    ]
  },
  "isolation": {
    "values": [
      "auto",
      "isolate"
    ]
  },
  "left": {
    "values": [
      "auto"
    ]
  },
  "letter-spacing": {
    "values": [
      "normal"
    ]
  },
  "lighting-color": {
    "values": [
      "currentcolor"
    ]
  },
  "line-break": {
    "values": [
      "auto",
      "loose",
      "normal",
      "strict",
      "anywhere"
    ]
  },
  "line-clamp": {
    "values": [
      "none",
      "auto"
    ]
  },
  "line-height": {
    "values": [
      "normal"
    ]
  },
  "list-style-image": {
    "values": [
      "none"
    ]
  },
  "list-style-position": {
    "values": [
      "outside",
      "inside"
    ]
  },
  "list-style-type": {
    "values": [
      "disc",
      "circle",
      "square",
      "disclosure-open",
      "disclosure-closed",
      "decimal",
      "none"
    ]
  },
  "margin-block-end": {
    "values": [
      "auto"
    ]
  },
  "margin-block-start": {
    "values": [
      "auto"
    ]
  },
  "margin-bottom": {
    "values": [
      "auto"
    ]
  },
  "margin-inline-end": {
    "values": [
      "auto"
    ]
  },
  "margin-inline-start": {
    "values": [
      "auto"
    ]
  },
  "margin-left": {
    "values": [
      "auto"
    ]
  },
  "margin-right": {
    "values": [
      "auto"
    ]
  },
  "margin-top": {
    "values": [
      "auto"
    ]
  },
  "marker-end": {
    "values": [
      "none"
    ]
  },
  "marker-mid": {
    "values": [
      "none"
    ]
  },
  "marker-start": {
    "values": [
      "none"
    ]
  },
  "mask-type": {
    "values": [
      "luminance",
      "alpha"
    ]
  },
  "masonry-slack": {
    "values": [
      "normal"
    ]
  },
  "masonry-track-end": {
    "values": [
      "auto"
    ]
  },
  "masonry-track-start": {
    "values": [
      "auto"
    ]
  },
  "math-shift": {
    "values": [
      "normal",
      "compact"
    ]
  },
  "math-style": {
    "values": [
      "normal",
      "compact"
    ]
  },
  "max-block-size": {
    "values": [
      "none"
    ]
  },
  "max-height": {
    "values": [
      "none"
    ]
  },
  "max-inline-size": {
    "values": [
      "none"
    ]
  },
  "max-width": {
    "values": [
      "none"
    ]
  },
  "mix-blend-mode": {
    "values": [
      "normal",
      "multiply",
      "screen",
      "overlay",
      "darken",
      "lighten",
      "color-dodge",
      "color-burn",
      "hard-light",
      "soft-light",
      "difference",
      "exclusion",
      "hue",
      "saturation",
      "color",
      "luminosity",
      "plus-lighter"
    ]
  },
  "object-fit": {
    "values": [
      "fill",
      "contain",
      "cover",
      "none",
      "scale-down"
    ]
  },
  "object-view-box": {
    "values": [
      "none"
    ]
  },
  "offset-anchor": {
    "values": [
      "auto"
    ]
  },
  "offset-path": {
    "values": [
      "none"
    ]
  },
  "offset-position": {
    "values": [
      "auto",
      "normal"
    ]
  },
  "offset-rotate": {
    "values": [
      "auto",
      "reverse"
    ]
  },
  "origin-trial-test-property": {
    "values": [
      "normal",
      "none"
    ]
  },
  "outline-color": {
    "values": [
      "currentcolor"
    ]
  },
  "outline-style": {
    "values": [
      "none",
      "hidden",
      "inset",
      "groove",
      "outset",
      "ridge",
      "dotted",
      "dashed",
      "solid",
      "double"
    ]
  },
  "outline-width": {
    "values": [
      "thin",
      "medium",
      "thick"
    ]
  },
  "overflow-anchor": {
    "values": [
      "visible",
      "none",
      "auto"
    ]
  },
  "overflow-clip-margin": {
    "values": [
      "border-box",
      "content-box",
      "padding-box"
    ]
  },
  "overflow-wrap": {
    "values": [
      "normal",
      "break-word",
      "anywhere"
    ]
  },
  "overflow-x": {
    "values": [
      "visible",
      "hidden",
      "scroll",
      "auto",
      "overlay",
      "clip"
    ]
  },
  "overflow-y": {
    "values": [
      "visible",
      "hidden",
      "scroll",
      "auto",
      "overlay",
      "clip"
    ]
  },
  "overlay": {
    "values": [
      "none",
      "auto"
    ]
  },
  "overscroll-behavior-x": {
    "values": [
      "auto",
      "contain",
      "none"
    ]
  },
  "overscroll-behavior-y": {
    "values": [
      "auto",
      "contain",
      "none"
    ]
  },
  "page": {
    "values": [
      "auto"
    ]
  },
  "paint-order": {
    "values": [
      "normal",
      "fill",
      "stroke",
      "markers"
    ]
  },
  "perspective": {
    "values": [
      "none"
    ]
  },
  "pointer-events": {
    "values": [
      "none",
      "auto",
      "stroke",
      "fill",
      "painted",
      "visible",
      "visiblestroke",
      "visiblefill",
      "visiblepainted",
      "bounding-box",
      "all"
    ]
  },
  "position": {
    "values": [
      "static",
      "relative",
      "absolute",
      "fixed",
      "sticky"
    ]
  },
  "position-anchor": {
    "values": [
      "auto"
    ]
  },
  "position-area": {
    "values": [
      "none",
      "top",
      "bottom",
      "center",
      "left",
      "right",
      "x-start",
      "x-end",
      "y-start",
      "y-end",
      "start",
      "end",
      "self-start",
      "self-end",
      "all"
    ]
  },
  "position-try-fallbacks": {
    "values": [
      "none",
      "flip-block",
      "flip-inline",
      "flip-start"
    ]
  },
  "position-try-order": {
    "values": [
      "normal",
      "most-width",
      "most-height",
      "most-block-size",
      "most-inline-size"
    ]
  },
  "position-visibility": {
    "values": [
      "always",
      "anchors-visible",
      "no-overflow"
    ]
  },
  "quotes": {
    "values": [
      "auto",
      "none"
    ]
  },
  "reading-flow": {
    "values": [
      "normal",
      "flex-visual",
      "flex-flow",
      "grid-rows",
      "grid-columns",
      "grid-order"
    ]
  },
  "resize": {
    "values": [
      "none",
      "both",
      "horizontal",
      "vertical",
      "block",
      "inline"
    ]
  },
  "right": {
    "values": [
      "auto"
    ]
  },
  "row-gap": {
    "values": [
      "normal"
    ]
  },
  "ruby-align": {
    "values": [
      "space-around",
      "start",
      "center",
      "space-between"
    ]
  },
  "ruby-position": {
    "values": [
      "over",
      "under"
    ]
  },
  "rx": {
    "values": [
      "auto"
    ]
  },
  "ry": {
    "values": [
      "auto"
    ]
  },
  "scroll-behavior": {
    "values": [
      "auto",
      "smooth"
    ]
  },
  "scroll-marker-group": {
    "values": [
      "none",
      "after",
      "before"
    ]
  },
  "scroll-padding-block-end": {
    "values": [
      "auto"
    ]
  },
  "scroll-padding-block-start": {
    "values": [
      "auto"
    ]
  },
  "scroll-padding-bottom": {
    "values": [
      "auto"
    ]
  },
  "scroll-padding-inline-end": {
    "values": [
      "auto"
    ]
  },
  "scroll-padding-inline-start": {
    "values": [
      "auto"
    ]
  },
  "scroll-padding-left": {
    "values": [
      "auto"
    ]
  },
  "scroll-padding-right": {
    "values": [
      "auto"
    ]
  },
  "scroll-padding-top": {
    "values": [
      "auto"
    ]
  },
  "scroll-snap-align": {
    "values": [
      "none",
      "start",
      "end",
      "center"
    ]
  },
  "scroll-snap-stop": {
    "values": [
      "normal",
      "always"
    ]
  },
  "scroll-snap-type": {
    "values": [
      "none",
      "x",
      "y",
      "block",
      "inline",
      "both",
      "mandatory",
      "proximity"
    ]
  },
  "scroll-start-target": {
    "values": [
      "none",
      "auto"
    ]
  },
  "scrollbar-color": {
    "values": [
      "auto"
    ]
  },
  "scrollbar-gutter": {
    "values": [
      "auto",
      "stable",
      "both-edges"
    ]
  },
  "scrollbar-width": {
    "values": [
      "auto",
      "thin",
      "none"
    ]
  },
  "shape-margin": {
    "values": [
      "none"
    ]
  },
  "shape-outside": {
    "values": [
      "none"
    ]
  },
  "shape-rendering": {
    "values": [
      "auto",
      "optimizespeed",
      "crispedges",
      "geometricprecision"
    ]
  },
  "speak": {
    "values": [
      "none",
      "normal",
      "spell-out",
      "digits",
      "literal-punctuation",
      "no-punctuation"
    ]
  },
  "stop-color": {
    "values": [
      "currentcolor"
    ]
  },
  "stroke-dasharray": {
    "values": [
      "none"
    ]
  },
  "stroke-linecap": {
    "values": [
      "butt",
      "round",
      "square"
    ]
  },
  "stroke-linejoin": {
    "values": [
      "miter",
      "bevel",
      "round"
    ]
  },
  "table-layout": {
    "values": [
      "auto",
      "fixed"
    ]
  },
  "text-align": {
    "values": [
      "left",
      "right",
      "center",
      "justify",
      "-webkit-left",
      "-webkit-right",
      "-webkit-center",
      "start",
      "end"
    ]
  },
  "text-align-last": {
    "values": [
      "auto",
      "start",
      "end",
      "left",
      "right",
      "center",
      "justify"
    ]
  },
  "text-anchor": {
    "values": [
      "start",
      "middle",
      "end"
    ]
  },
  "text-autospace": {
    "values": [
      "normal",
      "no-autospace"
    ]
  },
  "text-box-trim": {
    "values": [
      "none",
      "trim-start",
      "trim-end",
      "trim-both"
    ]
  },
  "text-combine-upright": {
    "values": [
      "none",
      "all"
    ]
  },
  "text-decoration-color": {
    "values": [
      "currentcolor"
    ]
  },
  "text-decoration-line": {
    "values": [
      "none",
      "underline",
      "overline",
      "line-through",
      "blink",
      "spelling-error",
      "grammar-error"
    ]
  },
  "text-decoration-skip-ink": {
    "values": [
      "none",
      "auto"
    ]
  },
  "text-decoration-style": {
    "values": [
      "solid",
      "double",
      "dotted",
      "dashed",
      "wavy"
    ]
  },
  "text-decoration-thickness": {
    "values": [
      "auto",
      "from-font"
    ]
  },
  "text-emphasis-color": {
    "values": [
      "currentcolor"
    ]
  },
  "text-orientation": {
    "values": [
      "sideways",
      "mixed",
      "upright"
    ]
  },
  "text-overflow": {
    "values": [
      "clip",
      "ellipsis"
    ]
  },
  "text-rendering": {
    "values": [
      "auto",
      "optimizespeed",
      "optimizelegibility",
      "geometricprecision"
    ]
  },
  "text-shadow": {
    "values": [
      "none"
    ]
  },
  "text-size-adjust": {
    "values": [
      "none",
      "auto"
    ]
  },
  "text-spacing-trim": {
    "values": [
      "normal",
      "space-all",
      "space-first",
      "trim-start"
    ]
  },
  "text-transform": {
    "values": [
      "capitalize",
      "uppercase",
      "lowercase",
      "none",
      "math-auto"
    ]
  },
  "text-underline-offset": {
    "values": [
      "auto"
    ]
  },
  "text-underline-position": {
    "values": [
      "auto",
      "from-font",
      "under",
      "left",
      "right"
    ]
  },
  "text-wrap-mode": {
    "values": [
      "wrap",
      "nowrap"
    ]
  },
  "text-wrap-style": {
    "values": [
      "auto",
      "balance",
      "pretty",
      "stable"
    ]
  },
  "top": {
    "values": [
      "auto"
    ]
  },
  "touch-action": {
    "values": [
      "auto",
      "none",
      "pan-x",
      "pan-left",
      "pan-right",
      "pan-y",
      "pan-up",
      "pan-down",
      "pinch-zoom",
      "manipulation"
    ]
  },
  "transform": {
    "values": [
      "none"
    ]
  },
  "transform-box": {
    "values": [
      "content-box",
      "border-box",
      "fill-box",
      "stroke-box",
      "view-box"
    ]
  },
  "transform-style": {
    "values": [
      "flat",
      "preserve-3d"
    ]
  },
  "transition-behavior": {
    "values": [
      "normal",
      "allow-discrete"
    ]
  },
  "transition-property": {
    "values": [
      "none"
    ]
  },
  "transition-timing-function": {
    "values": [
      "linear",
      "ease",
      "ease-in",
      "ease-out",
      "ease-in-out",
      "jump-both",
      "jump-end",
      "jump-none",
      "jump-start",
      "step-start",
      "step-end"
    ]
  },
  "unicode-bidi": {
    "values": [
      "normal",
      "embed",
      "bidi-override",
      "isolate",
      "plaintext",
      "isolate-override"
    ]
  },
  "user-select": {
    "values": [
      "auto",
      "none",
      "text",
      "all",
      "contain"
    ]
  },
  "vector-effect": {
    "values": [
      "none",
      "non-scaling-stroke"
    ]
  },
  "vertical-align": {
    "values": [
      "baseline",
      "sub",
      "super",
      "text-top",
      "text-bottom",
      "middle"
    ]
  },
  "view-transition-capture-mode": {
    "values": [
      "flat",
      "layered"
    ]
  },
  "view-transition-class": {
    "values": [
      "none"
    ]
  },
  "view-transition-group": {
    "values": [
      "normal",
      "contain",
      "nearest"
    ]
  },
  "view-transition-name": {
    "values": [
      "none",
      "auto"
    ]
  },
  "visibility": {
    "values": [
      "visible",
      "hidden",
      "collapse"
    ]
  },
  "white-space-collapse": {
    "values": [
      "collapse",
      "preserve",
      "preserve-breaks",
      "break-spaces"
    ]
  },
  "width": {
    "values": [
      "auto",
      "fit-content",
      "min-content",
      "max-content"
    ]
  },
  "will-change": {
    "values": [
      "auto"
    ]
  },
  "word-break": {
    "values": [
      "normal",
      "break-all",
      "keep-all",
      "break-word",
      "auto-phrase"
    ]
  },
  "word-spacing": {
    "values": [
      "normal"
    ]
  },
  "writing-mode": {
    "values": [
      "horizontal-tb",
      "vertical-rl",
      "vertical-lr",
      "sideways-rl",
      "sideways-lr"
    ]
  },
  "z-index": {
    "values": [
      "auto"
    ]
  }
};
var generatedAliasesFor = /* @__PURE__ */ new Map([
  [
    "-epub-caption-side",
    "caption-side"
  ],
  [
    "-epub-text-combine",
    "-webkit-text-combine"
  ],
  [
    "-epub-text-emphasis",
    "text-emphasis"
  ],
  [
    "-epub-text-emphasis-color",
    "text-emphasis-color"
  ],
  [
    "-epub-text-emphasis-style",
    "text-emphasis-style"
  ],
  [
    "-epub-text-orientation",
    "-webkit-text-orientation"
  ],
  [
    "-epub-text-transform",
    "text-transform"
  ],
  [
    "-epub-word-break",
    "word-break"
  ],
  [
    "-epub-writing-mode",
    "-webkit-writing-mode"
  ],
  [
    "-webkit-align-content",
    "align-content"
  ],
  [
    "-webkit-align-items",
    "align-items"
  ],
  [
    "-webkit-align-self",
    "align-self"
  ],
  [
    "-webkit-alternative-animation-with-timeline",
    "-alternative-animation-with-timeline"
  ],
  [
    "-webkit-animation",
    "animation"
  ],
  [
    "-webkit-animation-delay",
    "animation-delay"
  ],
  [
    "-webkit-animation-direction",
    "animation-direction"
  ],
  [
    "-webkit-animation-duration",
    "animation-duration"
  ],
  [
    "-webkit-animation-fill-mode",
    "animation-fill-mode"
  ],
  [
    "-webkit-animation-iteration-count",
    "animation-iteration-count"
  ],
  [
    "-webkit-animation-name",
    "animation-name"
  ],
  [
    "-webkit-animation-play-state",
    "animation-play-state"
  ],
  [
    "-webkit-animation-timing-function",
    "animation-timing-function"
  ],
  [
    "-webkit-app-region",
    "app-region"
  ],
  [
    "-webkit-appearance",
    "appearance"
  ],
  [
    "-webkit-backface-visibility",
    "backface-visibility"
  ],
  [
    "-webkit-background-clip",
    "background-clip"
  ],
  [
    "-webkit-background-origin",
    "background-origin"
  ],
  [
    "-webkit-background-size",
    "background-size"
  ],
  [
    "-webkit-border-after",
    "border-block-end"
  ],
  [
    "-webkit-border-after-color",
    "border-block-end-color"
  ],
  [
    "-webkit-border-after-style",
    "border-block-end-style"
  ],
  [
    "-webkit-border-after-width",
    "border-block-end-width"
  ],
  [
    "-webkit-border-before",
    "border-block-start"
  ],
  [
    "-webkit-border-before-color",
    "border-block-start-color"
  ],
  [
    "-webkit-border-before-style",
    "border-block-start-style"
  ],
  [
    "-webkit-border-before-width",
    "border-block-start-width"
  ],
  [
    "-webkit-border-bottom-left-radius",
    "border-bottom-left-radius"
  ],
  [
    "-webkit-border-bottom-right-radius",
    "border-bottom-right-radius"
  ],
  [
    "-webkit-border-end",
    "border-inline-end"
  ],
  [
    "-webkit-border-end-color",
    "border-inline-end-color"
  ],
  [
    "-webkit-border-end-style",
    "border-inline-end-style"
  ],
  [
    "-webkit-border-end-width",
    "border-inline-end-width"
  ],
  [
    "-webkit-border-radius",
    "border-radius"
  ],
  [
    "-webkit-border-start",
    "border-inline-start"
  ],
  [
    "-webkit-border-start-color",
    "border-inline-start-color"
  ],
  [
    "-webkit-border-start-style",
    "border-inline-start-style"
  ],
  [
    "-webkit-border-start-width",
    "border-inline-start-width"
  ],
  [
    "-webkit-border-top-left-radius",
    "border-top-left-radius"
  ],
  [
    "-webkit-border-top-right-radius",
    "border-top-right-radius"
  ],
  [
    "-webkit-box-shadow",
    "box-shadow"
  ],
  [
    "-webkit-box-sizing",
    "box-sizing"
  ],
  [
    "-webkit-clip-path",
    "clip-path"
  ],
  [
    "-webkit-column-count",
    "column-count"
  ],
  [
    "-webkit-column-gap",
    "column-gap"
  ],
  [
    "-webkit-column-rule",
    "column-rule"
  ],
  [
    "-webkit-column-rule-color",
    "column-rule-color"
  ],
  [
    "-webkit-column-rule-style",
    "column-rule-style"
  ],
  [
    "-webkit-column-rule-width",
    "column-rule-width"
  ],
  [
    "-webkit-column-span",
    "column-span"
  ],
  [
    "-webkit-column-width",
    "column-width"
  ],
  [
    "-webkit-columns",
    "columns"
  ],
  [
    "-webkit-filter",
    "filter"
  ],
  [
    "-webkit-flex",
    "flex"
  ],
  [
    "-webkit-flex-basis",
    "flex-basis"
  ],
  [
    "-webkit-flex-direction",
    "flex-direction"
  ],
  [
    "-webkit-flex-flow",
    "flex-flow"
  ],
  [
    "-webkit-flex-grow",
    "flex-grow"
  ],
  [
    "-webkit-flex-shrink",
    "flex-shrink"
  ],
  [
    "-webkit-flex-wrap",
    "flex-wrap"
  ],
  [
    "-webkit-font-feature-settings",
    "font-feature-settings"
  ],
  [
    "-webkit-hyphenate-character",
    "hyphenate-character"
  ],
  [
    "-webkit-justify-content",
    "justify-content"
  ],
  [
    "-webkit-logical-height",
    "block-size"
  ],
  [
    "-webkit-logical-width",
    "inline-size"
  ],
  [
    "-webkit-margin-after",
    "margin-block-end"
  ],
  [
    "-webkit-margin-before",
    "margin-block-start"
  ],
  [
    "-webkit-margin-end",
    "margin-inline-end"
  ],
  [
    "-webkit-margin-start",
    "margin-inline-start"
  ],
  [
    "-webkit-mask",
    "mask"
  ],
  [
    "-webkit-mask-clip",
    "mask-clip"
  ],
  [
    "-webkit-mask-composite",
    "mask-composite"
  ],
  [
    "-webkit-mask-image",
    "mask-image"
  ],
  [
    "-webkit-mask-origin",
    "mask-origin"
  ],
  [
    "-webkit-mask-position",
    "mask-position"
  ],
  [
    "-webkit-mask-repeat",
    "mask-repeat"
  ],
  [
    "-webkit-mask-size",
    "mask-size"
  ],
  [
    "-webkit-max-logical-height",
    "max-block-size"
  ],
  [
    "-webkit-max-logical-width",
    "max-inline-size"
  ],
  [
    "-webkit-min-logical-height",
    "min-block-size"
  ],
  [
    "-webkit-min-logical-width",
    "min-inline-size"
  ],
  [
    "-webkit-opacity",
    "opacity"
  ],
  [
    "-webkit-order",
    "order"
  ],
  [
    "-webkit-padding-after",
    "padding-block-end"
  ],
  [
    "-webkit-padding-before",
    "padding-block-start"
  ],
  [
    "-webkit-padding-end",
    "padding-inline-end"
  ],
  [
    "-webkit-padding-start",
    "padding-inline-start"
  ],
  [
    "-webkit-perspective",
    "perspective"
  ],
  [
    "-webkit-perspective-origin",
    "perspective-origin"
  ],
  [
    "-webkit-shape-image-threshold",
    "shape-image-threshold"
  ],
  [
    "-webkit-shape-margin",
    "shape-margin"
  ],
  [
    "-webkit-shape-outside",
    "shape-outside"
  ],
  [
    "-webkit-text-emphasis",
    "text-emphasis"
  ],
  [
    "-webkit-text-emphasis-color",
    "text-emphasis-color"
  ],
  [
    "-webkit-text-emphasis-position",
    "text-emphasis-position"
  ],
  [
    "-webkit-text-emphasis-style",
    "text-emphasis-style"
  ],
  [
    "-webkit-text-size-adjust",
    "text-size-adjust"
  ],
  [
    "-webkit-transform",
    "transform"
  ],
  [
    "-webkit-transform-origin",
    "transform-origin"
  ],
  [
    "-webkit-transform-style",
    "transform-style"
  ],
  [
    "-webkit-transition",
    "transition"
  ],
  [
    "-webkit-transition-delay",
    "transition-delay"
  ],
  [
    "-webkit-transition-duration",
    "transition-duration"
  ],
  [
    "-webkit-transition-property",
    "transition-property"
  ],
  [
    "-webkit-transition-timing-function",
    "transition-timing-function"
  ],
  [
    "-webkit-user-select",
    "user-select"
  ],
  [
    "grid-column-gap",
    "column-gap"
  ],
  [
    "grid-gap",
    "gap"
  ],
  [
    "grid-row-gap",
    "row-gap"
  ],
  [
    "word-wrap",
    "overflow-wrap"
  ]
]);

// gen/front_end/core/sdk/CSSMetadata.js
import * as Common2 from "./../common/common.js";
var CSSMetadata = class _CSSMetadata {
  #values;
  #longhands;
  #shorthands;
  #inherited;
  #svgProperties;
  #propertyValues;
  #aliasesFor;
  #valuesSet;
  #nameValuePresetsInternal;
  #nameValuePresetsIncludingSVG;
  constructor(properties, aliasesFor) {
    this.#values = [];
    this.#longhands = /* @__PURE__ */ new Map();
    this.#shorthands = /* @__PURE__ */ new Map();
    this.#inherited = /* @__PURE__ */ new Set();
    this.#svgProperties = /* @__PURE__ */ new Set();
    this.#propertyValues = /* @__PURE__ */ new Map();
    this.#aliasesFor = aliasesFor;
    for (let i = 0; i < properties.length; ++i) {
      const property = properties[i];
      const propertyName = property.name;
      if (!CSS.supports(propertyName, "initial")) {
        continue;
      }
      this.#values.push(propertyName);
      if (property.inherited) {
        this.#inherited.add(propertyName);
      }
      if (property.svg) {
        this.#svgProperties.add(propertyName);
      }
      const longhands = properties[i].longhands;
      if (longhands) {
        this.#longhands.set(propertyName, longhands);
        for (let j = 0; j < longhands.length; ++j) {
          const longhandName = longhands[j];
          let shorthands = this.#shorthands.get(longhandName);
          if (!shorthands) {
            shorthands = [];
            this.#shorthands.set(longhandName, shorthands);
          }
          shorthands.push(propertyName);
        }
      }
    }
    this.#values.sort(_CSSMetadata.sortPrefixesAndCSSWideKeywordsToEnd);
    this.#valuesSet = new Set(this.#values);
    const propertyValueSets = /* @__PURE__ */ new Map();
    for (const [propertyName, basisValueObj] of Object.entries(generatedPropertyValues)) {
      propertyValueSets.set(propertyName, new Set(basisValueObj.values));
    }
    for (const [propertyName, extraValues] of extraPropertyValues) {
      const propertyValueSet = propertyValueSets.get(propertyName);
      if (propertyValueSet) {
        propertyValueSets.set(propertyName, propertyValueSet.union(extraValues));
      } else {
        propertyValueSets.set(propertyName, extraValues);
      }
    }
    for (const [propertyName, values] of propertyValueSets) {
      for (const commonKeyword of CommonKeywords) {
        if (!values.has(commonKeyword) && CSS.supports(propertyName, commonKeyword)) {
          values.add(commonKeyword);
        }
      }
      this.#propertyValues.set(propertyName, [...values]);
    }
    this.#nameValuePresetsInternal = [];
    this.#nameValuePresetsIncludingSVG = [];
    for (const name of this.#valuesSet) {
      const values = this.specificPropertyValues(name).filter((value) => CSS.supports(name, value)).sort(_CSSMetadata.sortPrefixesAndCSSWideKeywordsToEnd);
      const presets = values.map((value) => `${name}: ${value}`);
      if (!this.isSVGProperty(name)) {
        this.#nameValuePresetsInternal.push(...presets);
      }
      this.#nameValuePresetsIncludingSVG.push(...presets);
    }
  }
  static isCSSWideKeyword(a) {
    return CSSWideKeywords.includes(a);
  }
  static isPositionTryOrderKeyword(a) {
    return PositionTryOrderKeywords.includes(a);
  }
  static sortPrefixesAndCSSWideKeywordsToEnd(a, b) {
    const aIsCSSWideKeyword = _CSSMetadata.isCSSWideKeyword(a);
    const bIsCSSWideKeyword = _CSSMetadata.isCSSWideKeyword(b);
    if (aIsCSSWideKeyword && !bIsCSSWideKeyword) {
      return 1;
    }
    if (!aIsCSSWideKeyword && bIsCSSWideKeyword) {
      return -1;
    }
    const aIsPrefixed = a.startsWith("-webkit-");
    const bIsPrefixed = b.startsWith("-webkit-");
    if (aIsPrefixed && !bIsPrefixed) {
      return 1;
    }
    if (!aIsPrefixed && bIsPrefixed) {
      return -1;
    }
    return a < b ? -1 : a > b ? 1 : 0;
  }
  allProperties() {
    return this.#values;
  }
  aliasesFor() {
    return this.#aliasesFor;
  }
  nameValuePresets(includeSVG) {
    return includeSVG ? this.#nameValuePresetsIncludingSVG : this.#nameValuePresetsInternal;
  }
  isSVGProperty(name) {
    name = name.toLowerCase();
    return this.#svgProperties.has(name);
  }
  getLonghands(shorthand) {
    return this.#longhands.get(shorthand) || null;
  }
  getShorthands(longhand) {
    return this.#shorthands.get(longhand) || null;
  }
  isColorAwareProperty(propertyName) {
    return colorAwareProperties.has(propertyName.toLowerCase()) || this.isCustomProperty(propertyName.toLowerCase());
  }
  isFontFamilyProperty(propertyName) {
    return propertyName.toLowerCase() === "font-family";
  }
  isAngleAwareProperty(propertyName) {
    const lowerCasedName = propertyName.toLowerCase();
    return colorAwareProperties.has(lowerCasedName) || angleAwareProperties.has(lowerCasedName);
  }
  isGridAreaDefiningProperty(propertyName) {
    propertyName = propertyName.toLowerCase();
    return propertyName === "grid" || propertyName === "grid-template" || propertyName === "grid-template-areas";
  }
  isGridColumnNameAwareProperty(propertyName) {
    propertyName = propertyName.toLowerCase();
    return ["grid-column", "grid-column-start", "grid-column-end"].includes(propertyName);
  }
  isGridRowNameAwareProperty(propertyName) {
    propertyName = propertyName.toLowerCase();
    return ["grid-row", "grid-row-start", "grid-row-end"].includes(propertyName);
  }
  isGridAreaNameAwareProperty(propertyName) {
    propertyName = propertyName.toLowerCase();
    return propertyName === "grid-area";
  }
  isGridNameAwareProperty(propertyName) {
    return this.isGridAreaNameAwareProperty(propertyName) || this.isGridColumnNameAwareProperty(propertyName) || this.isGridRowNameAwareProperty(propertyName);
  }
  isLengthProperty(propertyName) {
    propertyName = propertyName.toLowerCase();
    if (propertyName === "line-height") {
      return false;
    }
    return distanceProperties.has(propertyName) || propertyName.startsWith("margin") || propertyName.startsWith("padding") || propertyName.indexOf("width") !== -1 || propertyName.indexOf("height") !== -1;
  }
  isBezierAwareProperty(propertyName) {
    propertyName = propertyName.toLowerCase();
    return bezierAwareProperties.has(propertyName) || this.isCustomProperty(propertyName);
  }
  isFontAwareProperty(propertyName) {
    propertyName = propertyName.toLowerCase();
    return fontAwareProperties.has(propertyName) || this.isCustomProperty(propertyName);
  }
  isCustomProperty(propertyName) {
    return propertyName.startsWith("--");
  }
  isShadowProperty(propertyName) {
    propertyName = propertyName.toLowerCase();
    return propertyName === "box-shadow" || propertyName === "text-shadow" || propertyName === "-webkit-box-shadow";
  }
  isStringProperty(propertyName) {
    propertyName = propertyName.toLowerCase();
    return propertyName === "content";
  }
  canonicalPropertyName(name) {
    if (this.isCustomProperty(name)) {
      return name;
    }
    name = name.toLowerCase();
    const aliasFor = this.#aliasesFor.get(name);
    if (aliasFor) {
      return aliasFor;
    }
    if (!name || name.length < 9 || name.charAt(0) !== "-") {
      return name;
    }
    const match = name.match(/(?:-webkit-)(.+)/);
    if (!match || !this.#valuesSet.has(match[1])) {
      return name;
    }
    return match[1];
  }
  isCSSPropertyName(propertyName) {
    propertyName = propertyName.toLowerCase();
    if (propertyName.startsWith("--") && propertyName.length > 2 || propertyName.startsWith("-moz-") || propertyName.startsWith("-ms-") || propertyName.startsWith("-o-") || propertyName.startsWith("-webkit-")) {
      return true;
    }
    return this.#valuesSet.has(propertyName);
  }
  isPropertyInherited(propertyName) {
    propertyName = propertyName.toLowerCase();
    return propertyName.startsWith("--") || this.#inherited.has(this.canonicalPropertyName(propertyName)) || this.#inherited.has(propertyName);
  }
  specificPropertyValues(propertyName) {
    const unprefixedName = propertyName.replace(/^-webkit-/, "");
    const propertyValues = this.#propertyValues;
    let keywords = propertyValues.get(propertyName) || propertyValues.get(unprefixedName);
    if (!keywords) {
      keywords = [];
      for (const commonKeyword of CommonKeywords) {
        if (CSS.supports(propertyName, commonKeyword)) {
          keywords.push(commonKeyword);
        }
      }
      propertyValues.set(propertyName, keywords);
    }
    return keywords;
  }
  getPropertyValues(propertyName) {
    propertyName = propertyName.toLowerCase();
    const acceptedKeywords = [...this.specificPropertyValues(propertyName), ...CSSWideKeywords];
    if (this.isColorAwareProperty(propertyName)) {
      acceptedKeywords.push("currentColor");
      for (const color of Common2.Color.Nicknames.keys()) {
        acceptedKeywords.push(color);
      }
    }
    return acceptedKeywords.sort(_CSSMetadata.sortPrefixesAndCSSWideKeywordsToEnd);
  }
  propertyUsageWeight(property) {
    return Weight.get(property) || Weight.get(this.canonicalPropertyName(property)) || 0;
  }
  getValuePreset(key, value) {
    const values = valuePresets.get(key);
    let text = values ? values.get(value) : null;
    if (!text) {
      return null;
    }
    let startColumn = text.length;
    let endColumn = text.length;
    if (text) {
      startColumn = text.indexOf("|");
      endColumn = text.lastIndexOf("|");
      endColumn = startColumn === endColumn ? endColumn : endColumn - 1;
      text = text.replace(/\|/g, "");
    }
    return { text, startColumn, endColumn };
  }
  isHighlightPseudoType(pseudoType) {
    return pseudoType === DOM.PseudoType.Highlight || pseudoType === DOM.PseudoType.Selection || pseudoType === DOM.PseudoType.TargetText || pseudoType === DOM.PseudoType.GrammarError || pseudoType === DOM.PseudoType.SpellingError;
  }
};
var CSSWideKeyword = /* @__PURE__ */ ((CSSWideKeyword2) => {
  CSSWideKeyword2["INHERIT"] = "inherit";
  CSSWideKeyword2["INITIAL"] = "initial";
  CSSWideKeyword2["REVERT"] = "revert";
  CSSWideKeyword2["REVERT_LAYER"] = "revert-layer";
  CSSWideKeyword2["UNSET"] = "unset";
  return CSSWideKeyword2;
})(CSSWideKeyword || {});
var CSSWideKeywords = [
  "inherit",
  "initial",
  "revert",
  "revert-layer",
  "unset"
  /* UNSET */
];
var PositionTryOrderKeyword = /* @__PURE__ */ ((PositionTryOrderKeyword2) => {
  PositionTryOrderKeyword2["NORMAL"] = "normal";
  PositionTryOrderKeyword2["MOST_HEIGHT"] = "most-height";
  PositionTryOrderKeyword2["MOST_WIDTH"] = "most-width";
  PositionTryOrderKeyword2["MOST_BLOCK_SIZE"] = "most-block-size";
  PositionTryOrderKeyword2["MOST_INLINE_SIZE"] = "most-inline-size";
  return PositionTryOrderKeyword2;
})(PositionTryOrderKeyword || {});
var PositionTryOrderKeywords = [
  "normal",
  "most-height",
  "most-width",
  "most-block-size",
  "most-inline-size"
  /* MOST_INLINE_SIZE */
];
var VariableNameRegex = /(\s*--.*?)/gs;
var VariableRegex = /(var\(\s*--.*?\))/gs;
var CustomVariableRegex = /(var\(*--[\w\d]+-([\w]+-[\w]+)\))/g;
var URLRegex = /url\(\s*('.+?'|".+?"|[^)]+)\s*\)/g;
var GridAreaRowRegex = /((?:\[[\w\- ]+\]\s*)*(?:"[^"]+"|'[^']+'))[^'"\[]*\[?[^'"\[]*/;
var cssMetadataInstance = null;
function cssMetadata() {
  if (!cssMetadataInstance) {
    const supportedProperties = generatedProperties;
    cssMetadataInstance = new CSSMetadata(supportedProperties, generatedAliasesFor);
  }
  return cssMetadataInstance;
}
var imageValuePresetMap = /* @__PURE__ */ new Map([
  ["linear-gradient", "linear-gradient(|45deg, black, transparent|)"],
  ["radial-gradient", "radial-gradient(|black, transparent|)"],
  ["repeating-linear-gradient", "repeating-linear-gradient(|45deg, black, transparent 100px|)"],
  ["repeating-radial-gradient", "repeating-radial-gradient(|black, transparent 100px|)"],
  ["url", "url(||)"]
]);
var filterValuePresetMap = /* @__PURE__ */ new Map([
  ["blur", "blur(|1px|)"],
  ["brightness", "brightness(|0.5|)"],
  ["contrast", "contrast(|0.5|)"],
  ["drop-shadow", "drop-shadow(|2px 4px 6px black|)"],
  ["grayscale", "grayscale(|1|)"],
  ["hue-rotate", "hue-rotate(|45deg|)"],
  ["invert", "invert(|1|)"],
  ["opacity", "opacity(|0.5|)"],
  ["saturate", "saturate(|0.5|)"],
  ["sepia", "sepia(|1|)"],
  ["url", "url(||)"]
]);
var valuePresets = /* @__PURE__ */ new Map([
  ["filter", filterValuePresetMap],
  ["backdrop-filter", filterValuePresetMap],
  ["background", imageValuePresetMap],
  ["background-image", imageValuePresetMap],
  ["-webkit-mask-image", imageValuePresetMap],
  [
    "transform",
    /* @__PURE__ */ new Map([
      ["scale", "scale(|1.5|)"],
      ["scaleX", "scaleX(|1.5|)"],
      ["scaleY", "scaleY(|1.5|)"],
      ["scale3d", "scale3d(|1.5, 1.5, 1.5|)"],
      ["rotate", "rotate(|45deg|)"],
      ["rotateX", "rotateX(|45deg|)"],
      ["rotateY", "rotateY(|45deg|)"],
      ["rotateZ", "rotateZ(|45deg|)"],
      ["rotate3d", "rotate3d(|1, 1, 1, 45deg|)"],
      ["skew", "skew(|10deg, 10deg|)"],
      ["skewX", "skewX(|10deg|)"],
      ["skewY", "skewY(|10deg|)"],
      ["translate", "translate(|10px, 10px|)"],
      ["translateX", "translateX(|10px|)"],
      ["translateY", "translateY(|10px|)"],
      ["translateZ", "translateZ(|10px|)"],
      ["translate3d", "translate3d(|10px, 10px, 10px|)"],
      ["matrix", "matrix(|1, 0, 0, 1, 0, 0|)"],
      ["matrix3d", "matrix3d(|1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1|)"],
      ["perspective", "perspective(|10px|)"]
    ])
  ]
]);
var distanceProperties = /* @__PURE__ */ new Set([
  "background-position",
  "border-spacing",
  "bottom",
  "font-size",
  "height",
  "left",
  "letter-spacing",
  "max-height",
  "max-width",
  "min-height",
  "min-width",
  "right",
  "text-indent",
  "top",
  "width",
  "word-spacing",
  "grid-row-gap",
  "grid-column-gap",
  "row-gap"
]);
var bezierAwareProperties = /* @__PURE__ */ new Set([
  "animation",
  "animation-timing-function",
  "transition",
  "transition-timing-function",
  "-webkit-animation",
  "-webkit-animation-timing-function",
  "-webkit-transition",
  "-webkit-transition-timing-function"
]);
var fontAwareProperties = /* @__PURE__ */ new Set(["font-size", "line-height", "font-weight", "font-family", "letter-spacing"]);
var colorAwareProperties = /* @__PURE__ */ new Set([
  "accent-color",
  "background",
  "background-color",
  "background-image",
  "border",
  "border-color",
  "border-image",
  "border-image-source",
  "border-bottom",
  "border-bottom-color",
  "border-left",
  "border-left-color",
  "border-right",
  "border-right-color",
  "border-top",
  "border-top-color",
  "border-block-end",
  "border-block-end-color",
  "border-block-start",
  "border-block-start-color",
  "border-inline-end",
  "border-inline-end-color",
  "border-inline-start",
  "border-inline-start-color",
  "box-shadow",
  "caret-color",
  "color",
  "column-rule",
  "column-rule-color",
  "content",
  "fill",
  "list-style-image",
  "mask",
  "mask-image",
  "mask-border",
  "mask-border-source",
  "outline",
  "outline-color",
  "scrollbar-color",
  "stop-color",
  "stroke",
  "text-decoration-color",
  "text-shadow",
  "text-emphasis",
  "text-emphasis-color",
  "-webkit-border-after",
  "-webkit-border-after-color",
  "-webkit-border-before",
  "-webkit-border-before-color",
  "-webkit-border-end",
  "-webkit-border-end-color",
  "-webkit-border-start",
  "-webkit-border-start-color",
  "-webkit-box-reflect",
  "-webkit-box-shadow",
  "-webkit-column-rule-color",
  "-webkit-mask",
  "-webkit-mask-box-image",
  "-webkit-mask-box-image-source",
  "-webkit-mask-image",
  "-webkit-tap-highlight-color",
  "-webkit-text-emphasis",
  "-webkit-text-emphasis-color",
  "-webkit-text-fill-color",
  "-webkit-text-stroke",
  "-webkit-text-stroke-color"
]);
var angleAwareProperties = /* @__PURE__ */ new Set([
  "-webkit-border-image",
  "transform",
  "-webkit-transform",
  "rotate",
  "filter",
  "-webkit-filter",
  "backdrop-filter",
  "offset",
  "offset-rotate",
  "font-style"
]);
var textEmphasisPosition = /* @__PURE__ */ new Set([
  "over",
  "under",
  "over right",
  // Initial value
  "over left",
  "under right",
  "under left"
]);
var textEmphasisStyle = /* @__PURE__ */ new Set([
  "none",
  "dot",
  "circle",
  "double-circle",
  "triangle",
  "sesame",
  "filled",
  "open",
  "dot open",
  "circle open",
  "double-circle open",
  "triangle open",
  "sesame open",
  '"\u2764\uFE0F"'
  // <string>
]);
var extraPropertyValues = /* @__PURE__ */ new Map([
  ["background-repeat", /* @__PURE__ */ new Set(["repeat", "repeat-x", "repeat-y", "no-repeat", "space", "round"])],
  ["content", /* @__PURE__ */ new Set(["normal", "close-quote", "no-close-quote", "no-open-quote", "open-quote"])],
  ["baseline-shift", /* @__PURE__ */ new Set(["baseline"])],
  ["max-height", /* @__PURE__ */ new Set(["min-content", "max-content", "-webkit-fill-available", "fit-content"])],
  ["color", /* @__PURE__ */ new Set(["black"])],
  ["background-color", /* @__PURE__ */ new Set(["white"])],
  ["box-shadow", /* @__PURE__ */ new Set(["inset"])],
  ["text-shadow", /* @__PURE__ */ new Set(["0 0 black"])],
  ["-webkit-writing-mode", /* @__PURE__ */ new Set(["horizontal-tb", "vertical-rl", "vertical-lr"])],
  ["writing-mode", /* @__PURE__ */ new Set(["lr", "rl", "tb", "lr-tb", "rl-tb", "tb-rl"])],
  ["page-break-inside", /* @__PURE__ */ new Set(["avoid"])],
  ["cursor", /* @__PURE__ */ new Set(["-webkit-zoom-in", "-webkit-zoom-out", "-webkit-grab", "-webkit-grabbing"])],
  ["border-width", /* @__PURE__ */ new Set(["medium", "thick", "thin"])],
  ["border-style", /* @__PURE__ */ new Set(["hidden", "inset", "groove", "ridge", "outset", "dotted", "dashed", "solid", "double"])],
  ["size", /* @__PURE__ */ new Set(["a3", "a4", "a5", "b4", "b5", "landscape", "ledger", "legal", "letter", "portrait"])],
  ["overflow", /* @__PURE__ */ new Set(["hidden", "visible", "overlay", "scroll"])],
  ["overscroll-behavior", /* @__PURE__ */ new Set(["contain"])],
  ["text-rendering", /* @__PURE__ */ new Set(["optimizeSpeed", "optimizeLegibility", "geometricPrecision"])],
  ["text-align", /* @__PURE__ */ new Set(["-webkit-auto", "-webkit-match-parent"])],
  ["clip-path", /* @__PURE__ */ new Set(["circle", "ellipse", "inset", "polygon", "url"])],
  ["color-interpolation", /* @__PURE__ */ new Set(["sRGB", "linearRGB"])],
  ["word-wrap", /* @__PURE__ */ new Set(["normal", "break-word"])],
  ["font-weight", /* @__PURE__ */ new Set(["100", "200", "300", "400", "500", "600", "700", "800", "900"])],
  ["text-emphasis", textEmphasisStyle],
  ["-webkit-text-emphasis", textEmphasisStyle],
  ["color-rendering", /* @__PURE__ */ new Set(["optimizeSpeed", "optimizeQuality"])],
  ["-webkit-text-combine", /* @__PURE__ */ new Set(["horizontal"])],
  ["text-orientation", /* @__PURE__ */ new Set(["sideways-right"])],
  [
    "outline",
    /* @__PURE__ */ new Set(["inset", "groove", "ridge", "outset", "dotted", "dashed", "solid", "double", "medium", "thick", "thin"])
  ],
  [
    "font",
    /* @__PURE__ */ new Set([
      "caption",
      "icon",
      "menu",
      "message-box",
      "small-caption",
      "-webkit-mini-control",
      "-webkit-small-control",
      "-webkit-control",
      "status-bar"
    ])
  ],
  ["dominant-baseline", /* @__PURE__ */ new Set(["text-before-edge", "text-after-edge", "use-script", "no-change", "reset-size"])],
  ["text-emphasis-position", textEmphasisPosition],
  ["-webkit-text-emphasis-position", textEmphasisPosition],
  ["alignment-baseline", /* @__PURE__ */ new Set(["before-edge", "after-edge", "text-before-edge", "text-after-edge", "hanging"])],
  ["page-break-before", /* @__PURE__ */ new Set(["left", "right", "always", "avoid"])],
  ["border-image", /* @__PURE__ */ new Set(["repeat", "stretch", "space", "round"])],
  [
    "text-decoration",
    /* @__PURE__ */ new Set(["blink", "line-through", "overline", "underline", "wavy", "double", "solid", "dashed", "dotted"])
  ],
  // List taken from https://drafts.csswg.org/css-fonts-4/#generic-font-families
  [
    "font-family",
    /* @__PURE__ */ new Set([
      "serif",
      "sans-serif",
      "cursive",
      "fantasy",
      "monospace",
      "system-ui",
      "emoji",
      "math",
      "fangsong",
      "ui-serif",
      "ui-sans-serif",
      "ui-monospace",
      "ui-rounded",
      "-webkit-body"
    ])
  ],
  ["zoom", /* @__PURE__ */ new Set(["normal"])],
  ["max-width", /* @__PURE__ */ new Set(["min-content", "max-content", "-webkit-fill-available", "fit-content"])],
  ["-webkit-font-smoothing", /* @__PURE__ */ new Set(["antialiased", "subpixel-antialiased"])],
  [
    "border",
    /* @__PURE__ */ new Set([
      "hidden",
      "inset",
      "groove",
      "ridge",
      "outset",
      "dotted",
      "dashed",
      "solid",
      "double",
      "medium",
      "thick",
      "thin"
    ])
  ],
  [
    "font-variant",
    /* @__PURE__ */ new Set([
      "small-caps",
      "normal",
      "common-ligatures",
      "no-common-ligatures",
      "discretionary-ligatures",
      "no-discretionary-ligatures",
      "historical-ligatures",
      "no-historical-ligatures",
      "contextual",
      "no-contextual",
      "all-small-caps",
      "petite-caps",
      "all-petite-caps",
      "unicase",
      "titling-caps",
      "lining-nums",
      "oldstyle-nums",
      "proportional-nums",
      "tabular-nums",
      "diagonal-fractions",
      "stacked-fractions",
      "ordinal",
      "slashed-zero",
      "jis78",
      "jis83",
      "jis90",
      "jis04",
      "simplified",
      "traditional",
      "full-width",
      "proportional-width",
      "ruby"
    ])
  ],
  ["vertical-align", /* @__PURE__ */ new Set(["top", "bottom", "-webkit-baseline-middle"])],
  ["page-break-after", /* @__PURE__ */ new Set(["left", "right", "always", "avoid"])],
  ["text-emphasis-style", textEmphasisStyle],
  ["-webkit-text-emphasis-style", textEmphasisStyle],
  [
    "transform",
    /* @__PURE__ */ new Set([
      "scale",
      "scaleX",
      "scaleY",
      "scale3d",
      "rotate",
      "rotateX",
      "rotateY",
      "rotateZ",
      "rotate3d",
      "skew",
      "skewX",
      "skewY",
      "translate",
      "translateX",
      "translateY",
      "translateZ",
      "translate3d",
      "matrix",
      "matrix3d",
      "perspective"
    ])
  ],
  [
    "align-content",
    /* @__PURE__ */ new Set([
      "normal",
      "baseline",
      "space-between",
      "space-around",
      "space-evenly",
      "stretch",
      "center",
      "start",
      "end",
      "flex-start",
      "flex-end"
    ])
  ],
  [
    "justify-content",
    /* @__PURE__ */ new Set([
      "normal",
      "space-between",
      "space-around",
      "space-evenly",
      "stretch",
      "center",
      "start",
      "end",
      "flex-start",
      "flex-end",
      "left",
      "right"
    ])
  ],
  [
    "place-content",
    /* @__PURE__ */ new Set([
      "normal",
      "space-between",
      "space-around",
      "space-evenly",
      "stretch",
      "center",
      "start",
      "end",
      "flex-start",
      "flex-end",
      "baseline"
    ])
  ],
  [
    "align-items",
    /* @__PURE__ */ new Set([
      "normal",
      "stretch",
      "baseline",
      "center",
      "start",
      "end",
      "self-start",
      "self-end",
      "flex-start",
      "flex-end",
      "anchor-center"
    ])
  ],
  [
    "justify-items",
    /* @__PURE__ */ new Set([
      "normal",
      "stretch",
      "baseline",
      "center",
      "start",
      "end",
      "self-start",
      "self-end",
      "flex-start",
      "flex-end",
      "left",
      "right",
      "legacy",
      "anchor-center"
    ])
  ],
  [
    "place-items",
    /* @__PURE__ */ new Set([
      "normal",
      "stretch",
      "baseline",
      "center",
      "start",
      "end",
      "self-start",
      "self-end",
      "flex-start",
      "flex-end",
      "anchor-center"
    ])
  ],
  [
    "align-self",
    /* @__PURE__ */ new Set([
      "normal",
      "stretch",
      "baseline",
      "center",
      "start",
      "end",
      "self-start",
      "self-end",
      "flex-start",
      "flex-end",
      "anchor-center"
    ])
  ],
  [
    "justify-self",
    /* @__PURE__ */ new Set([
      "normal",
      "stretch",
      "baseline",
      "center",
      "start",
      "end",
      "self-start",
      "self-end",
      "flex-start",
      "flex-end",
      "left",
      "right",
      "anchor-center"
    ])
  ],
  [
    "place-self",
    /* @__PURE__ */ new Set([
      "normal",
      "stretch",
      "baseline",
      "center",
      "start",
      "end",
      "self-start",
      "self-end",
      "flex-start",
      "flex-end",
      "anchor-center"
    ])
  ],
  ["perspective-origin", /* @__PURE__ */ new Set(["left", "center", "right", "top", "bottom"])],
  ["transform-origin", /* @__PURE__ */ new Set(["left", "center", "right", "top", "bottom"])],
  ["transition-timing-function", /* @__PURE__ */ new Set(["cubic-bezier", "steps"])],
  ["animation-timing-function", /* @__PURE__ */ new Set(["cubic-bezier", "steps"])],
  ["-webkit-backface-visibility", /* @__PURE__ */ new Set(["visible", "hidden"])],
  ["-webkit-column-break-after", /* @__PURE__ */ new Set(["always", "avoid"])],
  ["-webkit-column-break-before", /* @__PURE__ */ new Set(["always", "avoid"])],
  ["-webkit-column-break-inside", /* @__PURE__ */ new Set(["avoid"])],
  ["-webkit-column-span", /* @__PURE__ */ new Set(["all"])],
  ["-webkit-column-gap", /* @__PURE__ */ new Set(["normal"])],
  [
    "filter",
    /* @__PURE__ */ new Set([
      "url",
      "blur",
      "brightness",
      "contrast",
      "drop-shadow",
      "grayscale",
      "hue-rotate",
      "invert",
      "opacity",
      "saturate",
      "sepia"
    ])
  ],
  [
    "backdrop-filter",
    /* @__PURE__ */ new Set([
      "url",
      "blur",
      "brightness",
      "contrast",
      "drop-shadow",
      "grayscale",
      "hue-rotate",
      "invert",
      "opacity",
      "saturate",
      "sepia"
    ])
  ],
  ["grid-template-columns", /* @__PURE__ */ new Set(["min-content", "max-content"])],
  ["grid-template-rows", /* @__PURE__ */ new Set(["min-content", "max-content"])],
  ["grid-auto-flow", /* @__PURE__ */ new Set(["dense"])],
  [
    "background",
    /* @__PURE__ */ new Set([
      "repeat",
      "repeat-x",
      "repeat-y",
      "no-repeat",
      "top",
      "bottom",
      "left",
      "right",
      "center",
      "fixed",
      "local",
      "scroll",
      "space",
      "round",
      "border-box",
      "content-box",
      "padding-box",
      "linear-gradient",
      "radial-gradient",
      "repeating-linear-gradient",
      "repeating-radial-gradient",
      "url"
    ])
  ],
  [
    "background-image",
    /* @__PURE__ */ new Set(["linear-gradient", "radial-gradient", "repeating-linear-gradient", "repeating-radial-gradient", "url"])
  ],
  ["background-position", /* @__PURE__ */ new Set(["top", "bottom", "left", "right", "center"])],
  ["background-position-x", /* @__PURE__ */ new Set(["left", "right", "center"])],
  ["background-position-y", /* @__PURE__ */ new Set(["top", "bottom", "center"])],
  ["background-repeat-x", /* @__PURE__ */ new Set(["repeat", "no-repeat"])],
  ["background-repeat-y", /* @__PURE__ */ new Set(["repeat", "no-repeat"])],
  [
    "border-bottom",
    /* @__PURE__ */ new Set([
      "hidden",
      "inset",
      "groove",
      "outset",
      "ridge",
      "dotted",
      "dashed",
      "solid",
      "double",
      "medium",
      "thick",
      "thin"
    ])
  ],
  [
    "border-left",
    /* @__PURE__ */ new Set([
      "hidden",
      "inset",
      "groove",
      "outset",
      "ridge",
      "dotted",
      "dashed",
      "solid",
      "double",
      "medium",
      "thick",
      "thin"
    ])
  ],
  [
    "border-right",
    /* @__PURE__ */ new Set([
      "hidden",
      "inset",
      "groove",
      "outset",
      "ridge",
      "dotted",
      "dashed",
      "solid",
      "double",
      "medium",
      "thick",
      "thin"
    ])
  ],
  [
    "border-top",
    /* @__PURE__ */ new Set([
      "hidden",
      "inset",
      "groove",
      "outset",
      "ridge",
      "dotted",
      "dashed",
      "solid",
      "double",
      "medium",
      "thick",
      "thin"
    ])
  ],
  ["buffered-rendering", /* @__PURE__ */ new Set(["static", "dynamic"])],
  ["color-interpolation-filters", /* @__PURE__ */ new Set(["srgb", "linearrgb"])],
  [
    "column-rule",
    /* @__PURE__ */ new Set([
      "hidden",
      "inset",
      "groove",
      "outset",
      "ridge",
      "dotted",
      "dashed",
      "solid",
      "double",
      "medium",
      "thick",
      "thin"
    ])
  ],
  ["flex-flow", /* @__PURE__ */ new Set(["nowrap", "row", "row-reverse", "column", "column-reverse", "wrap", "wrap-reverse"])],
  ["height", /* @__PURE__ */ new Set(["-webkit-fill-available"])],
  ["inline-size", /* @__PURE__ */ new Set(["-webkit-fill-available", "min-content", "max-content", "fit-content"])],
  [
    "list-style",
    /* @__PURE__ */ new Set([
      "outside",
      "inside",
      "disc",
      "circle",
      "square",
      "decimal",
      "decimal-leading-zero",
      "arabic-indic",
      "bengali",
      "cambodian",
      "khmer",
      "devanagari",
      "gujarati",
      "gurmukhi",
      "kannada",
      "lao",
      "malayalam",
      "mongolian",
      "myanmar",
      "oriya",
      "persian",
      "urdu",
      "telugu",
      "tibetan",
      "thai",
      "lower-roman",
      "upper-roman",
      "lower-greek",
      "lower-alpha",
      "lower-latin",
      "upper-alpha",
      "upper-latin",
      "cjk-earthly-branch",
      "cjk-heavenly-stem",
      "ethiopic-halehame",
      "ethiopic-halehame-am",
      "ethiopic-halehame-ti-er",
      "ethiopic-halehame-ti-et",
      "hangul",
      "hangul-consonant",
      "korean-hangul-formal",
      "korean-hanja-formal",
      "korean-hanja-informal",
      "hebrew",
      "armenian",
      "lower-armenian",
      "upper-armenian",
      "georgian",
      "cjk-ideographic",
      "simp-chinese-formal",
      "simp-chinese-informal",
      "trad-chinese-formal",
      "trad-chinese-informal",
      "hiragana",
      "katakana",
      "hiragana-iroha",
      "katakana-iroha"
    ])
  ],
  ["max-block-size", /* @__PURE__ */ new Set(["-webkit-fill-available", "min-content", "max-content", "fit-content"])],
  ["max-inline-size", /* @__PURE__ */ new Set(["-webkit-fill-available", "min-content", "max-content", "fit-content"])],
  ["min-block-size", /* @__PURE__ */ new Set(["-webkit-fill-available", "min-content", "max-content", "fit-content"])],
  ["min-height", /* @__PURE__ */ new Set(["-webkit-fill-available", "min-content", "max-content", "fit-content"])],
  ["min-inline-size", /* @__PURE__ */ new Set(["-webkit-fill-available", "min-content", "max-content", "fit-content"])],
  ["min-width", /* @__PURE__ */ new Set(["-webkit-fill-available", "min-content", "max-content", "fit-content"])],
  ["object-position", /* @__PURE__ */ new Set(["top", "bottom", "left", "right", "center"])],
  ["shape-outside", /* @__PURE__ */ new Set(["border-box", "content-box", "padding-box", "margin-box"])],
  [
    "-webkit-appearance",
    /* @__PURE__ */ new Set([
      "checkbox",
      "radio",
      "push-button",
      "square-button",
      "button",
      "inner-spin-button",
      "listbox",
      "media-slider",
      "media-sliderthumb",
      "media-volume-slider",
      "media-volume-sliderthumb",
      "menulist",
      "menulist-button",
      "meter",
      "progress-bar",
      "slider-horizontal",
      "slider-vertical",
      "sliderthumb-horizontal",
      "sliderthumb-vertical",
      "searchfield",
      "searchfield-cancel-button",
      "textfield",
      "textarea"
    ])
  ],
  [
    "-webkit-border-after",
    /* @__PURE__ */ new Set([
      "hidden",
      "inset",
      "groove",
      "outset",
      "ridge",
      "dotted",
      "dashed",
      "solid",
      "double",
      "medium",
      "thick",
      "thin"
    ])
  ],
  [
    "-webkit-border-after-style",
    /* @__PURE__ */ new Set(["hidden", "inset", "groove", "outset", "ridge", "dotted", "dashed", "solid", "double"])
  ],
  ["-webkit-border-after-width", /* @__PURE__ */ new Set(["medium", "thick", "thin"])],
  [
    "-webkit-border-before",
    /* @__PURE__ */ new Set([
      "hidden",
      "inset",
      "groove",
      "outset",
      "ridge",
      "dotted",
      "dashed",
      "solid",
      "double",
      "medium",
      "thick",
      "thin"
    ])
  ],
  [
    "-webkit-border-before-style",
    /* @__PURE__ */ new Set(["hidden", "inset", "groove", "outset", "ridge", "dotted", "dashed", "solid", "double"])
  ],
  ["-webkit-border-before-width", /* @__PURE__ */ new Set(["medium", "thick", "thin"])],
  [
    "-webkit-border-end",
    /* @__PURE__ */ new Set([
      "hidden",
      "inset",
      "groove",
      "outset",
      "ridge",
      "dotted",
      "dashed",
      "solid",
      "double",
      "medium",
      "thick",
      "thin"
    ])
  ],
  [
    "-webkit-border-end-style",
    /* @__PURE__ */ new Set(["hidden", "inset", "groove", "outset", "ridge", "dotted", "dashed", "solid", "double"])
  ],
  ["-webkit-border-end-width", /* @__PURE__ */ new Set(["medium", "thick", "thin"])],
  [
    "-webkit-border-start",
    /* @__PURE__ */ new Set([
      "hidden",
      "inset",
      "groove",
      "outset",
      "ridge",
      "dotted",
      "dashed",
      "solid",
      "double",
      "medium",
      "thick",
      "thin"
    ])
  ],
  [
    "-webkit-border-start-style",
    /* @__PURE__ */ new Set(["hidden", "inset", "groove", "outset", "ridge", "dotted", "dashed", "solid", "double"])
  ],
  ["-webkit-border-start-width", /* @__PURE__ */ new Set(["medium", "thick", "thin"])],
  ["-webkit-logical-height", /* @__PURE__ */ new Set(["-webkit-fill-available", "min-content", "max-content", "fit-content"])],
  ["-webkit-logical-width", /* @__PURE__ */ new Set(["-webkit-fill-available", "min-content", "max-content", "fit-content"])],
  ["-webkit-mask-box-image", /* @__PURE__ */ new Set(["repeat", "stretch", "space", "round"])],
  ["-webkit-mask-box-image-repeat", /* @__PURE__ */ new Set(["repeat", "stretch", "space", "round"])],
  ["-webkit-mask-clip", /* @__PURE__ */ new Set(["text", "border", "border-box", "content", "content-box", "padding", "padding-box"])],
  [
    "-webkit-mask-composite",
    /* @__PURE__ */ new Set([
      "clear",
      "copy",
      "source-over",
      "source-in",
      "source-out",
      "source-atop",
      "destination-over",
      "destination-in",
      "destination-out",
      "destination-atop",
      "xor",
      "plus-lighter"
    ])
  ],
  [
    "-webkit-mask-image",
    /* @__PURE__ */ new Set(["linear-gradient", "radial-gradient", "repeating-linear-gradient", "repeating-radial-gradient", "url"])
  ],
  ["-webkit-mask-origin", /* @__PURE__ */ new Set(["border", "border-box", "content", "content-box", "padding", "padding-box"])],
  ["-webkit-mask-position", /* @__PURE__ */ new Set(["top", "bottom", "left", "right", "center"])],
  ["-webkit-mask-position-x", /* @__PURE__ */ new Set(["left", "right", "center"])],
  ["-webkit-mask-position-y", /* @__PURE__ */ new Set(["top", "bottom", "center"])],
  ["-webkit-mask-repeat", /* @__PURE__ */ new Set(["repeat", "repeat-x", "repeat-y", "no-repeat", "space", "round"])],
  ["-webkit-mask-size", /* @__PURE__ */ new Set(["contain", "cover"])],
  ["-webkit-max-logical-height", /* @__PURE__ */ new Set(["-webkit-fill-available", "min-content", "max-content", "fit-content"])],
  ["-webkit-max-logical-width", /* @__PURE__ */ new Set(["-webkit-fill-available", "min-content", "max-content", "fit-content"])],
  ["-webkit-min-logical-height", /* @__PURE__ */ new Set(["-webkit-fill-available", "min-content", "max-content", "fit-content"])],
  ["-webkit-min-logical-width", /* @__PURE__ */ new Set(["-webkit-fill-available", "min-content", "max-content", "fit-content"])],
  ["-webkit-perspective-origin-x", /* @__PURE__ */ new Set(["left", "right", "center"])],
  ["-webkit-perspective-origin-y", /* @__PURE__ */ new Set(["top", "bottom", "center"])],
  ["-webkit-text-decorations-in-effect", /* @__PURE__ */ new Set(["blink", "line-through", "overline", "underline"])],
  ["-webkit-text-stroke", /* @__PURE__ */ new Set(["medium", "thick", "thin"])],
  ["-webkit-text-stroke-width", /* @__PURE__ */ new Set(["medium", "thick", "thin"])],
  ["-webkit-transform-origin-x", /* @__PURE__ */ new Set(["left", "right", "center"])],
  ["-webkit-transform-origin-y", /* @__PURE__ */ new Set(["top", "bottom", "center"])],
  ["width", /* @__PURE__ */ new Set(["-webkit-fill-available"])],
  ["contain-intrinsic-width", /* @__PURE__ */ new Set(["auto none", "auto 100px"])],
  ["contain-intrinsic-height", /* @__PURE__ */ new Set(["auto none", "auto 100px"])],
  ["contain-intrinsic-size", /* @__PURE__ */ new Set(["auto none", "auto 100px"])],
  ["contain-intrinsic-inline-size", /* @__PURE__ */ new Set(["auto none", "auto 100px"])],
  ["contain-intrinsic-block-size", /* @__PURE__ */ new Set(["auto none", "auto 100px"])],
  // Due to some compatibility issues[1] with Chrome's implementation[2],
  // only a few legacy values are added here.
  // [1]: https://github.com/w3c/csswg-drafts/issues/9102#issuecomment-1807453214
  // [2]: https://chromium-review.googlesource.com/c/chromium/src/+/4232738
  [
    "white-space",
    /* @__PURE__ */ new Set([
      "normal",
      // equal to: `collapse wrap`
      "pre",
      // equal to: `preserve nowrap`
      "pre-wrap",
      // equal to: `preserve wrap`
      "pre-line",
      // equal to: `preserve-breaks wrap`
      "nowrap",
      // equal to: `collapse nowrap`
      "break-spaces"
      // equal to: `break-spaces wrap`, Chrome 76, crbug.com/767634#c28
    ])
  ],
  // https://drafts.csswg.org/css-inline-3/#text-box-edge
  // Now we're going to allow the following rule:
  // auto | [ text | cap | ex ] [ text | alphabetic ]?
  // ideographic and ideographic-ink are not implemented yet.
  // We don't add values like `cap text` because that is equivalent to `text`.
  [
    "text-box-edge",
    /* @__PURE__ */ new Set([
      "auto",
      "text",
      "cap",
      "ex",
      "text alphabetic",
      "cap alphabetic",
      "ex alphabetic"
    ])
  ]
]);
var Weight = /* @__PURE__ */ new Map([
  ["align-content", 57],
  ["align-items", 129],
  ["align-self", 55],
  ["animation", 175],
  ["animation-delay", 114],
  ["animation-direction", 113],
  ["animation-duration", 137],
  ["animation-fill-mode", 132],
  ["animation-iteration-count", 124],
  ["animation-name", 139],
  ["animation-play-state", 104],
  ["animation-timing-function", 141],
  ["backface-visibility", 123],
  ["background", 260],
  ["background-attachment", 119],
  ["background-clip", 165],
  ["background-color", 259],
  ["background-image", 246],
  ["background-origin", 107],
  ["background-position", 237],
  ["background-position-x", 108],
  ["background-position-y", 93],
  ["background-repeat", 234],
  ["background-size", 203],
  ["border", 263],
  ["border-bottom", 233],
  ["border-bottom-color", 190],
  ["border-bottom-left-radius", 186],
  ["border-bottom-right-radius", 185],
  ["border-bottom-style", 150],
  ["border-bottom-width", 179],
  ["border-collapse", 209],
  ["border-color", 226],
  ["border-image", 89],
  ["border-image-outset", 50],
  ["border-image-repeat", 49],
  ["border-image-slice", 58],
  ["border-image-source", 32],
  ["border-image-width", 52],
  ["border-left", 221],
  ["border-left-color", 174],
  ["border-left-style", 142],
  ["border-left-width", 172],
  ["border-radius", 224],
  ["border-right", 223],
  ["border-right-color", 182],
  ["border-right-style", 130],
  ["border-right-width", 178],
  ["border-spacing", 198],
  ["border-style", 206],
  ["border-top", 231],
  ["border-top-color", 192],
  ["border-top-left-radius", 187],
  ["border-top-right-radius", 189],
  ["border-top-style", 152],
  ["border-top-width", 180],
  ["border-width", 214],
  ["bottom", 227],
  ["box-shadow", 213],
  ["box-sizing", 216],
  ["caption-side", 96],
  ["clear", 229],
  ["clip", 173],
  ["clip-rule", 5],
  ["color", 256],
  ["content", 219],
  ["counter-increment", 111],
  ["counter-reset", 110],
  ["cursor", 250],
  ["direction", 176],
  ["display", 262],
  ["empty-cells", 99],
  ["fill", 140],
  ["fill-opacity", 82],
  ["fill-rule", 22],
  ["filter", 160],
  ["flex", 133],
  ["flex-basis", 66],
  ["flex-direction", 85],
  ["flex-flow", 94],
  ["flex-grow", 112],
  ["flex-shrink", 61],
  ["flex-wrap", 68],
  ["float", 252],
  ["font", 211],
  ["font-family", 254],
  ["font-kerning", 18],
  ["font-size", 264],
  ["font-stretch", 77],
  ["font-style", 220],
  ["font-variant", 161],
  ["font-weight", 257],
  ["height", 266],
  ["image-rendering", 90],
  ["justify-content", 127],
  ["left", 248],
  ["letter-spacing", 188],
  ["line-height", 244],
  ["list-style", 215],
  ["list-style-image", 145],
  ["list-style-position", 149],
  ["list-style-type", 199],
  ["margin", 267],
  ["margin-bottom", 241],
  ["margin-left", 243],
  ["margin-right", 238],
  ["margin-top", 253],
  ["mask", 20],
  ["max-height", 205],
  ["max-width", 225],
  ["min-height", 217],
  ["min-width", 218],
  ["object-fit", 33],
  ["opacity", 251],
  ["order", 117],
  ["orphans", 146],
  ["outline", 222],
  ["outline-color", 153],
  ["outline-offset", 147],
  ["outline-style", 151],
  ["outline-width", 148],
  ["overflow", 255],
  ["overflow-wrap", 105],
  ["overflow-x", 184],
  ["overflow-y", 196],
  ["padding", 265],
  ["padding-bottom", 230],
  ["padding-left", 235],
  ["padding-right", 232],
  ["padding-top", 240],
  ["page", 8],
  ["page-break-after", 120],
  ["page-break-before", 69],
  ["page-break-inside", 121],
  ["perspective", 92],
  ["perspective-origin", 103],
  ["pointer-events", 183],
  ["position", 261],
  ["quotes", 158],
  ["resize", 168],
  ["right", 245],
  ["shape-rendering", 38],
  ["size", 64],
  ["speak", 118],
  ["src", 170],
  ["stop-color", 42],
  ["stop-opacity", 31],
  ["stroke", 98],
  ["stroke-dasharray", 36],
  ["stroke-dashoffset", 3],
  ["stroke-linecap", 30],
  ["stroke-linejoin", 21],
  ["stroke-miterlimit", 12],
  ["stroke-opacity", 34],
  ["stroke-width", 87],
  ["table-layout", 171],
  ["tab-size", 46],
  ["text-align", 260],
  ["text-anchor", 35],
  ["text-decoration", 247],
  ["text-indent", 207],
  ["text-overflow", 204],
  ["text-rendering", 155],
  ["text-shadow", 208],
  ["text-transform", 202],
  ["top", 258],
  ["touch-action", 80],
  ["transform", 181],
  ["transform-origin", 162],
  ["transform-style", 86],
  ["transition", 193],
  ["transition-delay", 134],
  ["transition-duration", 135],
  ["transition-property", 131],
  ["transition-timing-function", 122],
  ["unicode-bidi", 156],
  ["unicode-range", 136],
  ["vertical-align", 236],
  ["visibility", 242],
  ["-webkit-appearance", 191],
  ["-webkit-backface-visibility", 154],
  ["-webkit-background-clip", 164],
  ["-webkit-background-origin", 40],
  ["-webkit-background-size", 163],
  ["-webkit-border-end", 9],
  ["-webkit-border-horizontal-spacing", 81],
  ["-webkit-border-image", 75],
  ["-webkit-border-radius", 212],
  ["-webkit-border-start", 10],
  ["-webkit-border-start-color", 16],
  ["-webkit-border-start-width", 13],
  ["-webkit-border-vertical-spacing", 43],
  ["-webkit-box-align", 101],
  ["-webkit-box-direction", 51],
  ["-webkit-box-flex", 128],
  ["-webkit-box-ordinal-group", 91],
  ["-webkit-box-orient", 144],
  ["-webkit-box-pack", 106],
  ["-webkit-box-reflect", 39],
  ["-webkit-box-shadow", 210],
  ["-webkit-column-break-inside", 60],
  ["-webkit-column-count", 84],
  ["-webkit-column-gap", 76],
  ["-webkit-column-rule", 25],
  ["-webkit-column-rule-color", 23],
  ["-webkit-columns", 44],
  ["-webkit-column-span", 29],
  ["-webkit-column-width", 47],
  ["-webkit-filter", 159],
  ["-webkit-font-feature-settings", 59],
  ["-webkit-font-smoothing", 177],
  ["-webkit-line-break", 45],
  ["-webkit-line-clamp", 126],
  ["-webkit-margin-after", 67],
  ["-webkit-margin-before", 70],
  ["-webkit-margin-collapse", 14],
  ["-webkit-margin-end", 65],
  ["-webkit-margin-start", 100],
  ["-webkit-mask", 19],
  ["-webkit-mask-box-image", 72],
  ["-webkit-mask-image", 88],
  ["-webkit-mask-position", 54],
  ["-webkit-mask-repeat", 63],
  ["-webkit-mask-size", 79],
  ["-webkit-padding-after", 15],
  ["-webkit-padding-before", 28],
  ["-webkit-padding-end", 48],
  ["-webkit-padding-start", 73],
  ["-webkit-print-color-adjust", 83],
  ["-webkit-rtl-ordering", 7],
  ["-webkit-tap-highlight-color", 169],
  ["-webkit-text-emphasis-color", 11],
  ["-webkit-text-fill-color", 71],
  ["-webkit-text-security", 17],
  ["-webkit-text-stroke", 56],
  ["-webkit-text-stroke-color", 37],
  ["-webkit-text-stroke-width", 53],
  ["-webkit-user-drag", 95],
  ["-webkit-user-modify", 62],
  ["-webkit-user-select", 194],
  ["-webkit-writing-mode", 4],
  ["white-space", 228],
  ["widows", 115],
  ["width", 268],
  ["will-change", 74],
  ["word-break", 166],
  ["word-spacing", 157],
  ["word-wrap", 197],
  ["writing-mode", 41],
  ["z-index", 239],
  ["zoom", 200]
]);
var CommonKeywords = ["auto", "none"];

// gen/front_end/core/sdk/ProfileTreeModel.js
var ProfileTreeModel_exports = {};
__export(ProfileTreeModel_exports, {
  ProfileTreeModel: () => ProfileTreeModel2
});
import * as CPUProfile from "./../../models/cpu_profile/cpu_profile.js";
var ProfileTreeModel2 = class extends CPUProfile.ProfileTreeModel.ProfileTreeModel {
};

// gen/front_end/core/sdk/NetworkRequest.js
var NetworkRequest_exports = {};
__export(NetworkRequest_exports, {
  Events: () => Events2,
  InitiatorType: () => InitiatorType,
  NetworkRequest: () => NetworkRequest,
  WebSocketFrameType: () => WebSocketFrameType,
  cookieBlockedReasonToAttribute: () => cookieBlockedReasonToAttribute,
  cookieBlockedReasonToUiString: () => cookieBlockedReasonToUiString,
  cookieExemptionReasonToUiString: () => cookieExemptionReasonToUiString,
  setCookieBlockedReasonToAttribute: () => setCookieBlockedReasonToAttribute,
  setCookieBlockedReasonToUiString: () => setCookieBlockedReasonToUiString
});
import * as TextUtils21 from "./../../models/text_utils/text_utils.js";
import * as Common25 from "./../common/common.js";
import * as i18n21 from "./../i18n/i18n.js";
import * as Platform19 from "./../platform/platform.js";

// gen/front_end/core/sdk/Cookie.js
var Cookie_exports = {};
__export(Cookie_exports, {
  Attribute: () => Attribute,
  Cookie: () => Cookie,
  Type: () => Type
});
var OPAQUE_PARTITION_KEY = "<opaque>";
var Cookie = class _Cookie {
  #nameInternal;
  #valueInternal;
  #typeInternal;
  #attributes;
  #sizeInternal;
  #priorityInternal;
  #cookieLine;
  #partitionKey;
  constructor(name, value, type, priority, partitionKey) {
    this.#nameInternal = name;
    this.#valueInternal = value;
    this.#typeInternal = type;
    this.#attributes = /* @__PURE__ */ new Map();
    this.#sizeInternal = 0;
    this.#priorityInternal = priority || "Medium";
    this.#cookieLine = null;
    this.#partitionKey = partitionKey;
  }
  static fromProtocolCookie(protocolCookie) {
    const cookie = new _Cookie(protocolCookie.name, protocolCookie.value, null, protocolCookie.priority);
    cookie.addAttribute("domain", protocolCookie["domain"]);
    cookie.addAttribute("path", protocolCookie["path"]);
    if (protocolCookie["expires"]) {
      cookie.addAttribute("expires", protocolCookie["expires"] * 1e3);
    }
    if (protocolCookie["httpOnly"]) {
      cookie.addAttribute(
        "http-only"
        /* HTTP_ONLY */
      );
    }
    if (protocolCookie["secure"]) {
      cookie.addAttribute(
        "secure"
        /* SECURE */
      );
    }
    if (protocolCookie["sameSite"]) {
      cookie.addAttribute("same-site", protocolCookie["sameSite"]);
    }
    if ("sourcePort" in protocolCookie) {
      cookie.addAttribute("source-port", protocolCookie.sourcePort);
    }
    if ("sourceScheme" in protocolCookie) {
      cookie.addAttribute("source-scheme", protocolCookie.sourceScheme);
    }
    if ("partitionKey" in protocolCookie) {
      if (protocolCookie.partitionKey) {
        cookie.setPartitionKey(
          protocolCookie.partitionKey.topLevelSite,
          protocolCookie.partitionKey.hasCrossSiteAncestor
        );
      }
    }
    if ("partitionKeyOpaque" in protocolCookie && protocolCookie.partitionKeyOpaque) {
      cookie.addAttribute("partition-key", OPAQUE_PARTITION_KEY);
    }
    cookie.setSize(protocolCookie["size"]);
    return cookie;
  }
  key() {
    return (this.domain() || "-") + " " + this.name() + " " + (this.path() || "-") + " " + (this.partitionKey() ? this.topLevelSite() + " " + (this.hasCrossSiteAncestor() ? "cross_site" : "same_site") : "-");
  }
  name() {
    return this.#nameInternal;
  }
  value() {
    return this.#valueInternal;
  }
  type() {
    return this.#typeInternal;
  }
  httpOnly() {
    return this.#attributes.has(
      "http-only"
      /* HTTP_ONLY */
    );
  }
  secure() {
    return this.#attributes.has(
      "secure"
      /* SECURE */
    );
  }
  partitioned() {
    return this.#attributes.has(
      "partitioned"
      /* PARTITIONED */
    ) || Boolean(this.partitionKey()) || this.partitionKeyOpaque();
  }
  sameSite() {
    return this.#attributes.get(
      "same-site"
      /* SAME_SITE */
    );
  }
  partitionKey() {
    return this.#partitionKey;
  }
  setPartitionKey(topLevelSite, hasCrossSiteAncestor) {
    this.#partitionKey = { topLevelSite, hasCrossSiteAncestor };
    if (!this.#attributes.has(
      "partitioned"
      /* PARTITIONED */
    )) {
      this.addAttribute(
        "partitioned"
        /* PARTITIONED */
      );
    }
  }
  topLevelSite() {
    if (!this.#partitionKey) {
      return "";
    }
    return this.#partitionKey?.topLevelSite;
  }
  setTopLevelSite(topLevelSite, hasCrossSiteAncestor) {
    this.setPartitionKey(topLevelSite, hasCrossSiteAncestor);
  }
  hasCrossSiteAncestor() {
    if (!this.#partitionKey) {
      return false;
    }
    return this.#partitionKey?.hasCrossSiteAncestor;
  }
  setHasCrossSiteAncestor(hasCrossSiteAncestor) {
    if (!this.partitionKey() || !Boolean(this.topLevelSite())) {
      return;
    }
    this.setPartitionKey(this.topLevelSite(), hasCrossSiteAncestor);
  }
  partitionKeyOpaque() {
    if (!this.#partitionKey) {
      return false;
    }
    return this.topLevelSite() === OPAQUE_PARTITION_KEY;
  }
  setPartitionKeyOpaque() {
    this.addAttribute("partition-key", OPAQUE_PARTITION_KEY);
    this.setPartitionKey(OPAQUE_PARTITION_KEY, false);
  }
  priority() {
    return this.#priorityInternal;
  }
  session() {
    return !(this.#attributes.has(
      "expires"
      /* EXPIRES */
    ) || this.#attributes.has(
      "max-age"
      /* MAX_AGE */
    ));
  }
  path() {
    return this.#attributes.get(
      "path"
      /* PATH */
    );
  }
  domain() {
    return this.#attributes.get(
      "domain"
      /* DOMAIN */
    );
  }
  expires() {
    return this.#attributes.get(
      "expires"
      /* EXPIRES */
    );
  }
  maxAge() {
    return this.#attributes.get(
      "max-age"
      /* MAX_AGE */
    );
  }
  sourcePort() {
    return this.#attributes.get(
      "source-port"
      /* SOURCE_PORT */
    );
  }
  sourceScheme() {
    return this.#attributes.get(
      "source-scheme"
      /* SOURCE_SCHEME */
    );
  }
  size() {
    return this.#sizeInternal;
  }
  /**
   * @deprecated
   */
  url() {
    if (!this.domain() || !this.path()) {
      return null;
    }
    let port = "";
    const sourcePort = this.sourcePort();
    if (sourcePort && sourcePort !== 80 && sourcePort !== 443) {
      port = `:${this.sourcePort()}`;
    }
    return (this.secure() ? "https://" : "http://") + this.domain() + port + this.path();
  }
  setSize(size) {
    this.#sizeInternal = size;
  }
  expiresDate(requestDate) {
    if (this.maxAge()) {
      return new Date(requestDate.getTime() + 1e3 * this.maxAge());
    }
    if (this.expires()) {
      return new Date(this.expires());
    }
    return null;
  }
  addAttribute(key, value) {
    if (!key) {
      return;
    }
    switch (key) {
      case "priority":
        this.#priorityInternal = value;
        break;
      default:
        this.#attributes.set(key, value);
    }
  }
  setCookieLine(cookieLine) {
    this.#cookieLine = cookieLine;
  }
  getCookieLine() {
    return this.#cookieLine;
  }
  matchesSecurityOrigin(securityOrigin) {
    const hostname = new URL(securityOrigin).hostname;
    return _Cookie.isDomainMatch(this.domain(), hostname);
  }
  static isDomainMatch(domain, hostname) {
    if (hostname === domain) {
      return true;
    }
    if (!domain || domain[0] !== ".") {
      return false;
    }
    if (domain.substr(1) === hostname) {
      return true;
    }
    return hostname.length > domain.length && hostname.endsWith(domain);
  }
};
var Type = /* @__PURE__ */ ((Type22) => {
  Type22[Type22["REQUEST"] = 0] = "REQUEST";
  Type22[Type22["RESPONSE"] = 1] = "RESPONSE";
  return Type22;
})(Type || {});
var Attribute = /* @__PURE__ */ ((Attribute2) => {
  Attribute2["NAME"] = "name";
  Attribute2["VALUE"] = "value";
  Attribute2["SIZE"] = "size";
  Attribute2["DOMAIN"] = "domain";
  Attribute2["PATH"] = "path";
  Attribute2["EXPIRES"] = "expires";
  Attribute2["MAX_AGE"] = "max-age";
  Attribute2["HTTP_ONLY"] = "http-only";
  Attribute2["SECURE"] = "secure";
  Attribute2["SAME_SITE"] = "same-site";
  Attribute2["SOURCE_SCHEME"] = "source-scheme";
  Attribute2["SOURCE_PORT"] = "source-port";
  Attribute2["PRIORITY"] = "priority";
  Attribute2["PARTITIONED"] = "partitioned";
  Attribute2["PARTITION_KEY"] = "partition-key";
  Attribute2["PARTITION_KEY_SITE"] = "partition-key-site";
  Attribute2["HAS_CROSS_SITE_ANCESTOR"] = "has-cross-site-ancestor";
  return Attribute2;
})(Attribute || {});

// gen/front_end/core/sdk/CookieModel.js
var CookieModel_exports = {};
__export(CookieModel_exports, {
  CookieModel: () => CookieModel,
  Events: () => Events16
});
import * as Common24 from "./../common/common.js";
import * as Platform17 from "./../platform/platform.js";
import * as Root7 from "./../root/root.js";

// gen/front_end/core/sdk/NetworkManager.js
var NetworkManager_exports = {};
__export(NetworkManager_exports, {
  ConditionsSerializer: () => ConditionsSerializer,
  Events: () => Events3,
  Fast4GConditions: () => Fast4GConditions,
  FetchDispatcher: () => FetchDispatcher,
  InterceptedRequest: () => InterceptedRequest,
  MultitargetNetworkManager: () => MultitargetNetworkManager,
  NetworkDispatcher: () => NetworkDispatcher,
  NetworkManager: () => NetworkManager,
  NoThrottlingConditions: () => NoThrottlingConditions,
  OfflineConditions: () => OfflineConditions,
  Slow3GConditions: () => Slow3GConditions,
  Slow4GConditions: () => Slow4GConditions,
  networkConditionsEqual: () => networkConditionsEqual
});
import * as TextUtils from "./../../models/text_utils/text_utils.js";
import * as Common5 from "./../common/common.js";
import * as Host2 from "./../host/host.js";
import * as i18n from "./../i18n/i18n.js";
import * as Platform3 from "./../platform/platform.js";

// gen/front_end/core/sdk/Target.js
var Target_exports = {};
__export(Target_exports, {
  Capability: () => Capability,
  Target: () => Target,
  Type: () => Type2
});
import * as Common3 from "./../common/common.js";
import * as Platform from "./../platform/platform.js";
import * as ProtocolClient from "./../protocol_client/protocol_client.js";
var Target = class extends ProtocolClient.InspectorBackend.TargetBase {
  #targetManagerInternal;
  #nameInternal;
  #inspectedURLInternal;
  #inspectedURLName;
  #capabilitiesMask;
  #typeInternal;
  #parentTargetInternal;
  #idInternal;
  #modelByConstructor;
  #isSuspended;
  #targetInfoInternal;
  #creatingModels;
  constructor(targetManager, id, name, type, parentTarget, sessionId, suspended, connection, targetInfo) {
    const needsNodeJSPatching = type === "node";
    super(needsNodeJSPatching, parentTarget, sessionId, connection);
    this.#targetManagerInternal = targetManager;
    this.#nameInternal = name;
    this.#inspectedURLInternal = Platform.DevToolsPath.EmptyUrlString;
    this.#inspectedURLName = "";
    this.#capabilitiesMask = 0;
    switch (type) {
      case "frame":
        this.#capabilitiesMask = 1 | 8192 | 2 | 4 | 8 | 16 | 32 | 128 | 256 | 1024 | 2048 | 32768 | 65536 | 131072 | 262144 | 524288;
        if (parentTarget?.type() !== "frame") {
          this.#capabilitiesMask |= 4096 | 64 | 512 | 16384;
          if (Common3.ParsedURL.schemeIs(targetInfo?.url, "chrome-extension:")) {
            this.#capabilitiesMask &= ~512;
          }
        }
        break;
      case "service-worker":
        this.#capabilitiesMask = 4 | 8 | 16 | 32 | 2048 | 131072 | 524288;
        if (parentTarget?.type() !== "frame") {
          this.#capabilitiesMask |= 1;
        }
        break;
      case "shared-worker":
        this.#capabilitiesMask = 4 | 8 | 16 | 32 | 131072 | 262144 | 2048 | 524288;
        break;
      case "shared-storage-worklet":
        this.#capabilitiesMask = 4 | 8 | 2048 | 524288;
        break;
      case "worker":
        this.#capabilitiesMask = 4 | 8 | 16 | 32 | 131072 | 262144 | 256 | 524288;
        break;
      case "worklet":
        this.#capabilitiesMask = 4 | 8 | 524288 | 16;
        break;
      case "node":
        this.#capabilitiesMask = 4;
        break;
      case "auction-worklet":
        this.#capabilitiesMask = 4 | 524288;
        break;
      case "browser":
        this.#capabilitiesMask = 32 | 131072;
        break;
      case "tab":
        this.#capabilitiesMask = 32 | 128;
        break;
    }
    this.#typeInternal = type;
    this.#parentTargetInternal = parentTarget;
    this.#idInternal = id;
    this.#modelByConstructor = /* @__PURE__ */ new Map();
    this.#isSuspended = suspended;
    this.#targetInfoInternal = targetInfo;
  }
  createModels(required) {
    this.#creatingModels = true;
    const registeredModels2 = Array.from(SDKModel.registeredModels.entries());
    for (const [modelClass, info] of registeredModels2) {
      if (info.early) {
        this.model(modelClass);
      }
    }
    for (const [modelClass, info] of registeredModels2) {
      if (info.autostart || required.has(modelClass)) {
        this.model(modelClass);
      }
    }
    this.#creatingModels = false;
  }
  id() {
    return this.#idInternal;
  }
  name() {
    return this.#nameInternal || this.#inspectedURLName;
  }
  setName(name) {
    if (this.#nameInternal === name) {
      return;
    }
    this.#nameInternal = name;
    this.#targetManagerInternal.onNameChange(this);
  }
  type() {
    return this.#typeInternal;
  }
  markAsNodeJSForTest() {
    super.markAsNodeJSForTest();
    this.#typeInternal = "node";
  }
  targetManager() {
    return this.#targetManagerInternal;
  }
  hasAllCapabilities(capabilitiesMask) {
    return (this.#capabilitiesMask & capabilitiesMask) === capabilitiesMask;
  }
  decorateLabel(label) {
    return this.#typeInternal === "worker" || this.#typeInternal === "service-worker" ? "\u2699 " + label : label;
  }
  parentTarget() {
    return this.#parentTargetInternal;
  }
  outermostTarget() {
    let lastTarget = null;
    let currentTarget = this;
    do {
      if (currentTarget.type() !== "tab" && currentTarget.type() !== "browser") {
        lastTarget = currentTarget;
      }
      currentTarget = currentTarget.parentTarget();
    } while (currentTarget);
    return lastTarget;
  }
  dispose(reason) {
    super.dispose(reason);
    this.#targetManagerInternal.removeTarget(this);
    for (const model of this.#modelByConstructor.values()) {
      model.dispose();
    }
  }
  model(modelClass) {
    if (!this.#modelByConstructor.get(modelClass)) {
      const info = SDKModel.registeredModels.get(modelClass);
      if (info === void 0) {
        throw "Model class is not registered @" + new Error().stack;
      }
      if ((this.#capabilitiesMask & info.capabilities) === info.capabilities) {
        const model = new modelClass(this);
        this.#modelByConstructor.set(modelClass, model);
        if (!this.#creatingModels) {
          this.#targetManagerInternal.modelAdded(this, modelClass, model, this.#targetManagerInternal.isInScope(this));
        }
      }
    }
    return this.#modelByConstructor.get(modelClass) || null;
  }
  models() {
    return this.#modelByConstructor;
  }
  inspectedURL() {
    return this.#inspectedURLInternal;
  }
  setInspectedURL(inspectedURL) {
    this.#inspectedURLInternal = inspectedURL;
    const parsedURL = Common3.ParsedURL.ParsedURL.fromString(inspectedURL);
    this.#inspectedURLName = parsedURL ? parsedURL.lastPathComponentWithFragment() : "#" + this.#idInternal;
    this.#targetManagerInternal.onInspectedURLChange(this);
    if (!this.#nameInternal) {
      this.#targetManagerInternal.onNameChange(this);
    }
  }
  async suspend(reason) {
    if (this.#isSuspended) {
      return;
    }
    this.#isSuspended = true;
    await Promise.all(Array.from(this.models().values(), (m) => m.preSuspendModel(reason)));
    await Promise.all(Array.from(this.models().values(), (m) => m.suspendModel(reason)));
  }
  async resume() {
    if (!this.#isSuspended) {
      return;
    }
    this.#isSuspended = false;
    await Promise.all(Array.from(this.models().values(), (m) => m.resumeModel()));
    await Promise.all(Array.from(this.models().values(), (m) => m.postResumeModel()));
  }
  suspended() {
    return this.#isSuspended;
  }
  updateTargetInfo(targetInfo) {
    this.#targetInfoInternal = targetInfo;
  }
  targetInfo() {
    return this.#targetInfoInternal;
  }
};
var Type2 = /* @__PURE__ */ ((Type22) => {
  Type22["FRAME"] = "frame";
  Type22["ServiceWorker"] = "service-worker";
  Type22["Worker"] = "worker";
  Type22["SHARED_WORKER"] = "shared-worker";
  Type22["SHARED_STORAGE_WORKLET"] = "shared-storage-worklet";
  Type22["NODE"] = "node";
  Type22["BROWSER"] = "browser";
  Type22["AUCTION_WORKLET"] = "auction-worklet";
  Type22["WORKLET"] = "worklet";
  Type22["TAB"] = "tab";
  return Type22;
})(Type2 || {});
var Capability = /* @__PURE__ */ ((Capability2) => {
  Capability2[Capability2["BROWSER"] = 1] = "BROWSER";
  Capability2[Capability2["DOM"] = 2] = "DOM";
  Capability2[Capability2["JS"] = 4] = "JS";
  Capability2[Capability2["LOG"] = 8] = "LOG";
  Capability2[Capability2["NETWORK"] = 16] = "NETWORK";
  Capability2[Capability2["TARGET"] = 32] = "TARGET";
  Capability2[Capability2["SCREEN_CAPTURE"] = 64] = "SCREEN_CAPTURE";
  Capability2[Capability2["TRACING"] = 128] = "TRACING";
  Capability2[Capability2["EMULATION"] = 256] = "EMULATION";
  Capability2[Capability2["SECURITY"] = 512] = "SECURITY";
  Capability2[Capability2["INPUT"] = 1024] = "INPUT";
  Capability2[Capability2["INSPECTOR"] = 2048] = "INSPECTOR";
  Capability2[Capability2["DEVICE_EMULATION"] = 4096] = "DEVICE_EMULATION";
  Capability2[Capability2["STORAGE"] = 8192] = "STORAGE";
  Capability2[Capability2["SERVICE_WORKER"] = 16384] = "SERVICE_WORKER";
  Capability2[Capability2["AUDITS"] = 32768] = "AUDITS";
  Capability2[Capability2["WEB_AUTHN"] = 65536] = "WEB_AUTHN";
  Capability2[Capability2["IO"] = 131072] = "IO";
  Capability2[Capability2["MEDIA"] = 262144] = "MEDIA";
  Capability2[Capability2["EVENT_BREAKPOINTS"] = 524288] = "EVENT_BREAKPOINTS";
  Capability2[Capability2["NONE"] = 0] = "NONE";
  return Capability2;
})(Capability || {});

// gen/front_end/core/sdk/TargetManager.js
var TargetManager_exports = {};
__export(TargetManager_exports, {
  Events: () => Events,
  Observer: () => Observer,
  SDKModelObserver: () => SDKModelObserver,
  TargetManager: () => TargetManager
});
import * as Common4 from "./../common/common.js";
import * as Host from "./../host/host.js";
import * as Platform2 from "./../platform/platform.js";
import { assertNotNullOrUndefined } from "./../platform/platform.js";
import * as Root from "./../root/root.js";
var targetManagerInstance;
var TargetManager = class _TargetManager extends Common4.ObjectWrapper.ObjectWrapper {
  #targetsInternal;
  #observers;
  /* eslint-disable @typescript-eslint/no-explicit-any */
  #modelListeners;
  #modelObservers;
  #scopedObservers;
  /* eslint-enable @typescript-eslint/no-explicit-any */
  #isSuspended;
  #browserTargetInternal;
  #scopeTarget;
  #defaultScopeSet;
  #scopeChangeListeners;
  constructor() {
    super();
    this.#targetsInternal = /* @__PURE__ */ new Set();
    this.#observers = /* @__PURE__ */ new Set();
    this.#modelListeners = new Platform2.MapUtilities.Multimap();
    this.#modelObservers = new Platform2.MapUtilities.Multimap();
    this.#isSuspended = false;
    this.#browserTargetInternal = null;
    this.#scopeTarget = null;
    this.#scopedObservers = /* @__PURE__ */ new WeakSet();
    this.#defaultScopeSet = false;
    this.#scopeChangeListeners = /* @__PURE__ */ new Set();
  }
  static instance({ forceNew } = { forceNew: false }) {
    if (!targetManagerInstance || forceNew) {
      targetManagerInstance = new _TargetManager();
    }
    return targetManagerInstance;
  }
  static removeInstance() {
    targetManagerInstance = void 0;
  }
  onInspectedURLChange(target) {
    if (target !== this.#scopeTarget) {
      return;
    }
    Host.InspectorFrontendHost.InspectorFrontendHostInstance.inspectedURLChanged(
      target.inspectedURL() || Platform2.DevToolsPath.EmptyUrlString
    );
    this.dispatchEventToListeners("InspectedURLChanged", target);
  }
  onNameChange(target) {
    this.dispatchEventToListeners("NameChanged", target);
  }
  async suspendAllTargets(reason) {
    if (this.#isSuspended) {
      return;
    }
    this.#isSuspended = true;
    this.dispatchEventToListeners(
      "SuspendStateChanged"
      /* SUSPEND_STATE_CHANGED */
    );
    const suspendPromises = Array.from(this.#targetsInternal.values(), (target) => target.suspend(reason));
    await Promise.all(suspendPromises);
  }
  async resumeAllTargets() {
    if (!this.#isSuspended) {
      return;
    }
    this.#isSuspended = false;
    this.dispatchEventToListeners(
      "SuspendStateChanged"
      /* SUSPEND_STATE_CHANGED */
    );
    const resumePromises = Array.from(this.#targetsInternal.values(), (target) => target.resume());
    await Promise.all(resumePromises);
  }
  allTargetsSuspended() {
    return this.#isSuspended;
  }
  models(modelClass, opts) {
    const result = [];
    for (const target of this.#targetsInternal) {
      if (opts?.scoped && !this.isInScope(target)) {
        continue;
      }
      const model = target.model(modelClass);
      if (!model) {
        continue;
      }
      result.push(model);
    }
    return result;
  }
  inspectedURL() {
    const mainTarget = this.primaryPageTarget();
    return mainTarget ? mainTarget.inspectedURL() : "";
  }
  observeModels(modelClass, observer, opts) {
    const models = this.models(modelClass, opts);
    this.#modelObservers.set(modelClass, observer);
    if (opts?.scoped) {
      this.#scopedObservers.add(observer);
    }
    for (const model of models) {
      observer.modelAdded(model);
    }
  }
  unobserveModels(modelClass, observer) {
    this.#modelObservers.delete(modelClass, observer);
    this.#scopedObservers.delete(observer);
  }
  modelAdded(target, modelClass, model, inScope) {
    for (const observer of this.#modelObservers.get(modelClass).values()) {
      if (!this.#scopedObservers.has(observer) || inScope) {
        observer.modelAdded(model);
      }
    }
  }
  modelRemoved(target, modelClass, model, inScope) {
    for (const observer of this.#modelObservers.get(modelClass).values()) {
      if (!this.#scopedObservers.has(observer) || inScope) {
        observer.modelRemoved(model);
      }
    }
  }
  addModelListener(modelClass, eventType, listener, thisObject, opts) {
    const wrappedListener = (event) => {
      if (!opts?.scoped || this.isInScope(event)) {
        listener.call(thisObject, event);
      }
    };
    for (const model of this.models(modelClass)) {
      model.addEventListener(eventType, wrappedListener);
    }
    this.#modelListeners.set(eventType, { modelClass, thisObject, listener, wrappedListener });
  }
  removeModelListener(modelClass, eventType, listener, thisObject) {
    if (!this.#modelListeners.has(eventType)) {
      return;
    }
    let wrappedListener = null;
    for (const info of this.#modelListeners.get(eventType)) {
      if (info.modelClass === modelClass && info.listener === listener && info.thisObject === thisObject) {
        wrappedListener = info.wrappedListener;
        this.#modelListeners.delete(eventType, info);
      }
    }
    if (wrappedListener) {
      for (const model of this.models(modelClass)) {
        model.removeEventListener(eventType, wrappedListener);
      }
    }
  }
  observeTargets(targetObserver, opts) {
    if (this.#observers.has(targetObserver)) {
      throw new Error("Observer can only be registered once");
    }
    if (opts?.scoped) {
      this.#scopedObservers.add(targetObserver);
    }
    for (const target of this.#targetsInternal) {
      if (!opts?.scoped || this.isInScope(target)) {
        targetObserver.targetAdded(target);
      }
    }
    this.#observers.add(targetObserver);
  }
  unobserveTargets(targetObserver) {
    this.#observers.delete(targetObserver);
    this.#scopedObservers.delete(targetObserver);
  }
  createTarget(id, name, type, parentTarget, sessionId, waitForDebuggerInPage, connection, targetInfo) {
    const target = new Target(
      this,
      id,
      name,
      type,
      parentTarget,
      sessionId || "",
      this.#isSuspended,
      connection || null,
      targetInfo
    );
    if (waitForDebuggerInPage) {
      void target.pageAgent().invoke_waitForDebugger();
    }
    target.createModels(new Set(this.#modelObservers.keysArray()));
    this.#targetsInternal.add(target);
    const inScope = this.isInScope(target);
    for (const observer of [...this.#observers]) {
      if (!this.#scopedObservers.has(observer) || inScope) {
        observer.targetAdded(target);
      }
    }
    for (const [modelClass, model] of target.models().entries()) {
      this.modelAdded(target, modelClass, model, inScope);
    }
    for (const key of this.#modelListeners.keysArray()) {
      for (const info of this.#modelListeners.get(key)) {
        const model = target.model(info.modelClass);
        if (model) {
          model.addEventListener(key, info.wrappedListener);
        }
      }
    }
    if (target === target.outermostTarget() && (target.type() !== Type2.FRAME || target === this.primaryPageTarget()) && !this.#defaultScopeSet) {
      this.setScopeTarget(target);
    }
    return target;
  }
  removeTarget(target) {
    if (!this.#targetsInternal.has(target)) {
      return;
    }
    const inScope = this.isInScope(target);
    this.#targetsInternal.delete(target);
    for (const modelClass of target.models().keys()) {
      const model = target.models().get(modelClass);
      assertNotNullOrUndefined(model);
      this.modelRemoved(target, modelClass, model, inScope);
    }
    for (const observer of [...this.#observers]) {
      if (!this.#scopedObservers.has(observer) || inScope) {
        observer.targetRemoved(target);
      }
    }
    for (const key of this.#modelListeners.keysArray()) {
      for (const info of this.#modelListeners.get(key)) {
        const model = target.model(info.modelClass);
        if (model) {
          model.removeEventListener(key, info.wrappedListener);
        }
      }
    }
  }
  targets() {
    return [...this.#targetsInternal];
  }
  targetById(id) {
    return this.targets().find((target) => target.id() === id) || null;
  }
  rootTarget() {
    if (this.#targetsInternal.size === 0) {
      return null;
    }
    return this.#targetsInternal.values().next().value ?? null;
  }
  primaryPageTarget() {
    let target = this.rootTarget();
    if (target?.type() === Type2.TAB) {
      target = this.targets().find(
        (t) => t.parentTarget() === target && t.type() === Type2.FRAME && !t.targetInfo()?.subtype?.length
      ) || null;
    }
    return target;
  }
  browserTarget() {
    return this.#browserTargetInternal;
  }
  async maybeAttachInitialTarget() {
    if (!Boolean(Root.Runtime.Runtime.queryParam("browserConnection"))) {
      return false;
    }
    if (!this.#browserTargetInternal) {
      this.#browserTargetInternal = new Target(
        this,
        /* #id*/
        "main",
        /* #name*/
        "browser",
        Type2.BROWSER,
        /* #parentTarget*/
        null,
        /* #sessionId */
        "",
        /* suspended*/
        false,
        /* #connection*/
        null,
        /* targetInfo*/
        void 0
      );
      this.#browserTargetInternal.createModels(new Set(this.#modelObservers.keysArray()));
    }
    const targetId = await Host.InspectorFrontendHost.InspectorFrontendHostInstance.initialTargetId();
    void this.#browserTargetInternal.targetAgent().invoke_autoAttachRelated({
      targetId,
      waitForDebuggerOnStart: true
    });
    return true;
  }
  clearAllTargetsForTest() {
    this.#targetsInternal.clear();
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  isInScope(arg) {
    if (!arg) {
      return false;
    }
    if (isSDKModelEvent(arg)) {
      arg = arg.source;
    }
    if (arg instanceof SDKModel) {
      arg = arg.target();
    }
    while (arg && arg !== this.#scopeTarget) {
      arg = arg.parentTarget();
    }
    return Boolean(arg) && arg === this.#scopeTarget;
  }
  // Sets a root of a scope substree.
  // TargetManager API invoked with `scoped: true` will behave as if targets
  // outside of the scope subtree don't exist. Concretely this means that
  // target observers, model observers and model listeners won't be invoked for targets outside of the
  // scope tree. This method will invoke targetRemoved and modelRemoved for
  // objects in the previous scope, as if they disappear and then will invoke
  // targetAdded and modelAdded as if they just appeared.
  // Note that scopeTarget could be null, which will effectively prevent scoped
  // observes from getting any events.
  setScopeTarget(scopeTarget) {
    if (scopeTarget === this.#scopeTarget) {
      return;
    }
    for (const target of this.targets()) {
      if (!this.isInScope(target)) {
        continue;
      }
      for (const modelClass of this.#modelObservers.keysArray()) {
        const model = target.models().get(modelClass);
        if (!model) {
          continue;
        }
        for (const observer of [...this.#modelObservers.get(modelClass)].filter((o) => this.#scopedObservers.has(o))) {
          observer.modelRemoved(model);
        }
      }
      for (const observer of [...this.#observers].filter((o) => this.#scopedObservers.has(o))) {
        observer.targetRemoved(target);
      }
    }
    this.#scopeTarget = scopeTarget;
    for (const target of this.targets()) {
      if (!this.isInScope(target)) {
        continue;
      }
      for (const observer of [...this.#observers].filter((o) => this.#scopedObservers.has(o))) {
        observer.targetAdded(target);
      }
      for (const [modelClass, model] of target.models().entries()) {
        for (const observer of [...this.#modelObservers.get(modelClass)].filter((o) => this.#scopedObservers.has(o))) {
          observer.modelAdded(model);
        }
      }
    }
    for (const scopeChangeListener of this.#scopeChangeListeners) {
      scopeChangeListener();
    }
    if (scopeTarget && scopeTarget.inspectedURL()) {
      this.onInspectedURLChange(scopeTarget);
    }
  }
  addScopeChangeListener(listener) {
    this.#scopeChangeListeners.add(listener);
  }
  removeScopeChangeListener(listener) {
    this.#scopeChangeListeners.delete(listener);
  }
  scopeTarget() {
    return this.#scopeTarget;
  }
};
var Events = /* @__PURE__ */ ((Events210) => {
  Events210["AVAILABLE_TARGETS_CHANGED"] = "AvailableTargetsChanged";
  Events210["INSPECTED_URL_CHANGED"] = "InspectedURLChanged";
  Events210["NAME_CHANGED"] = "NameChanged";
  Events210["SUSPEND_STATE_CHANGED"] = "SuspendStateChanged";
  return Events210;
})(Events || {});
var Observer = class {
  targetAdded(_target) {
  }
  targetRemoved(_target) {
  }
};
var SDKModelObserver = class {
  modelAdded(_model) {
  }
  modelRemoved(_model) {
  }
};
function isSDKModelEvent(arg) {
  return "source" in arg && arg.source instanceof SDKModel;
}

// gen/front_end/core/sdk/NetworkManager.js
var UIStrings = {
  /**
   *@description Explanation why no content is shown for WebSocket connection.
   */
  noContentForWebSocket: "Content for WebSockets is currently not supported",
  /**
   *@description Explanation why no content is shown for redirect response.
   */
  noContentForRedirect: "No content available because this request was redirected",
  /**
   *@description Explanation why no content is shown for preflight request.
   */
  noContentForPreflight: "No content available for preflight request",
  /**
   *@description Text to indicate that network throttling is disabled
   */
  noThrottling: "No throttling",
  /**
   *@description Text to indicate the network connectivity is offline
   */
  offline: "Offline",
  /**
   *@description Text in Network Manager representing the "3G" throttling preset.
   */
  slowG: "3G",
  // Named `slowG` for legacy reasons and because this value
  // is serialized locally on the user's machine: if we
  // change it we break their stored throttling settings.
  // (See crrev.com/c/2947255)
  /**
   *@description Text in Network Manager representing the "Slow 4G" throttling preset
   */
  fastG: "Slow 4G",
  // Named `fastG` for legacy reasons and because this value
  // is serialized locally on the user's machine: if we
  // change it we break their stored throttling settings.
  // (See crrev.com/c/2947255)
  /**
   *@description Text in Network Manager representing the "Fast 4G" throttling preset
   */
  fast4G: "Fast 4G",
  /**
   *@description Text in Network Manager
   *@example {https://example.com} PH1
   */
  requestWasBlockedByDevtoolsS: 'Request was blocked by DevTools: "{PH1}"',
  /**
   *@description Message in Network Manager
   *@example {XHR} PH1
   *@example {GET} PH2
   *@example {https://example.com} PH3
   */
  sFailedLoadingSS: '{PH1} failed loading: {PH2} "{PH3}".',
  /**
   *@description Message in Network Manager
   *@example {XHR} PH1
   *@example {GET} PH2
   *@example {https://example.com} PH3
   */
  sFinishedLoadingSS: '{PH1} finished loading: {PH2} "{PH3}".'
};
var str_ = i18n.i18n.registerUIStrings("core/sdk/NetworkManager.ts", UIStrings);
var i18nString = i18n.i18n.getLocalizedString.bind(void 0, str_);
var i18nLazyString = i18n.i18n.getLazilyComputedLocalizedString.bind(void 0, str_);
var requestToManagerMap = /* @__PURE__ */ new WeakMap();
var CONNECTION_TYPES = /* @__PURE__ */ new Map([
  ["2g", Network.ConnectionType.Cellular2g],
  ["3g", Network.ConnectionType.Cellular3g],
  ["4g", Network.ConnectionType.Cellular4g],
  ["bluetooth", Network.ConnectionType.Bluetooth],
  ["wifi", Network.ConnectionType.Wifi],
  ["wimax", Network.ConnectionType.Wimax]
]);
var NetworkManager = class _NetworkManager extends SDKModel {
  dispatcher;
  fetchDispatcher;
  #networkAgent;
  #bypassServiceWorkerSetting;
  constructor(target) {
    super(target);
    this.dispatcher = new NetworkDispatcher(this);
    this.fetchDispatcher = new FetchDispatcher(target.fetchAgent(), this);
    this.#networkAgent = target.networkAgent();
    target.registerNetworkDispatcher(this.dispatcher);
    target.registerFetchDispatcher(this.fetchDispatcher);
    if (Common5.Settings.Settings.instance().moduleSetting("cache-disabled").get()) {
      void this.#networkAgent.invoke_setCacheDisabled({ cacheDisabled: true });
    }
    void this.#networkAgent.invoke_enable({ maxPostDataSize: MAX_EAGER_POST_REQUEST_BODY_LENGTH });
    void this.#networkAgent.invoke_setAttachDebugStack({ enabled: true });
    this.#bypassServiceWorkerSetting = Common5.Settings.Settings.instance().createSetting("bypass-service-worker", false);
    if (this.#bypassServiceWorkerSetting.get()) {
      this.bypassServiceWorkerChanged();
    }
    this.#bypassServiceWorkerSetting.addChangeListener(this.bypassServiceWorkerChanged, this);
    Common5.Settings.Settings.instance().moduleSetting("cache-disabled").addChangeListener(this.cacheDisabledSettingChanged, this);
  }
  static forRequest(request) {
    return requestToManagerMap.get(request) || null;
  }
  static canReplayRequest(request) {
    return Boolean(requestToManagerMap.get(request)) && Boolean(request.backendRequestId()) && !request.isRedirect() && request.resourceType() === Common5.ResourceType.resourceTypes.XHR;
  }
  static replayRequest(request) {
    const manager = requestToManagerMap.get(request);
    const requestId = request.backendRequestId();
    if (!manager || !requestId || request.isRedirect()) {
      return;
    }
    void manager.#networkAgent.invoke_replayXHR({ requestId });
  }
  static async searchInRequest(request, query, caseSensitive, isRegex) {
    const manager = _NetworkManager.forRequest(request);
    const requestId = request.backendRequestId();
    if (!manager || !requestId || request.isRedirect()) {
      return [];
    }
    const response = await manager.#networkAgent.invoke_searchInResponseBody({ requestId, query, caseSensitive, isRegex });
    return TextUtils.TextUtils.performSearchInSearchMatches(response.result || [], query, caseSensitive, isRegex);
  }
  static async requestContentData(request) {
    if (request.resourceType() === Common5.ResourceType.resourceTypes.WebSocket) {
      return { error: i18nString(UIStrings.noContentForWebSocket) };
    }
    if (!request.finished) {
      await request.once(Events2.FINISHED_LOADING);
    }
    if (request.isRedirect()) {
      return { error: i18nString(UIStrings.noContentForRedirect) };
    }
    if (request.isPreflightRequest()) {
      return { error: i18nString(UIStrings.noContentForPreflight) };
    }
    const manager = _NetworkManager.forRequest(request);
    if (!manager) {
      return { error: "No network manager for request" };
    }
    const requestId = request.backendRequestId();
    if (!requestId) {
      return { error: "No backend request id for request" };
    }
    const response = await manager.#networkAgent.invoke_getResponseBody({ requestId });
    const error = response.getError();
    if (error) {
      return { error };
    }
    return new TextUtils.ContentData.ContentData(
      response.body,
      response.base64Encoded,
      request.mimeType,
      request.charset() ?? void 0
    );
  }
  /**
   * Returns the already received bytes for an in-flight request. After calling this method
   * "dataReceived" events will contain additional data.
   */
  static async streamResponseBody(request) {
    if (request.finished) {
      return { error: "Streaming the response body is only available for in-flight requests." };
    }
    const manager = _NetworkManager.forRequest(request);
    if (!manager) {
      return { error: "No network manager for request" };
    }
    const requestId = request.backendRequestId();
    if (!requestId) {
      return { error: "No backend request id for request" };
    }
    const response = await manager.#networkAgent.invoke_streamResourceContent({ requestId });
    const error = response.getError();
    if (error) {
      return { error };
    }
    await request.waitForResponseReceived();
    return new TextUtils.ContentData.ContentData(
      response.bufferedData,
      /* isBase64=*/
      true,
      request.mimeType,
      request.charset() ?? void 0
    );
  }
  static async requestPostData(request) {
    const manager = _NetworkManager.forRequest(request);
    if (!manager) {
      console.error("No network manager for request");
      return null;
    }
    const requestId = request.backendRequestId();
    if (!requestId) {
      console.error("No backend request id for request");
      return null;
    }
    try {
      const { postData } = await manager.#networkAgent.invoke_getRequestPostData({ requestId });
      return postData;
    } catch (e) {
      return e.message;
    }
  }
  static connectionType(conditions) {
    if (!conditions.download && !conditions.upload) {
      return Network.ConnectionType.None;
    }
    try {
      const title = typeof conditions.title === "function" ? conditions.title().toLowerCase() : conditions.title.toLowerCase();
      for (const [name, protocolType] of CONNECTION_TYPES) {
        if (title.includes(name)) {
          return protocolType;
        }
      }
    } catch {
      return Network.ConnectionType.None;
    }
    return Network.ConnectionType.Other;
  }
  static lowercaseHeaders(headers) {
    const newHeaders = {};
    for (const headerName in headers) {
      newHeaders[headerName.toLowerCase()] = headers[headerName];
    }
    return newHeaders;
  }
  requestForURL(url) {
    return this.dispatcher.requestForURL(url);
  }
  requestForId(id) {
    return this.dispatcher.requestForId(id);
  }
  requestForLoaderId(loaderId) {
    return this.dispatcher.requestForLoaderId(loaderId);
  }
  cacheDisabledSettingChanged({ data: enabled }) {
    void this.#networkAgent.invoke_setCacheDisabled({ cacheDisabled: enabled });
  }
  dispose() {
    Common5.Settings.Settings.instance().moduleSetting("cache-disabled").removeChangeListener(this.cacheDisabledSettingChanged, this);
  }
  bypassServiceWorkerChanged() {
    void this.#networkAgent.invoke_setBypassServiceWorker({ bypass: this.#bypassServiceWorkerSetting.get() });
  }
  async getSecurityIsolationStatus(frameId) {
    const result = await this.#networkAgent.invoke_getSecurityIsolationStatus({ frameId: frameId ?? void 0 });
    if (result.getError()) {
      return null;
    }
    return result.status;
  }
  async enableReportingApi(enable = true) {
    return this.#networkAgent.invoke_enableReportingApi({ enable });
  }
  async loadNetworkResource(frameId, url, options) {
    const result = await this.#networkAgent.invoke_loadNetworkResource({ frameId: frameId ?? void 0, url, options });
    if (result.getError()) {
      throw new Error(result.getError());
    }
    return result.resource;
  }
  clearRequests() {
    this.dispatcher.clearRequests();
  }
};
var Events3 = /* @__PURE__ */ ((Events210) => {
  Events210["RequestStarted"] = "RequestStarted";
  Events210["RequestUpdated"] = "RequestUpdated";
  Events210["RequestFinished"] = "RequestFinished";
  Events210["RequestUpdateDropped"] = "RequestUpdateDropped";
  Events210["ResponseReceived"] = "ResponseReceived";
  Events210["MessageGenerated"] = "MessageGenerated";
  Events210["RequestRedirected"] = "RequestRedirected";
  Events210["LoadingFinished"] = "LoadingFinished";
  Events210["ReportingApiReportAdded"] = "ReportingApiReportAdded";
  Events210["ReportingApiReportUpdated"] = "ReportingApiReportUpdated";
  Events210["ReportingApiEndpointsChangedForOrigin"] = "ReportingApiEndpointsChangedForOrigin";
  return Events210;
})(Events3 || {});
var NoThrottlingConditions = {
  title: i18nLazyString(UIStrings.noThrottling),
  i18nTitleKey: UIStrings.noThrottling,
  download: -1,
  upload: -1,
  latency: 0
};
var OfflineConditions = {
  title: i18nLazyString(UIStrings.offline),
  i18nTitleKey: UIStrings.offline,
  download: 0,
  upload: 0,
  latency: 0
};
var slow3GTargetLatency = 400;
var Slow3GConditions = {
  title: i18nLazyString(UIStrings.slowG),
  i18nTitleKey: UIStrings.slowG,
  // ~500Kbps down
  download: 500 * 1e3 / 8 * 0.8,
  // ~500Kbps up
  upload: 500 * 1e3 / 8 * 0.8,
  // 400ms RTT
  latency: slow3GTargetLatency * 5,
  targetLatency: slow3GTargetLatency
};
var slow4GTargetLatency = 150;
var Slow4GConditions = {
  title: i18nLazyString(UIStrings.fastG),
  i18nTitleKey: UIStrings.fastG,
  // ~1.6 Mbps down
  download: 1.6 * 1e3 * 1e3 / 8 * 0.9,
  // ~0.75 Mbps up
  upload: 750 * 1e3 / 8 * 0.9,
  // 150ms RTT
  latency: slow4GTargetLatency * 3.75,
  targetLatency: slow4GTargetLatency
};
var fast4GTargetLatency = 60;
var Fast4GConditions = {
  title: i18nLazyString(UIStrings.fast4G),
  i18nTitleKey: UIStrings.fast4G,
  // 9 Mbps down
  download: 9 * 1e3 * 1e3 / 8 * 0.9,
  // 1.5 Mbps up
  upload: 1.5 * 1e3 * 1e3 / 8 * 0.9,
  // 60ms RTT
  latency: fast4GTargetLatency * 2.75,
  targetLatency: fast4GTargetLatency
};
var MAX_EAGER_POST_REQUEST_BODY_LENGTH = 64 * 1024;
var FetchDispatcher = class {
  #fetchAgent;
  #manager;
  constructor(agent, manager) {
    this.#fetchAgent = agent;
    this.#manager = manager;
  }
  requestPaused({ requestId, request, resourceType, responseStatusCode, responseHeaders, networkId }) {
    const networkRequest = networkId ? this.#manager.requestForId(networkId) : null;
    if (networkRequest?.originalResponseHeaders.length === 0 && responseHeaders) {
      networkRequest.originalResponseHeaders = responseHeaders;
    }
    void MultitargetNetworkManager.instance().requestIntercepted(new InterceptedRequest(
      this.#fetchAgent,
      request,
      resourceType,
      requestId,
      networkRequest,
      responseStatusCode,
      responseHeaders
    ));
  }
  authRequired({}) {
  }
};
var NetworkDispatcher = class {
  #manager;
  #requestsById;
  #requestsByURL;
  #requestsByLoaderId;
  #requestIdToExtraInfoBuilder;
  #requestIdToTrustTokenEvent;
  constructor(manager) {
    this.#manager = manager;
    this.#requestsById = /* @__PURE__ */ new Map();
    this.#requestsByURL = /* @__PURE__ */ new Map();
    this.#requestsByLoaderId = /* @__PURE__ */ new Map();
    this.#requestIdToExtraInfoBuilder = /* @__PURE__ */ new Map();
    this.#requestIdToTrustTokenEvent = /* @__PURE__ */ new Map();
    MultitargetNetworkManager.instance().addEventListener(
      MultitargetNetworkManager.Events.REQUEST_INTERCEPTED,
      this.#markAsIntercepted.bind(this)
    );
  }
  #markAsIntercepted(event) {
    const request = this.requestForId(event.data);
    if (request) {
      request.setWasIntercepted(true);
    }
  }
  headersMapToHeadersArray(headersMap) {
    const result = [];
    for (const name in headersMap) {
      const values = headersMap[name].split("\n");
      for (let i = 0; i < values.length; ++i) {
        result.push({ name, value: values[i] });
      }
    }
    return result;
  }
  updateNetworkRequestWithRequest(networkRequest, request) {
    networkRequest.requestMethod = request.method;
    networkRequest.setRequestHeaders(this.headersMapToHeadersArray(request.headers));
    networkRequest.setRequestFormData(Boolean(request.hasPostData), request.postData || null);
    networkRequest.setInitialPriority(request.initialPriority);
    networkRequest.mixedContentType = request.mixedContentType || Security.MixedContentType.None;
    networkRequest.setReferrerPolicy(request.referrerPolicy);
    networkRequest.setIsSameSite(request.isSameSite || false);
  }
  updateNetworkRequestWithResponse(networkRequest, response) {
    if (response.url && networkRequest.url() !== response.url) {
      networkRequest.setUrl(response.url);
    }
    networkRequest.mimeType = response.mimeType;
    networkRequest.setCharset(response.charset);
    if (!networkRequest.statusCode || networkRequest.wasIntercepted()) {
      networkRequest.statusCode = response.status;
    }
    if (!networkRequest.statusText || networkRequest.wasIntercepted()) {
      networkRequest.statusText = response.statusText;
    }
    if (!networkRequest.hasExtraResponseInfo() || networkRequest.wasIntercepted()) {
      networkRequest.responseHeaders = this.headersMapToHeadersArray(response.headers);
    }
    if (response.encodedDataLength >= 0) {
      networkRequest.setTransferSize(response.encodedDataLength);
    }
    if (response.requestHeaders && !networkRequest.hasExtraRequestInfo()) {
      networkRequest.setRequestHeaders(this.headersMapToHeadersArray(response.requestHeaders));
      networkRequest.setRequestHeadersText(response.requestHeadersText || "");
    }
    networkRequest.connectionReused = response.connectionReused;
    networkRequest.connectionId = String(response.connectionId);
    if (response.remoteIPAddress) {
      networkRequest.setRemoteAddress(response.remoteIPAddress, response.remotePort || -1);
    }
    if (response.fromServiceWorker) {
      networkRequest.fetchedViaServiceWorker = true;
    }
    if (response.fromDiskCache) {
      networkRequest.setFromDiskCache();
    }
    if (response.fromPrefetchCache) {
      networkRequest.setFromPrefetchCache();
    }
    if (response.fromEarlyHints) {
      networkRequest.setFromEarlyHints();
    }
    if (response.cacheStorageCacheName) {
      networkRequest.setResponseCacheStorageCacheName(response.cacheStorageCacheName);
    }
    if (response.serviceWorkerRouterInfo) {
      networkRequest.serviceWorkerRouterInfo = response.serviceWorkerRouterInfo;
    }
    if (response.responseTime) {
      networkRequest.setResponseRetrievalTime(new Date(response.responseTime));
    }
    networkRequest.timing = response.timing;
    networkRequest.protocol = response.protocol || "";
    networkRequest.alternateProtocolUsage = response.alternateProtocolUsage;
    if (response.serviceWorkerResponseSource) {
      networkRequest.setServiceWorkerResponseSource(response.serviceWorkerResponseSource);
    }
    networkRequest.setSecurityState(response.securityState);
    if (response.securityDetails) {
      networkRequest.setSecurityDetails(response.securityDetails);
    }
    const newResourceType = Common5.ResourceType.ResourceType.fromMimeTypeOverride(networkRequest.mimeType);
    if (newResourceType) {
      networkRequest.setResourceType(newResourceType);
    }
    if (networkRequest.responseReceivedPromiseResolve) {
      networkRequest.responseReceivedPromiseResolve();
    } else {
      networkRequest.responseReceivedPromise = Promise.resolve();
    }
  }
  requestForId(id) {
    return this.#requestsById.get(id) || null;
  }
  requestForURL(url) {
    return this.#requestsByURL.get(url) || null;
  }
  requestForLoaderId(loaderId) {
    return this.#requestsByLoaderId.get(loaderId) || null;
  }
  resourceChangedPriority({ requestId, newPriority }) {
    const networkRequest = this.#requestsById.get(requestId);
    if (networkRequest) {
      networkRequest.setPriority(newPriority);
    }
  }
  signedExchangeReceived({ requestId, info }) {
    let networkRequest = this.#requestsById.get(requestId);
    if (!networkRequest) {
      networkRequest = this.#requestsByURL.get(info.outerResponse.url);
      if (!networkRequest) {
        return;
      }
    }
    networkRequest.setSignedExchangeInfo(info);
    networkRequest.setResourceType(Common5.ResourceType.resourceTypes.SignedExchange);
    this.updateNetworkRequestWithResponse(networkRequest, info.outerResponse);
    this.updateNetworkRequest(networkRequest);
    this.#manager.dispatchEventToListeners(
      "ResponseReceived",
      { request: networkRequest, response: info.outerResponse }
    );
  }
  requestWillBeSent({
    requestId,
    loaderId,
    documentURL,
    request,
    timestamp,
    wallTime,
    initiator,
    redirectResponse,
    type,
    frameId,
    hasUserGesture
  }) {
    let networkRequest = this.#requestsById.get(requestId);
    if (networkRequest) {
      if (!redirectResponse) {
        return;
      }
      if (!networkRequest.signedExchangeInfo()) {
        this.responseReceived({
          requestId,
          loaderId,
          timestamp,
          type: type || Network.ResourceType.Other,
          response: redirectResponse,
          hasExtraInfo: false,
          frameId
        });
      }
      networkRequest = this.appendRedirect(requestId, timestamp, request.url);
      this.#manager.dispatchEventToListeners("RequestRedirected", networkRequest);
    } else {
      networkRequest = NetworkRequest.create(
        requestId,
        request.url,
        documentURL,
        frameId ?? null,
        loaderId,
        initiator,
        hasUserGesture
      );
      requestToManagerMap.set(networkRequest, this.#manager);
    }
    networkRequest.hasNetworkData = true;
    this.updateNetworkRequestWithRequest(networkRequest, request);
    networkRequest.setIssueTime(timestamp, wallTime);
    networkRequest.setResourceType(
      type ? Common5.ResourceType.resourceTypes[type] : Common5.ResourceType.resourceTypes.Other
    );
    if (request.trustTokenParams) {
      networkRequest.setTrustTokenParams(request.trustTokenParams);
    }
    const maybeTrustTokenEvent = this.#requestIdToTrustTokenEvent.get(requestId);
    if (maybeTrustTokenEvent) {
      networkRequest.setTrustTokenOperationDoneEvent(maybeTrustTokenEvent);
      this.#requestIdToTrustTokenEvent.delete(requestId);
    }
    this.getExtraInfoBuilder(requestId).addRequest(networkRequest);
    this.startNetworkRequest(networkRequest, request);
  }
  requestServedFromCache({ requestId }) {
    const networkRequest = this.#requestsById.get(requestId);
    if (!networkRequest) {
      return;
    }
    networkRequest.setFromMemoryCache();
  }
  responseReceived({ requestId, loaderId, timestamp, type, response, frameId }) {
    const networkRequest = this.#requestsById.get(requestId);
    const lowercaseHeaders = NetworkManager.lowercaseHeaders(response.headers);
    if (!networkRequest) {
      const lastModifiedHeader = lowercaseHeaders["last-modified"];
      const eventData = {
        url: response.url,
        frameId: frameId ?? null,
        loaderId,
        resourceType: type,
        mimeType: response.mimeType,
        lastModified: lastModifiedHeader ? new Date(lastModifiedHeader) : null
      };
      this.#manager.dispatchEventToListeners("RequestUpdateDropped", eventData);
      return;
    }
    networkRequest.responseReceivedTime = timestamp;
    networkRequest.setResourceType(Common5.ResourceType.resourceTypes[type]);
    this.updateNetworkRequestWithResponse(networkRequest, response);
    this.updateNetworkRequest(networkRequest);
    this.#manager.dispatchEventToListeners("ResponseReceived", { request: networkRequest, response });
  }
  dataReceived(event) {
    let networkRequest = this.#requestsById.get(event.requestId);
    if (!networkRequest) {
      networkRequest = this.maybeAdoptMainResourceRequest(event.requestId);
    }
    if (!networkRequest) {
      return;
    }
    networkRequest.addDataReceivedEvent(event);
    this.updateNetworkRequest(networkRequest);
  }
  loadingFinished({ requestId, timestamp: finishTime, encodedDataLength }) {
    let networkRequest = this.#requestsById.get(requestId);
    if (!networkRequest) {
      networkRequest = this.maybeAdoptMainResourceRequest(requestId);
    }
    if (!networkRequest) {
      return;
    }
    this.getExtraInfoBuilder(requestId).finished();
    this.finishNetworkRequest(networkRequest, finishTime, encodedDataLength);
    this.#manager.dispatchEventToListeners("LoadingFinished", networkRequest);
  }
  loadingFailed({
    requestId,
    timestamp: time,
    type: resourceType,
    errorText: localizedDescription,
    canceled,
    blockedReason,
    corsErrorStatus
  }) {
    const networkRequest = this.#requestsById.get(requestId);
    if (!networkRequest) {
      return;
    }
    networkRequest.failed = true;
    networkRequest.setResourceType(Common5.ResourceType.resourceTypes[resourceType]);
    networkRequest.canceled = Boolean(canceled);
    if (blockedReason) {
      networkRequest.setBlockedReason(blockedReason);
      if (blockedReason === Network.BlockedReason.Inspector) {
        const message = i18nString(UIStrings.requestWasBlockedByDevtoolsS, { PH1: networkRequest.url() });
        this.#manager.dispatchEventToListeners("MessageGenerated", { message, requestId, warning: true });
      }
    }
    if (corsErrorStatus) {
      networkRequest.setCorsErrorStatus(corsErrorStatus);
    }
    networkRequest.localizedFailDescription = localizedDescription;
    this.getExtraInfoBuilder(requestId).finished();
    this.finishNetworkRequest(networkRequest, time, -1);
  }
  webSocketCreated({ requestId, url: requestURL, initiator }) {
    const networkRequest = NetworkRequest.createForWebSocket(requestId, requestURL, initiator);
    requestToManagerMap.set(networkRequest, this.#manager);
    networkRequest.setResourceType(Common5.ResourceType.resourceTypes.WebSocket);
    this.startNetworkRequest(networkRequest, null);
  }
  webSocketWillSendHandshakeRequest({ requestId, timestamp: time, wallTime, request }) {
    const networkRequest = this.#requestsById.get(requestId);
    if (!networkRequest) {
      return;
    }
    networkRequest.requestMethod = "GET";
    networkRequest.setRequestHeaders(this.headersMapToHeadersArray(request.headers));
    networkRequest.setIssueTime(time, wallTime);
    this.updateNetworkRequest(networkRequest);
  }
  webSocketHandshakeResponseReceived({ requestId, timestamp: time, response }) {
    const networkRequest = this.#requestsById.get(requestId);
    if (!networkRequest) {
      return;
    }
    networkRequest.statusCode = response.status;
    networkRequest.statusText = response.statusText;
    networkRequest.responseHeaders = this.headersMapToHeadersArray(response.headers);
    networkRequest.responseHeadersText = response.headersText || "";
    if (response.requestHeaders) {
      networkRequest.setRequestHeaders(this.headersMapToHeadersArray(response.requestHeaders));
    }
    if (response.requestHeadersText) {
      networkRequest.setRequestHeadersText(response.requestHeadersText);
    }
    networkRequest.responseReceivedTime = time;
    networkRequest.protocol = "websocket";
    this.updateNetworkRequest(networkRequest);
  }
  webSocketFrameReceived({ requestId, timestamp: time, response }) {
    const networkRequest = this.#requestsById.get(requestId);
    if (!networkRequest) {
      return;
    }
    networkRequest.addProtocolFrame(response, time, false);
    networkRequest.responseReceivedTime = time;
    this.updateNetworkRequest(networkRequest);
  }
  webSocketFrameSent({ requestId, timestamp: time, response }) {
    const networkRequest = this.#requestsById.get(requestId);
    if (!networkRequest) {
      return;
    }
    networkRequest.addProtocolFrame(response, time, true);
    networkRequest.responseReceivedTime = time;
    this.updateNetworkRequest(networkRequest);
  }
  webSocketFrameError({ requestId, timestamp: time, errorMessage }) {
    const networkRequest = this.#requestsById.get(requestId);
    if (!networkRequest) {
      return;
    }
    networkRequest.addProtocolFrameError(errorMessage, time);
    networkRequest.responseReceivedTime = time;
    this.updateNetworkRequest(networkRequest);
  }
  webSocketClosed({ requestId, timestamp: time }) {
    const networkRequest = this.#requestsById.get(requestId);
    if (!networkRequest) {
      return;
    }
    this.finishNetworkRequest(networkRequest, time, -1);
  }
  eventSourceMessageReceived({ requestId, timestamp: time, eventName, eventId, data }) {
    const networkRequest = this.#requestsById.get(requestId);
    if (!networkRequest) {
      return;
    }
    networkRequest.addEventSourceMessage(time, eventName, eventId, data);
  }
  requestIntercepted({}) {
  }
  requestWillBeSentExtraInfo({ requestId, associatedCookies, headers, clientSecurityState, connectTiming, siteHasCookieInOtherPartition }) {
    const blockedRequestCookies = [];
    const includedRequestCookies = [];
    for (const { blockedReasons, exemptionReason, cookie } of associatedCookies) {
      if (blockedReasons.length === 0) {
        includedRequestCookies.push({ exemptionReason, cookie: Cookie.fromProtocolCookie(cookie) });
      } else {
        blockedRequestCookies.push({ blockedReasons, cookie: Cookie.fromProtocolCookie(cookie) });
      }
    }
    const extraRequestInfo = {
      blockedRequestCookies,
      includedRequestCookies,
      requestHeaders: this.headersMapToHeadersArray(headers),
      clientSecurityState,
      connectTiming,
      siteHasCookieInOtherPartition
    };
    this.getExtraInfoBuilder(requestId).addRequestExtraInfo(extraRequestInfo);
  }
  responseReceivedEarlyHints({
    requestId,
    headers
  }) {
    this.getExtraInfoBuilder(requestId).setEarlyHintsHeaders(this.headersMapToHeadersArray(headers));
  }
  responseReceivedExtraInfo({
    requestId,
    blockedCookies,
    headers,
    headersText,
    resourceIPAddressSpace,
    statusCode,
    cookiePartitionKey,
    cookiePartitionKeyOpaque,
    exemptedCookies
  }) {
    const extraResponseInfo = {
      blockedResponseCookies: blockedCookies.map((blockedCookie) => ({
        blockedReasons: blockedCookie.blockedReasons,
        cookieLine: blockedCookie.cookieLine,
        cookie: blockedCookie.cookie ? Cookie.fromProtocolCookie(blockedCookie.cookie) : null
      })),
      responseHeaders: this.headersMapToHeadersArray(headers),
      responseHeadersText: headersText,
      resourceIPAddressSpace,
      statusCode,
      cookiePartitionKey,
      cookiePartitionKeyOpaque,
      exemptedResponseCookies: exemptedCookies?.map((exemptedCookie) => ({
        cookie: Cookie.fromProtocolCookie(exemptedCookie.cookie),
        cookieLine: exemptedCookie.cookieLine,
        exemptionReason: exemptedCookie.exemptionReason
      }))
    };
    this.getExtraInfoBuilder(requestId).addResponseExtraInfo(extraResponseInfo);
  }
  getExtraInfoBuilder(requestId) {
    let builder;
    if (!this.#requestIdToExtraInfoBuilder.has(requestId)) {
      builder = new ExtraInfoBuilder();
      this.#requestIdToExtraInfoBuilder.set(requestId, builder);
    } else {
      builder = this.#requestIdToExtraInfoBuilder.get(requestId);
    }
    return builder;
  }
  appendRedirect(requestId, time, redirectURL) {
    const originalNetworkRequest = this.#requestsById.get(requestId);
    if (!originalNetworkRequest) {
      throw new Error(`Could not find original network request for ${requestId}`);
    }
    let redirectCount = 0;
    for (let redirect = originalNetworkRequest.redirectSource(); redirect; redirect = redirect.redirectSource()) {
      redirectCount++;
    }
    originalNetworkRequest.markAsRedirect(redirectCount);
    this.finishNetworkRequest(originalNetworkRequest, time, -1);
    const newNetworkRequest = NetworkRequest.create(
      requestId,
      redirectURL,
      originalNetworkRequest.documentURL,
      originalNetworkRequest.frameId,
      originalNetworkRequest.loaderId,
      originalNetworkRequest.initiator(),
      originalNetworkRequest.hasUserGesture() ?? void 0
    );
    requestToManagerMap.set(newNetworkRequest, this.#manager);
    newNetworkRequest.setRedirectSource(originalNetworkRequest);
    originalNetworkRequest.setRedirectDestination(newNetworkRequest);
    return newNetworkRequest;
  }
  maybeAdoptMainResourceRequest(requestId) {
    const request = MultitargetNetworkManager.instance().inflightMainResourceRequests.get(requestId);
    if (!request) {
      return null;
    }
    const oldDispatcher = NetworkManager.forRequest(request).dispatcher;
    oldDispatcher.#requestsById.delete(requestId);
    oldDispatcher.#requestsByURL.delete(request.url());
    const loaderId = request.loaderId;
    if (loaderId) {
      oldDispatcher.#requestsByLoaderId.delete(loaderId);
    }
    const builder = oldDispatcher.#requestIdToExtraInfoBuilder.get(requestId);
    oldDispatcher.#requestIdToExtraInfoBuilder.delete(requestId);
    this.#requestsById.set(requestId, request);
    this.#requestsByURL.set(request.url(), request);
    if (loaderId) {
      this.#requestsByLoaderId.set(loaderId, request);
    }
    if (builder) {
      this.#requestIdToExtraInfoBuilder.set(requestId, builder);
    }
    requestToManagerMap.set(request, this.#manager);
    return request;
  }
  startNetworkRequest(networkRequest, originalRequest) {
    this.#requestsById.set(networkRequest.requestId(), networkRequest);
    this.#requestsByURL.set(networkRequest.url(), networkRequest);
    const loaderId = networkRequest.loaderId;
    if (loaderId) {
      this.#requestsByLoaderId.set(loaderId, networkRequest);
    }
    if (networkRequest.loaderId === networkRequest.requestId()) {
      MultitargetNetworkManager.instance().inflightMainResourceRequests.set(networkRequest.requestId(), networkRequest);
    }
    this.#manager.dispatchEventToListeners("RequestStarted", { request: networkRequest, originalRequest });
  }
  updateNetworkRequest(networkRequest) {
    this.#manager.dispatchEventToListeners("RequestUpdated", networkRequest);
  }
  finishNetworkRequest(networkRequest, finishTime, encodedDataLength) {
    networkRequest.endTime = finishTime;
    networkRequest.finished = true;
    if (encodedDataLength >= 0) {
      const redirectSource = networkRequest.redirectSource();
      if (redirectSource && redirectSource.signedExchangeInfo()) {
        networkRequest.setTransferSize(0);
        redirectSource.setTransferSize(encodedDataLength);
        this.updateNetworkRequest(redirectSource);
      } else {
        networkRequest.setTransferSize(encodedDataLength);
      }
    }
    this.#manager.dispatchEventToListeners("RequestFinished", networkRequest);
    MultitargetNetworkManager.instance().inflightMainResourceRequests.delete(networkRequest.requestId());
    if (Common5.Settings.Settings.instance().moduleSetting("monitoring-xhr-enabled").get() && networkRequest.resourceType().category() === Common5.ResourceType.resourceCategories.XHR) {
      let message;
      const failedToLoad = networkRequest.failed || networkRequest.hasErrorStatusCode();
      if (failedToLoad) {
        message = i18nString(
          UIStrings.sFailedLoadingSS,
          { PH1: networkRequest.resourceType().title(), PH2: networkRequest.requestMethod, PH3: networkRequest.url() }
        );
      } else {
        message = i18nString(
          UIStrings.sFinishedLoadingSS,
          { PH1: networkRequest.resourceType().title(), PH2: networkRequest.requestMethod, PH3: networkRequest.url() }
        );
      }
      this.#manager.dispatchEventToListeners(
        "MessageGenerated",
        { message, requestId: networkRequest.requestId(), warning: false }
      );
    }
  }
  clearRequests() {
    for (const [requestId, request] of this.#requestsById) {
      if (request.finished) {
        this.#requestsById.delete(requestId);
      }
    }
    for (const [requestURL, request] of this.#requestsByURL) {
      if (request.finished) {
        this.#requestsByURL.delete(requestURL);
      }
    }
    for (const [requestLoaderId, request] of this.#requestsByLoaderId) {
      if (request.finished) {
        this.#requestsByLoaderId.delete(requestLoaderId);
      }
    }
    for (const [requestId, builder] of this.#requestIdToExtraInfoBuilder) {
      if (builder.isFinished()) {
        this.#requestIdToExtraInfoBuilder.delete(requestId);
      }
    }
  }
  webTransportCreated({ transportId, url: requestURL, timestamp: time, initiator }) {
    const networkRequest = NetworkRequest.createForWebSocket(transportId, requestURL, initiator);
    networkRequest.hasNetworkData = true;
    requestToManagerMap.set(networkRequest, this.#manager);
    networkRequest.setResourceType(Common5.ResourceType.resourceTypes.WebTransport);
    networkRequest.setIssueTime(time, 0);
    this.startNetworkRequest(networkRequest, null);
  }
  webTransportConnectionEstablished({ transportId, timestamp: time }) {
    const networkRequest = this.#requestsById.get(transportId);
    if (!networkRequest) {
      return;
    }
    networkRequest.responseReceivedTime = time;
    networkRequest.endTime = time + 1e-3;
    this.updateNetworkRequest(networkRequest);
  }
  webTransportClosed({ transportId, timestamp: time }) {
    const networkRequest = this.#requestsById.get(transportId);
    if (!networkRequest) {
      return;
    }
    networkRequest.endTime = time;
    this.finishNetworkRequest(networkRequest, time, 0);
  }
  trustTokenOperationDone(event) {
    const request = this.#requestsById.get(event.requestId);
    if (!request) {
      this.#requestIdToTrustTokenEvent.set(event.requestId, event);
      return;
    }
    request.setTrustTokenOperationDoneEvent(event);
  }
  subresourceWebBundleMetadataReceived({ requestId, urls }) {
    const extraInfoBuilder = this.getExtraInfoBuilder(requestId);
    extraInfoBuilder.setWebBundleInfo({ resourceUrls: urls });
    const finalRequest = extraInfoBuilder.finalRequest();
    if (finalRequest) {
      this.updateNetworkRequest(finalRequest);
    }
  }
  subresourceWebBundleMetadataError({ requestId, errorMessage }) {
    const extraInfoBuilder = this.getExtraInfoBuilder(requestId);
    extraInfoBuilder.setWebBundleInfo({ errorMessage });
    const finalRequest = extraInfoBuilder.finalRequest();
    if (finalRequest) {
      this.updateNetworkRequest(finalRequest);
    }
  }
  subresourceWebBundleInnerResponseParsed({ innerRequestId, bundleRequestId }) {
    const extraInfoBuilder = this.getExtraInfoBuilder(innerRequestId);
    extraInfoBuilder.setWebBundleInnerRequestInfo({ bundleRequestId });
    const finalRequest = extraInfoBuilder.finalRequest();
    if (finalRequest) {
      this.updateNetworkRequest(finalRequest);
    }
  }
  subresourceWebBundleInnerResponseError({ innerRequestId, errorMessage }) {
    const extraInfoBuilder = this.getExtraInfoBuilder(innerRequestId);
    extraInfoBuilder.setWebBundleInnerRequestInfo({ errorMessage });
    const finalRequest = extraInfoBuilder.finalRequest();
    if (finalRequest) {
      this.updateNetworkRequest(finalRequest);
    }
  }
  reportingApiReportAdded(data) {
    this.#manager.dispatchEventToListeners("ReportingApiReportAdded", data.report);
  }
  reportingApiReportUpdated(data) {
    this.#manager.dispatchEventToListeners("ReportingApiReportUpdated", data.report);
  }
  reportingApiEndpointsChangedForOrigin(data) {
    this.#manager.dispatchEventToListeners("ReportingApiEndpointsChangedForOrigin", data);
  }
  policyUpdated() {
  }
  /**
   * @deprecated
   * This method is only kept for usage in a web test.
   */
  createNetworkRequest(requestId, frameId, loaderId, url, documentURL, initiator) {
    const request = NetworkRequest.create(
      requestId,
      url,
      documentURL,
      frameId,
      loaderId,
      initiator
    );
    requestToManagerMap.set(request, this.#manager);
    return request;
  }
};
var multiTargetNetworkManagerInstance;
var MultitargetNetworkManager = class _MultitargetNetworkManager extends Common5.ObjectWrapper.ObjectWrapper {
  #userAgentOverrideInternal;
  #userAgentMetadataOverride;
  #customAcceptedEncodings;
  #networkAgents;
  #fetchAgents;
  inflightMainResourceRequests;
  #networkConditionsInternal;
  #updatingInterceptionPatternsPromise;
  #blockingEnabledSetting;
  #blockedPatternsSetting;
  #effectiveBlockedURLs;
  #urlsForRequestInterceptor;
  #extraHeaders;
  #customUserAgent;
  constructor() {
    super();
    this.#userAgentOverrideInternal = "";
    this.#userAgentMetadataOverride = null;
    this.#customAcceptedEncodings = null;
    this.#networkAgents = /* @__PURE__ */ new Set();
    this.#fetchAgents = /* @__PURE__ */ new Set();
    this.inflightMainResourceRequests = /* @__PURE__ */ new Map();
    this.#networkConditionsInternal = NoThrottlingConditions;
    this.#updatingInterceptionPatternsPromise = null;
    const blockedPatternChanged = () => {
      this.updateBlockedPatterns();
      this.dispatchEventToListeners(_MultitargetNetworkManager.Events.BLOCKED_PATTERNS_CHANGED);
    };
    this.#blockingEnabledSetting = Common5.Settings.Settings.instance().moduleSetting("request-blocking-enabled");
    this.#blockingEnabledSetting.addChangeListener(blockedPatternChanged);
    this.#blockedPatternsSetting = Common5.Settings.Settings.instance().createSetting("network-blocked-patterns", []);
    this.#blockedPatternsSetting.addChangeListener(blockedPatternChanged);
    this.#effectiveBlockedURLs = [];
    this.updateBlockedPatterns();
    this.#urlsForRequestInterceptor = new Platform3.MapUtilities.Multimap();
    TargetManager.instance().observeModels(NetworkManager, this);
  }
  static instance(opts = { forceNew: null }) {
    const { forceNew } = opts;
    if (!multiTargetNetworkManagerInstance || forceNew) {
      multiTargetNetworkManagerInstance = new _MultitargetNetworkManager();
    }
    return multiTargetNetworkManagerInstance;
  }
  static dispose() {
    multiTargetNetworkManagerInstance = null;
  }
  static getChromeVersion() {
    const chromeRegex = /(?:^|\W)(?:Chrome|HeadlessChrome)\/(\S+)/;
    const chromeMatch = navigator.userAgent.match(chromeRegex);
    if (chromeMatch && chromeMatch.length > 1) {
      return chromeMatch[1];
    }
    return "";
  }
  static patchUserAgentWithChromeVersion(uaString) {
    const chromeVersion = _MultitargetNetworkManager.getChromeVersion();
    if (chromeVersion.length > 0) {
      const additionalAppVersion = chromeVersion.split(".", 1)[0] + ".0.100.0";
      return Platform3.StringUtilities.sprintf(uaString, chromeVersion, additionalAppVersion);
    }
    return uaString;
  }
  static patchUserAgentMetadataWithChromeVersion(userAgentMetadata) {
    if (!userAgentMetadata.brands) {
      return;
    }
    const chromeVersion = _MultitargetNetworkManager.getChromeVersion();
    if (chromeVersion.length === 0) {
      return;
    }
    const majorVersion = chromeVersion.split(".", 1)[0];
    for (const brand of userAgentMetadata.brands) {
      if (brand.version.includes("%s")) {
        brand.version = Platform3.StringUtilities.sprintf(brand.version, majorVersion);
      }
    }
    if (userAgentMetadata.fullVersion) {
      if (userAgentMetadata.fullVersion.includes("%s")) {
        userAgentMetadata.fullVersion = Platform3.StringUtilities.sprintf(userAgentMetadata.fullVersion, chromeVersion);
      }
    }
  }
  modelAdded(networkManager) {
    const networkAgent = networkManager.target().networkAgent();
    const fetchAgent = networkManager.target().fetchAgent();
    if (this.#extraHeaders) {
      void networkAgent.invoke_setExtraHTTPHeaders({ headers: this.#extraHeaders });
    }
    if (this.currentUserAgent()) {
      void networkAgent.invoke_setUserAgentOverride(
        { userAgent: this.currentUserAgent(), userAgentMetadata: this.#userAgentMetadataOverride || void 0 }
      );
    }
    if (this.#effectiveBlockedURLs.length) {
      void networkAgent.invoke_setBlockedURLs({ urls: this.#effectiveBlockedURLs });
    }
    if (this.isIntercepting()) {
      void fetchAgent.invoke_enable({ patterns: this.#urlsForRequestInterceptor.valuesArray() });
    }
    if (this.#customAcceptedEncodings === null) {
      void networkAgent.invoke_clearAcceptedEncodingsOverride();
    } else {
      void networkAgent.invoke_setAcceptedEncodings({ encodings: this.#customAcceptedEncodings });
    }
    this.#networkAgents.add(networkAgent);
    this.#fetchAgents.add(fetchAgent);
    if (this.isThrottling()) {
      this.updateNetworkConditions(networkAgent);
    }
  }
  modelRemoved(networkManager) {
    for (const entry of this.inflightMainResourceRequests) {
      const manager = NetworkManager.forRequest(entry[1]);
      if (manager !== networkManager) {
        continue;
      }
      this.inflightMainResourceRequests.delete(entry[0]);
    }
    this.#networkAgents.delete(networkManager.target().networkAgent());
    this.#fetchAgents.delete(networkManager.target().fetchAgent());
  }
  isThrottling() {
    return this.#networkConditionsInternal.download >= 0 || this.#networkConditionsInternal.upload >= 0 || this.#networkConditionsInternal.latency > 0;
  }
  isOffline() {
    return !this.#networkConditionsInternal.download && !this.#networkConditionsInternal.upload;
  }
  setNetworkConditions(conditions) {
    this.#networkConditionsInternal = conditions;
    for (const agent of this.#networkAgents) {
      this.updateNetworkConditions(agent);
    }
    this.dispatchEventToListeners(_MultitargetNetworkManager.Events.CONDITIONS_CHANGED);
  }
  networkConditions() {
    return this.#networkConditionsInternal;
  }
  updateNetworkConditions(networkAgent) {
    const conditions = this.#networkConditionsInternal;
    if (!this.isThrottling()) {
      void networkAgent.invoke_emulateNetworkConditions({
        offline: false,
        latency: 0,
        downloadThroughput: 0,
        uploadThroughput: 0
      });
    } else {
      void networkAgent.invoke_emulateNetworkConditions({
        offline: this.isOffline(),
        latency: conditions.latency,
        downloadThroughput: conditions.download < 0 ? 0 : conditions.download,
        uploadThroughput: conditions.upload < 0 ? 0 : conditions.upload,
        packetLoss: (conditions.packetLoss ?? 0) < 0 ? 0 : conditions.packetLoss,
        packetQueueLength: conditions.packetQueueLength,
        packetReordering: conditions.packetReordering,
        connectionType: NetworkManager.connectionType(conditions)
      });
    }
  }
  setExtraHTTPHeaders(headers) {
    this.#extraHeaders = headers;
    for (const agent of this.#networkAgents) {
      void agent.invoke_setExtraHTTPHeaders({ headers: this.#extraHeaders });
    }
  }
  currentUserAgent() {
    return this.#customUserAgent ? this.#customUserAgent : this.#userAgentOverrideInternal;
  }
  updateUserAgentOverride() {
    const userAgent = this.currentUserAgent();
    for (const agent of this.#networkAgents) {
      void agent.invoke_setUserAgentOverride(
        { userAgent, userAgentMetadata: this.#userAgentMetadataOverride || void 0 }
      );
    }
  }
  setUserAgentOverride(userAgent, userAgentMetadataOverride) {
    const uaChanged = this.#userAgentOverrideInternal !== userAgent;
    this.#userAgentOverrideInternal = userAgent;
    if (!this.#customUserAgent) {
      this.#userAgentMetadataOverride = userAgentMetadataOverride;
      this.updateUserAgentOverride();
    } else {
      this.#userAgentMetadataOverride = null;
    }
    if (uaChanged) {
      this.dispatchEventToListeners(_MultitargetNetworkManager.Events.USER_AGENT_CHANGED);
    }
  }
  userAgentOverride() {
    return this.#userAgentOverrideInternal;
  }
  setCustomUserAgentOverride(userAgent, userAgentMetadataOverride = null) {
    this.#customUserAgent = userAgent;
    this.#userAgentMetadataOverride = userAgentMetadataOverride;
    this.updateUserAgentOverride();
  }
  setCustomAcceptedEncodingsOverride(acceptedEncodings) {
    this.#customAcceptedEncodings = acceptedEncodings;
    this.updateAcceptedEncodingsOverride();
    this.dispatchEventToListeners(_MultitargetNetworkManager.Events.ACCEPTED_ENCODINGS_CHANGED);
  }
  clearCustomAcceptedEncodingsOverride() {
    this.#customAcceptedEncodings = null;
    this.updateAcceptedEncodingsOverride();
    this.dispatchEventToListeners(_MultitargetNetworkManager.Events.ACCEPTED_ENCODINGS_CHANGED);
  }
  isAcceptedEncodingOverrideSet() {
    return this.#customAcceptedEncodings !== null;
  }
  updateAcceptedEncodingsOverride() {
    const customAcceptedEncodings = this.#customAcceptedEncodings;
    for (const agent of this.#networkAgents) {
      if (customAcceptedEncodings === null) {
        void agent.invoke_clearAcceptedEncodingsOverride();
      } else {
        void agent.invoke_setAcceptedEncodings({ encodings: customAcceptedEncodings });
      }
    }
  }
  // TODO(allada) Move all request blocking into interception and let view manage blocking.
  blockedPatterns() {
    return this.#blockedPatternsSetting.get().slice();
  }
  blockingEnabled() {
    return this.#blockingEnabledSetting.get();
  }
  isBlocking() {
    return Boolean(this.#effectiveBlockedURLs.length);
  }
  setBlockedPatterns(patterns) {
    this.#blockedPatternsSetting.set(patterns);
  }
  setBlockingEnabled(enabled) {
    if (this.#blockingEnabledSetting.get() === enabled) {
      return;
    }
    this.#blockingEnabledSetting.set(enabled);
  }
  updateBlockedPatterns() {
    const urls = [];
    if (this.#blockingEnabledSetting.get()) {
      for (const pattern of this.#blockedPatternsSetting.get()) {
        if (pattern.enabled) {
          urls.push(pattern.url);
        }
      }
    }
    if (!urls.length && !this.#effectiveBlockedURLs.length) {
      return;
    }
    this.#effectiveBlockedURLs = urls;
    for (const agent of this.#networkAgents) {
      void agent.invoke_setBlockedURLs({ urls: this.#effectiveBlockedURLs });
    }
  }
  isIntercepting() {
    return Boolean(this.#urlsForRequestInterceptor.size);
  }
  setInterceptionHandlerForPatterns(patterns, requestInterceptor) {
    this.#urlsForRequestInterceptor.deleteAll(requestInterceptor);
    for (const newPattern of patterns) {
      this.#urlsForRequestInterceptor.set(requestInterceptor, newPattern);
    }
    return this.updateInterceptionPatternsOnNextTick();
  }
  updateInterceptionPatternsOnNextTick() {
    if (!this.#updatingInterceptionPatternsPromise) {
      this.#updatingInterceptionPatternsPromise = Promise.resolve().then(this.updateInterceptionPatterns.bind(this));
    }
    return this.#updatingInterceptionPatternsPromise;
  }
  async updateInterceptionPatterns() {
    if (!Common5.Settings.Settings.instance().moduleSetting("cache-disabled").get()) {
      Common5.Settings.Settings.instance().moduleSetting("cache-disabled").set(true);
    }
    this.#updatingInterceptionPatternsPromise = null;
    const promises = [];
    for (const agent of this.#fetchAgents) {
      promises.push(agent.invoke_enable({ patterns: this.#urlsForRequestInterceptor.valuesArray() }));
    }
    this.dispatchEventToListeners(_MultitargetNetworkManager.Events.INTERCEPTORS_CHANGED);
    await Promise.all(promises);
  }
  async requestIntercepted(interceptedRequest) {
    for (const requestInterceptor of this.#urlsForRequestInterceptor.keysArray()) {
      await requestInterceptor(interceptedRequest);
      if (interceptedRequest.hasResponded() && interceptedRequest.networkRequest) {
        this.dispatchEventToListeners(
          _MultitargetNetworkManager.Events.REQUEST_INTERCEPTED,
          interceptedRequest.networkRequest.requestId()
        );
        return;
      }
    }
    if (!interceptedRequest.hasResponded()) {
      interceptedRequest.continueRequestWithoutChange();
    }
  }
  clearBrowserCache() {
    for (const agent of this.#networkAgents) {
      void agent.invoke_clearBrowserCache();
    }
  }
  clearBrowserCookies() {
    for (const agent of this.#networkAgents) {
      void agent.invoke_clearBrowserCookies();
    }
  }
  async getCertificate(origin) {
    const target = TargetManager.instance().primaryPageTarget();
    if (!target) {
      return [];
    }
    const certificate = await target.networkAgent().invoke_getCertificate({ origin });
    if (!certificate) {
      return [];
    }
    return certificate.tableNames;
  }
  async loadResource(url) {
    const headers = {};
    const currentUserAgent = this.currentUserAgent();
    if (currentUserAgent) {
      headers["User-Agent"] = currentUserAgent;
    }
    if (Common5.Settings.Settings.instance().moduleSetting("cache-disabled").get()) {
      headers["Cache-Control"] = "no-cache";
    }
    const allowRemoteFilePaths = Common5.Settings.Settings.instance().moduleSetting("network.enable-remote-file-loading").get();
    return new Promise(
      (resolve) => Host2.ResourceLoader.load(url, headers, (success, _responseHeaders, content, errorDescription) => {
        resolve({ success, content, errorDescription });
      }, allowRemoteFilePaths)
    );
  }
};
((MultitargetNetworkManager2) => {
  let Events210;
  ((Events33) => {
    Events33["BLOCKED_PATTERNS_CHANGED"] = "BlockedPatternsChanged";
    Events33["CONDITIONS_CHANGED"] = "ConditionsChanged";
    Events33["USER_AGENT_CHANGED"] = "UserAgentChanged";
    Events33["INTERCEPTORS_CHANGED"] = "InterceptorsChanged";
    Events33["ACCEPTED_ENCODINGS_CHANGED"] = "AcceptedEncodingsChanged";
    Events33["REQUEST_INTERCEPTED"] = "RequestIntercepted";
    Events33["REQUEST_FULFILLED"] = "RequestFulfilled";
  })(Events210 = MultitargetNetworkManager2.Events || (MultitargetNetworkManager2.Events = {}));
})(MultitargetNetworkManager || (MultitargetNetworkManager = {}));
var InterceptedRequest = class _InterceptedRequest {
  #fetchAgent;
  #hasRespondedInternal;
  request;
  resourceType;
  responseStatusCode;
  responseHeaders;
  requestId;
  networkRequest;
  constructor(fetchAgent, request, resourceType, requestId, networkRequest, responseStatusCode, responseHeaders) {
    this.#fetchAgent = fetchAgent;
    this.#hasRespondedInternal = false;
    this.request = request;
    this.resourceType = resourceType;
    this.responseStatusCode = responseStatusCode;
    this.responseHeaders = responseHeaders;
    this.requestId = requestId;
    this.networkRequest = networkRequest;
  }
  hasResponded() {
    return this.#hasRespondedInternal;
  }
  static mergeSetCookieHeaders(originalSetCookieHeaders, setCookieHeadersFromOverrides) {
    const generateHeaderMap = (headers) => {
      const result = /* @__PURE__ */ new Map();
      for (const header of headers) {
        const match = header.value.match(/^([a-zA-Z0-9!#$%&'*+.^_`|~-]+=)(.*)$/);
        if (match) {
          if (result.has(match[1])) {
            result.get(match[1])?.push(header.value);
          } else {
            result.set(match[1], [header.value]);
          }
        } else {
          if (result.has(header.value)) {
            result.get(header.value)?.push(header.value);
          } else {
            result.set(header.value, [header.value]);
          }
        }
      }
      return result;
    };
    const originalHeadersMap = generateHeaderMap(originalSetCookieHeaders);
    const overridesHeaderMap = generateHeaderMap(setCookieHeadersFromOverrides);
    const mergedHeaders = [];
    for (const [key, headerValues] of originalHeadersMap) {
      if (overridesHeaderMap.has(key)) {
        for (const headerValue of overridesHeaderMap.get(key) || []) {
          mergedHeaders.push({ name: "set-cookie", value: headerValue });
        }
      } else {
        for (const headerValue of headerValues) {
          mergedHeaders.push({ name: "set-cookie", value: headerValue });
        }
      }
    }
    for (const [key, headerValues] of overridesHeaderMap) {
      if (originalHeadersMap.has(key)) {
        continue;
      }
      for (const headerValue of headerValues) {
        mergedHeaders.push({ name: "set-cookie", value: headerValue });
      }
    }
    return mergedHeaders;
  }
  async continueRequestWithContent(contentBlob, encoded, responseHeaders, isBodyOverridden) {
    this.#hasRespondedInternal = true;
    const body = encoded ? await contentBlob.text() : await Common5.Base64.encode(contentBlob).catch((err) => {
      console.error(err);
      return "";
    });
    const responseCode = isBodyOverridden ? 200 : this.responseStatusCode || 200;
    if (this.networkRequest) {
      const originalSetCookieHeaders = this.networkRequest?.originalResponseHeaders.filter((header) => header.name === "set-cookie") || [];
      const setCookieHeadersFromOverrides = responseHeaders.filter((header) => header.name === "set-cookie");
      this.networkRequest.setCookieHeaders = _InterceptedRequest.mergeSetCookieHeaders(originalSetCookieHeaders, setCookieHeadersFromOverrides);
      this.networkRequest.hasOverriddenContent = isBodyOverridden;
    }
    void this.#fetchAgent.invoke_fulfillRequest({ requestId: this.requestId, responseCode, body, responseHeaders });
    MultitargetNetworkManager.instance().dispatchEventToListeners(
      "RequestFulfilled",
      this.request.url
    );
  }
  continueRequestWithoutChange() {
    console.assert(!this.#hasRespondedInternal);
    this.#hasRespondedInternal = true;
    void this.#fetchAgent.invoke_continueRequest({ requestId: this.requestId });
  }
  continueRequestWithError(errorReason) {
    console.assert(!this.#hasRespondedInternal);
    this.#hasRespondedInternal = true;
    void this.#fetchAgent.invoke_failRequest({ requestId: this.requestId, errorReason });
  }
  async responseBody() {
    const response = await this.#fetchAgent.invoke_getResponseBody({ requestId: this.requestId });
    const error = response.getError();
    if (error) {
      return { error };
    }
    const { mimeType, charset } = this.getMimeTypeAndCharset();
    return new TextUtils.ContentData.ContentData(
      response.body,
      response.base64Encoded,
      mimeType ?? "application/octet-stream",
      charset ?? void 0
    );
  }
  isRedirect() {
    return this.responseStatusCode !== void 0 && this.responseStatusCode >= 300 && this.responseStatusCode < 400;
  }
  /**
   * Tries to determine the MIME type and charset for this intercepted request.
   * Looks at the interecepted response headers first (for Content-Type header), then
   * checks the `NetworkRequest` if we have one.
   */
  getMimeTypeAndCharset() {
    for (const header of this.responseHeaders ?? []) {
      if (header.name.toLowerCase() === "content-type") {
        return Platform3.MimeType.parseContentType(header.value);
      }
    }
    const mimeType = this.networkRequest?.mimeType ?? null;
    const charset = this.networkRequest?.charset() ?? null;
    return { mimeType, charset };
  }
};
var ExtraInfoBuilder = class {
  #requests;
  #requestExtraInfos;
  #responseExtraInfos;
  #responseEarlyHintsHeaders;
  #finishedInternal;
  #webBundleInfo;
  #webBundleInnerRequestInfo;
  constructor() {
    this.#requests = [];
    this.#requestExtraInfos = [];
    this.#responseEarlyHintsHeaders = [];
    this.#responseExtraInfos = [];
    this.#finishedInternal = false;
    this.#webBundleInfo = null;
    this.#webBundleInnerRequestInfo = null;
  }
  addRequest(req) {
    this.#requests.push(req);
    this.sync(this.#requests.length - 1);
  }
  addRequestExtraInfo(info) {
    this.#requestExtraInfos.push(info);
    this.sync(this.#requestExtraInfos.length - 1);
  }
  addResponseExtraInfo(info) {
    this.#responseExtraInfos.push(info);
    this.sync(this.#responseExtraInfos.length - 1);
  }
  setEarlyHintsHeaders(earlyHintsHeaders) {
    this.#responseEarlyHintsHeaders = earlyHintsHeaders;
    this.updateFinalRequest();
  }
  setWebBundleInfo(info) {
    this.#webBundleInfo = info;
    this.updateFinalRequest();
  }
  setWebBundleInnerRequestInfo(info) {
    this.#webBundleInnerRequestInfo = info;
    this.updateFinalRequest();
  }
  finished() {
    this.#finishedInternal = true;
    this.updateFinalRequest();
  }
  isFinished() {
    return this.#finishedInternal;
  }
  sync(index) {
    const req = this.#requests[index];
    if (!req) {
      return;
    }
    const requestExtraInfo = this.#requestExtraInfos[index];
    if (requestExtraInfo) {
      req.addExtraRequestInfo(requestExtraInfo);
      this.#requestExtraInfos[index] = null;
    }
    const responseExtraInfo = this.#responseExtraInfos[index];
    if (responseExtraInfo) {
      req.addExtraResponseInfo(responseExtraInfo);
      this.#responseExtraInfos[index] = null;
    }
  }
  finalRequest() {
    if (!this.#finishedInternal) {
      return null;
    }
    return this.#requests[this.#requests.length - 1] || null;
  }
  updateFinalRequest() {
    if (!this.#finishedInternal) {
      return;
    }
    const finalRequest = this.finalRequest();
    finalRequest?.setWebBundleInfo(this.#webBundleInfo);
    finalRequest?.setWebBundleInnerRequestInfo(this.#webBundleInnerRequestInfo);
    finalRequest?.setEarlyHintsHeaders(this.#responseEarlyHintsHeaders);
  }
};
SDKModel.register(NetworkManager, { capabilities: Capability.NETWORK, autostart: true });
var ConditionsSerializer = class {
  stringify(value) {
    const conditions = value;
    return JSON.stringify({
      ...conditions,
      title: typeof conditions.title === "function" ? conditions.title() : conditions.title
    });
  }
  parse(serialized) {
    const parsed = JSON.parse(serialized);
    return {
      ...parsed,
      // eslint-disable-next-line rulesdir/l10n_i18nString_call_only_with_uistrings
      title: parsed.i18nTitleKey ? i18nLazyString(parsed.i18nTitleKey) : parsed.title
    };
  }
};
function networkConditionsEqual(first, second) {
  const firstTitle = first.i18nTitleKey || (typeof first.title === "function" ? first.title() : first.title);
  const secondTitle = second.i18nTitleKey || (typeof second.title === "function" ? second.title() : second.title);
  return second.download === first.download && second.upload === first.upload && second.latency === first.latency && first.packetLoss === second.packetLoss && first.packetQueueLength === second.packetQueueLength && first.packetReordering === second.packetReordering && secondTitle === firstTitle;
}

// gen/front_end/core/sdk/ResourceTreeModel.js
var ResourceTreeModel_exports = {};
__export(ResourceTreeModel_exports, {
  Events: () => Events4,
  PageDispatcher: () => PageDispatcher,
  PrimaryPageChangeType: () => PrimaryPageChangeType,
  ResourceTreeFrame: () => ResourceTreeFrame,
  ResourceTreeModel: () => ResourceTreeModel
});
import * as Common23 from "./../common/common.js";
import * as i18n15 from "./../i18n/i18n.js";
import * as Platform16 from "./../platform/platform.js";

// gen/front_end/core/sdk/DOMModel.js
var DOMModel_exports = {};
__export(DOMModel_exports, {
  DOMDocument: () => DOMDocument,
  DOMModel: () => DOMModel,
  DOMModelUndoStack: () => DOMModelUndoStack,
  DOMNode: () => DOMNode,
  DOMNodeShortcut: () => DOMNodeShortcut,
  DeferredDOMNode: () => DeferredDOMNode,
  Events: () => Events12
});
import * as Common20 from "./../common/common.js";
import * as Host7 from "./../host/host.js";
import * as Platform14 from "./../platform/platform.js";
import * as Root6 from "./../root/root.js";

// gen/front_end/core/sdk/CSSModel.js
var CSSModel_exports = {};
__export(CSSModel_exports, {
  CSSLocation: () => CSSLocation,
  CSSModel: () => CSSModel,
  CSSPropertyTracker: () => CSSPropertyTracker,
  CSSPropertyTrackerEvents: () => CSSPropertyTrackerEvents,
  ColorScheme: () => ColorScheme,
  Edit: () => Edit,
  Events: () => Events8,
  InlineStyleResult: () => InlineStyleResult
});
import * as TextUtils15 from "./../../models/text_utils/text_utils.js";
import * as Common13 from "./../common/common.js";
import * as Host4 from "./../host/host.js";
import * as Platform10 from "./../platform/platform.js";

// gen/front_end/core/sdk/CSSFontFace.js
var CSSFontFace_exports = {};
__export(CSSFontFace_exports, {
  CSSFontFace: () => CSSFontFace
});
var CSSFontFace = class {
  #fontFamily;
  #fontVariationAxes;
  #fontVariationAxesByTag;
  #src;
  #fontDisplay;
  constructor(payload) {
    this.#fontFamily = payload.fontFamily;
    this.#fontVariationAxes = payload.fontVariationAxes || [];
    this.#fontVariationAxesByTag = /* @__PURE__ */ new Map();
    this.#src = payload.src;
    this.#fontDisplay = payload.fontDisplay;
    for (const axis of this.#fontVariationAxes) {
      this.#fontVariationAxesByTag.set(axis.tag, axis);
    }
  }
  getFontFamily() {
    return this.#fontFamily;
  }
  getSrc() {
    return this.#src;
  }
  getFontDisplay() {
    return this.#fontDisplay;
  }
  getVariationAxisByTag(tag) {
    return this.#fontVariationAxesByTag.get(tag);
  }
};

// gen/front_end/core/sdk/CSSMatchedStyles.js
var CSSMatchedStyles_exports = {};
__export(CSSMatchedStyles_exports, {
  CSSMatchedStyles: () => CSSMatchedStyles,
  CSSRegisteredProperty: () => CSSRegisteredProperty,
  CSSValueSource: () => CSSValueSource,
  PropertyState: () => PropertyState
});
import * as Platform6 from "./../platform/platform.js";

// gen/front_end/core/sdk/CSSProperty.js
var CSSProperty_exports = {};
__export(CSSProperty_exports, {
  CSSProperty: () => CSSProperty
});
import * as TextUtils3 from "./../../models/text_utils/text_utils.js";
import * as Common6 from "./../common/common.js";
import * as HostModule from "./../host/host.js";
import * as Platform4 from "./../platform/platform.js";

// gen/front_end/core/sdk/CSSPropertyParser.js
var CSSPropertyParser_exports = {};
__export(CSSPropertyParser_exports, {
  ASTUtils: () => ASTUtils,
  BottomUpTreeMatching: () => BottomUpTreeMatching,
  CSSControlMap: () => CSSControlMap,
  ComputedText: () => ComputedText,
  SyntaxTree: () => SyntaxTree,
  TextMatch: () => TextMatch,
  TreeSearch: () => TreeSearch,
  TreeWalker: () => TreeWalker,
  VariableMatch: () => VariableMatch,
  VariableMatcher: () => VariableMatcher,
  matcherBase: () => matcherBase,
  parseFontFamily: () => parseFontFamily,
  parseFontVariationSettings: () => parseFontVariationSettings,
  requiresSpace: () => requiresSpace,
  splitByComma: () => splitByComma,
  stripComments: () => stripComments,
  tokenizeDeclaration: () => tokenizeDeclaration,
  tokenizePropertyName: () => tokenizePropertyName
});
import * as CodeMirror from "./../../third_party/codemirror.next/codemirror.next.js";
var globalValues = /* @__PURE__ */ new Set(["inherit", "initial", "unset"]);
var tagRegexp = /[\x20-\x7E]{4}/;
var numRegexp = /[+-]?(?:\d*\.)?\d+(?:[eE]\d+)?/;
var fontVariationSettingsRegexp = new RegExp(`(?:'(${tagRegexp.source})')|(?:"(${tagRegexp.source})")\\s+(${numRegexp.source})`);
function parseFontVariationSettings(value) {
  if (globalValues.has(value.trim()) || value.trim() === "normal") {
    return [];
  }
  const results = [];
  for (const setting of splitByComma(stripComments(value))) {
    const match = setting.match(fontVariationSettingsRegexp);
    if (match) {
      results.push({
        tag: match[1] || match[2],
        value: parseFloat(match[3])
      });
    }
  }
  return results;
}
var fontFamilyRegexp = /^"(.+)"|'(.+)'$/;
function parseFontFamily(value) {
  if (globalValues.has(value.trim())) {
    return [];
  }
  const results = [];
  for (const family of splitByComma(stripComments(value))) {
    const match = family.match(fontFamilyRegexp);
    if (match) {
      results.push(match[1] || match[2]);
    } else {
      results.push(family);
    }
  }
  return results;
}
function splitByComma(value) {
  return value.split(",").map((part) => part.trim());
}
function stripComments(value) {
  return value.replaceAll(/(\/\*(?:.|\s)*?\*\/)/g, "");
}
var cssParser = CodeMirror.css.cssLanguage.parser;
function nodeText(node, text) {
  return nodeTextRange(node, node, text);
}
function nodeTextRange(from, to, text) {
  return text.substring(from.from, to.to);
}
var SyntaxTree = class _SyntaxTree {
  propertyValue;
  rule;
  tree;
  trailingNodes;
  propertyName;
  constructor(propertyValue, rule, tree, propertyName, trailingNodes = []) {
    this.propertyName = propertyName;
    this.propertyValue = propertyValue;
    this.rule = rule;
    this.tree = tree;
    this.trailingNodes = trailingNodes;
  }
  text(node) {
    if (node === null) {
      return "";
    }
    return nodeText(node ?? this.tree, this.rule);
  }
  textRange(from, to) {
    return nodeTextRange(from, to, this.rule);
  }
  subtree(node) {
    return new _SyntaxTree(this.propertyValue, this.rule, node);
  }
};
var TreeWalker = class {
  ast;
  constructor(ast) {
    this.ast = ast;
  }
  static walkExcludingSuccessors(propertyValue, ...args) {
    const instance = new this(propertyValue, ...args);
    if (propertyValue.tree.name === "Declaration") {
      instance.iterateDeclaration(propertyValue.tree);
    } else {
      instance.iterateExcludingSuccessors(propertyValue.tree);
    }
    return instance;
  }
  static walk(propertyValue, ...args) {
    const instance = new this(propertyValue, ...args);
    if (propertyValue.tree.name === "Declaration") {
      instance.iterateDeclaration(propertyValue.tree);
    } else {
      instance.iterate(propertyValue.tree);
    }
    return instance;
  }
  iterateDeclaration(tree) {
    if (tree.name !== "Declaration") {
      return;
    }
    if (this.enter(tree)) {
      ASTUtils.declValue(tree)?.cursor().iterate(this.enter.bind(this), this.leave.bind(this));
    }
    this.leave(tree);
  }
  iterate(tree) {
    tree.cursor().iterate(this.enter.bind(this), this.leave.bind(this));
  }
  iterateExcludingSuccessors(tree) {
    if (this.enter(tree)) {
      tree.firstChild?.cursor().iterate(this.enter.bind(this), this.leave.bind(this));
    }
    this.leave(tree);
  }
  enter(_node) {
    return true;
  }
  leave(_node) {
  }
};
function matcherBase(matchT) {
  class MatcherBase {
    matchType = matchT;
    accepts(_propertyName) {
      return true;
    }
    matches(_node, _matching) {
      return null;
    }
  }
  return MatcherBase;
}
var BottomUpTreeMatching = class extends TreeWalker {
  #matchers = [];
  #matchedNodes = /* @__PURE__ */ new Map();
  computedText;
  #key(node) {
    return `${node.from}:${node.to}`;
  }
  constructor(ast, matchers) {
    super(ast);
    this.computedText = new ComputedText(ast.rule.substring(ast.tree.from));
    this.#matchers.push(...matchers.filter((m) => !ast.propertyName || m.accepts(ast.propertyName)));
    this.#matchers.push(new TextMatcher());
  }
  leave({ node }) {
    for (const matcher of this.#matchers) {
      const match = matcher.matches(node, this);
      if (match) {
        this.computedText.push(match, node.from - this.ast.tree.from);
        this.#matchedNodes.set(this.#key(node), match);
        break;
      }
    }
  }
  matchText(node) {
    const matchers = this.#matchers.splice(0);
    this.#matchers.push(new TextMatcher());
    this.iterateExcludingSuccessors(node);
    this.#matchers.push(...matchers);
  }
  getMatch(node) {
    return this.#matchedNodes.get(this.#key(node));
  }
  hasUnresolvedVars(node) {
    return this.hasUnresolvedVarsRange(node, node);
  }
  hasUnresolvedVarsRange(from, to) {
    return this.computedText.hasUnresolvedVars(from.from - this.ast.tree.from, to.to - this.ast.tree.from);
  }
  getComputedText(node, substitutions) {
    return this.getComputedTextRange(node, node, substitutions);
  }
  getComputedTextRange(from, to, substitutions) {
    return this.computedText.get(from.from - this.ast.tree.from, to.to - this.ast.tree.from, substitutions);
  }
};
var ComputedTextChunk = class {
  constructor(match, offset) {
    this.match = match;
    this.offset = offset;
  }
  #cachedComputedText = null;
  get end() {
    return this.offset + this.length;
  }
  get length() {
    return this.match.text.length;
  }
  get computedText() {
    if (this.#cachedComputedText === null) {
      this.#cachedComputedText = this.match.computedText();
    }
    return this.#cachedComputedText;
  }
};
var ComputedText = class {
  #chunks = [];
  text;
  #sorted = true;
  constructor(text) {
    this.text = text;
  }
  clear() {
    this.#chunks.splice(0);
  }
  get chunkCount() {
    return this.#chunks.length;
  }
  #sortIfNecessary() {
    if (this.#sorted) {
      return;
    }
    this.#chunks.sort((a, b) => {
      if (a.offset < b.offset) {
        return -1;
      }
      if (b.offset < a.offset) {
        return 1;
      }
      if (a.end > b.end) {
        return -1;
      }
      if (a.end < b.end) {
        return 1;
      }
      return 0;
    });
    this.#sorted = true;
  }
  // Add another substitutable match. The match will either be appended to the list of existing matches or it will
  // be substituted for the last match(es) if it encompasses them.
  push(match, offset) {
    function hasComputedText(match2) {
      return Boolean(match2.computedText);
    }
    if (!hasComputedText(match) || offset < 0 || offset >= this.text.length) {
      return;
    }
    const chunk = new ComputedTextChunk(match, offset);
    if (chunk.end > this.text.length) {
      return;
    }
    this.#sorted = false;
    this.#chunks.push(chunk);
  }
  *#range(begin, end) {
    this.#sortIfNecessary();
    let i = this.#chunks.findIndex((c) => c.offset >= begin);
    while (i >= 0 && i < this.#chunks.length && this.#chunks[i].end > begin && begin < end) {
      if (this.#chunks[i].end > end) {
        i++;
        continue;
      }
      yield this.#chunks[i];
      begin = this.#chunks[i].end;
      while (begin < end && i < this.#chunks.length && this.#chunks[i].offset < begin) {
        i++;
      }
    }
  }
  hasUnresolvedVars(begin, end) {
    for (const chunk of this.#range(begin, end)) {
      if (chunk.computedText === null) {
        return true;
      }
    }
    return false;
  }
  *#getPieces(begin, end) {
    for (const chunk of this.#range(begin, end)) {
      const piece = this.text.substring(begin, Math.min(chunk.offset, end));
      yield piece;
      if (end >= chunk.end) {
        yield chunk;
      }
      begin = chunk.end;
    }
    if (begin < end) {
      const piece = this.text.substring(begin, end);
      yield piece;
    }
  }
  // Get a slice of the computed text corresponding to the property text in the range [begin, end). The slice may not
  // start within a substitution chunk, e.g., it's invalid to request the computed text for the property value text
  // slice "1px var(--".
  get(begin, end, substitutions) {
    const pieces = [];
    const getText = (piece) => {
      if (typeof piece === "string") {
        return piece;
      }
      const substitution = substitutions?.get(piece.match);
      if (substitution) {
        return getText(substitution);
      }
      return piece.computedText ?? piece.match.text;
    };
    for (const piece of this.#getPieces(begin, end)) {
      const text = getText(piece);
      if (text.length === 0) {
        continue;
      }
      if (pieces.length > 0 && requiresSpace(pieces[pieces.length - 1], text)) {
        pieces.push(" ");
      }
      pieces.push(text);
    }
    return pieces.join("");
  }
};
function requiresSpace(a, b) {
  const tail = Array.isArray(a) ? a.findLast((node) => node.textContent)?.textContent : a;
  const head = Array.isArray(b) ? b.find((node) => node.textContent)?.textContent : b;
  const trailingChar = tail ? tail[tail.length - 1] : "";
  const leadingChar = head ? head[0] : "";
  const noSpaceAfter = ["", "(", "{", "}", ";", "["];
  const noSpaceBefore = ["", "(", ")", ",", ":", "*", "{", ";", "]"];
  return !/\s/.test(trailingChar) && !/\s/.test(leadingChar) && !noSpaceAfter.includes(trailingChar) && !noSpaceBefore.includes(leadingChar);
}
var CSSControlMap = Map;
var ASTUtils;
((ASTUtils2) => {
  function siblings(node) {
    const result = [];
    while (node) {
      result.push(node);
      node = node.nextSibling;
    }
    return result;
  }
  ASTUtils2.siblings = siblings;
  function children(node) {
    return siblings(node?.firstChild ?? null);
  }
  ASTUtils2.children = children;
  function declValue(node) {
    if (node.name !== "Declaration") {
      return null;
    }
    return children(node).find((node2) => node2.name === ":")?.nextSibling ?? null;
  }
  ASTUtils2.declValue = declValue;
  function* stripComments2(nodes) {
    for (const node of nodes) {
      if (node.type.name !== "Comment") {
        yield node;
      }
    }
  }
  ASTUtils2.stripComments = stripComments2;
  function split(nodes) {
    const result = [];
    let current = [];
    for (const node of nodes) {
      if (node.name === ",") {
        result.push(current);
        current = [];
      } else {
        current.push(node);
      }
    }
    result.push(current);
    return result;
  }
  ASTUtils2.split = split;
  function callArgs(node) {
    const args = children(node.getChild("ArgList"));
    const openParen = args.splice(0, 1)[0];
    const closingParen = args.pop();
    if (openParen?.name !== "(" || closingParen?.name !== ")") {
      return [];
    }
    return split(args);
  }
  ASTUtils2.callArgs = callArgs;
  function equals(a, b) {
    return a.name === b.name && a.from === b.from && a.to === b.to;
  }
  ASTUtils2.equals = equals;
})(ASTUtils || (ASTUtils = {}));
var VariableMatch = class {
  constructor(text, node, name, fallback, matching, computedTextCallback) {
    this.text = text;
    this.node = node;
    this.name = name;
    this.fallback = fallback;
    this.matching = matching;
    this.computedTextCallback = computedTextCallback;
  }
  computedText() {
    return this.computedTextCallback(this, this.matching);
  }
};
var VariableMatcher = class extends matcherBase(VariableMatch) {
  // clang-format on
  #computedTextCallback;
  constructor(computedTextCallback) {
    super();
    this.#computedTextCallback = computedTextCallback;
  }
  matches(node, matching) {
    const callee = node.getChild("Callee");
    const args = node.getChild("ArgList");
    if (node.name !== "CallExpression" || !callee || matching.ast.text(callee) !== "var" || !args) {
      return null;
    }
    const [lparenNode, nameNode, ...fallbackOrRParenNodes] = ASTUtils.children(args);
    if (lparenNode?.name !== "(" || nameNode?.name !== "VariableName") {
      return null;
    }
    if (fallbackOrRParenNodes.length <= 1 && fallbackOrRParenNodes[0]?.name !== ")") {
      return null;
    }
    let fallback = [];
    if (fallbackOrRParenNodes.length > 1) {
      if (fallbackOrRParenNodes.shift()?.name !== ",") {
        return null;
      }
      if (fallbackOrRParenNodes.pop()?.name !== ")") {
        return null;
      }
      fallback = fallbackOrRParenNodes;
      if (fallback.length === 0) {
        return null;
      }
      if (fallback.some((n) => n.name === ",")) {
        return null;
      }
    }
    const varName = matching.ast.text(nameNode);
    if (!varName.startsWith("--")) {
      return null;
    }
    return new VariableMatch(matching.ast.text(node), node, varName, fallback, matching, this.#computedTextCallback);
  }
};
var TextMatch = class {
  constructor(text, node) {
    this.text = text;
    this.node = node;
    if (node.name === "Comment") {
      this.computedText = () => "";
    }
  }
  computedText;
  render() {
    return [document.createTextNode(this.text)];
  }
};
var TextMatcher = class extends matcherBase(TextMatch) {
  // clang-format on
  accepts() {
    return true;
  }
  matches(node, matching) {
    if (!node.firstChild || node.name === "NumberLiteral") {
      const text = matching.ast.text(node);
      if (text.length) {
        return new TextMatch(text, node);
      }
    }
    return null;
  }
};
function declaration(rule) {
  return cssParser.parse(rule).topNode.getChild("RuleSet")?.getChild("Block")?.getChild("Declaration") ?? null;
}
function tokenizeDeclaration(propertyName, propertyValue) {
  const name = tokenizePropertyName(propertyName);
  if (!name) {
    return null;
  }
  const rule = `*{${name}: ${propertyValue};}`;
  const decl = declaration(rule);
  if (!decl || decl.type.isError) {
    return null;
  }
  const childNodes = ASTUtils.children(decl);
  if (childNodes.length < 2) {
    return null;
  }
  const [varName, colon, tree] = childNodes;
  if (!varName || varName.type.isError || !colon || colon.type.isError || tree?.type.isError) {
    return null;
  }
  const trailingNodes = ASTUtils.siblings(decl).slice(1);
  const [semicolon, brace] = trailingNodes.splice(trailingNodes.length - 2, 2);
  if (semicolon?.name !== ";" && brace?.name !== "}") {
    return null;
  }
  const ast = new SyntaxTree(propertyValue, rule, decl, name, trailingNodes);
  if (ast.text(varName) !== name || colon.name !== ":") {
    return null;
  }
  return ast;
}
function tokenizePropertyName(name) {
  const rule = `*{${name}: inherit;}`;
  const decl = declaration(rule);
  if (!decl || decl.type.isError) {
    return null;
  }
  const propertyName = decl.getChild("PropertyName") ?? decl.getChild("VariableName");
  if (!propertyName) {
    return null;
  }
  return nodeText(propertyName, rule);
}
var TreeSearch = class _TreeSearch extends TreeWalker {
  #found = null;
  #predicate;
  constructor(ast, predicate) {
    super(ast);
    this.#predicate = predicate;
  }
  enter({ node }) {
    if (this.#found) {
      return false;
    }
    if (this.#predicate(node)) {
      this.#found = this.#found ?? node;
      return false;
    }
    return true;
  }
  static find(ast, predicate) {
    return _TreeSearch.walk(ast, predicate).#found;
  }
  static findAll(ast, predicate) {
    const foundNodes = [];
    _TreeSearch.walk(ast, (node) => {
      if (predicate(node)) {
        foundNodes.push(node);
      }
      return false;
    });
    return foundNodes;
  }
};

// gen/front_end/core/sdk/CSSProperty.js
var CSSProperty = class _CSSProperty {
  ownerStyle;
  index;
  name;
  value;
  important;
  disabled;
  parsedOk;
  implicit;
  text;
  range;
  #active;
  #nameRangeInternal;
  #valueRangeInternal;
  #invalidString;
  #longhandProperties = [];
  constructor(ownerStyle, index, name, value, important, disabled, parsedOk, implicit, text, range, longhandProperties) {
    this.ownerStyle = ownerStyle;
    this.index = index;
    this.name = name;
    this.value = value;
    this.important = important;
    this.disabled = disabled;
    this.parsedOk = parsedOk;
    this.implicit = implicit;
    this.text = text;
    this.range = range ? TextUtils3.TextRange.TextRange.fromObject(range) : null;
    this.#active = true;
    this.#nameRangeInternal = null;
    this.#valueRangeInternal = null;
    if (longhandProperties && longhandProperties.length > 0) {
      for (const property of longhandProperties) {
        this.#longhandProperties.push(
          new _CSSProperty(ownerStyle, ++index, property.name, property.value, important, disabled, parsedOk, true)
        );
      }
    } else {
      const longhandNames = cssMetadata().getLonghands(name);
      for (const longhandName of longhandNames || []) {
        this.#longhandProperties.push(
          new _CSSProperty(ownerStyle, ++index, longhandName, "", important, disabled, parsedOk, true)
        );
      }
    }
  }
  static parsePayload(ownerStyle, index, payload) {
    const result = new _CSSProperty(
      ownerStyle,
      index,
      payload.name,
      payload.value,
      payload.important || false,
      payload.disabled || false,
      "parsedOk" in payload ? Boolean(payload.parsedOk) : true,
      Boolean(payload.implicit),
      payload.text,
      payload.range,
      payload.longhandProperties
    );
    return result;
  }
  ensureRanges() {
    if (this.#nameRangeInternal && this.#valueRangeInternal) {
      return;
    }
    const range = this.range;
    const text = this.text ? new TextUtils3.Text.Text(this.text) : null;
    if (!range || !text) {
      return;
    }
    const nameIndex = text.value().indexOf(this.name);
    const valueIndex = text.value().lastIndexOf(this.value);
    if (nameIndex === -1 || valueIndex === -1 || nameIndex > valueIndex) {
      return;
    }
    const nameSourceRange = new TextUtils3.TextRange.SourceRange(nameIndex, this.name.length);
    const valueSourceRange = new TextUtils3.TextRange.SourceRange(valueIndex, this.value.length);
    this.#nameRangeInternal = rebase(text.toTextRange(nameSourceRange), range.startLine, range.startColumn);
    this.#valueRangeInternal = rebase(text.toTextRange(valueSourceRange), range.startLine, range.startColumn);
    function rebase(oneLineRange, lineOffset, columnOffset) {
      if (oneLineRange.startLine === 0) {
        oneLineRange.startColumn += columnOffset;
        oneLineRange.endColumn += columnOffset;
      }
      oneLineRange.startLine += lineOffset;
      oneLineRange.endLine += lineOffset;
      return oneLineRange;
    }
  }
  nameRange() {
    this.ensureRanges();
    return this.#nameRangeInternal;
  }
  valueRange() {
    this.ensureRanges();
    return this.#valueRangeInternal;
  }
  rebase(edit) {
    if (this.ownerStyle.styleSheetId !== edit.styleSheetId) {
      return;
    }
    if (this.range) {
      this.range = this.range.rebaseAfterTextEdit(edit.oldRange, edit.newRange);
    }
  }
  setActive(active) {
    this.#active = active;
  }
  get propertyText() {
    if (this.text !== void 0) {
      return this.text;
    }
    if (this.name === "") {
      return "";
    }
    return this.name + ": " + this.value + (this.important ? " !important" : "") + ";";
  }
  activeInStyle() {
    return this.#active;
  }
  trimmedValueWithoutImportant() {
    const important = "!important";
    return this.value.endsWith(important) ? this.value.slice(0, -important.length).trim() : this.value.trim();
  }
  async setText(propertyText, majorChange, overwrite) {
    if (!this.ownerStyle) {
      throw new Error("No ownerStyle for property");
    }
    if (!this.ownerStyle.styleSheetId) {
      throw new Error("No owner style id");
    }
    if (!this.range || !this.ownerStyle.range) {
      throw new Error("Style not editable");
    }
    if (majorChange) {
      HostModule.userMetrics.actionTaken(HostModule.UserMetrics.Action.StyleRuleEdited);
      if (this.ownerStyle.parentRule?.isKeyframeRule()) {
        HostModule.userMetrics.actionTaken(HostModule.UserMetrics.Action.StylePropertyInsideKeyframeEdited);
      }
      if (this.name.startsWith("--")) {
        HostModule.userMetrics.actionTaken(HostModule.UserMetrics.Action.CustomPropertyEdited);
      }
    }
    if (overwrite && propertyText === this.propertyText) {
      this.ownerStyle.cssModel().domModel().markUndoableState(!majorChange);
      return true;
    }
    const range = this.range.relativeTo(this.ownerStyle.range.startLine, this.ownerStyle.range.startColumn);
    const indentation = this.ownerStyle.cssText ? this.detectIndentation(this.ownerStyle.cssText) : Common6.Settings.Settings.instance().moduleSetting("text-editor-indent").get();
    const endIndentation = this.ownerStyle.cssText ? indentation.substring(0, this.ownerStyle.range.endColumn) : "";
    const text = new TextUtils3.Text.Text(this.ownerStyle.cssText || "");
    const newStyleText = text.replaceRange(range, Platform4.StringUtilities.sprintf(";%s;", propertyText));
    const styleText = await _CSSProperty.formatStyle(newStyleText, indentation, endIndentation);
    return this.ownerStyle.setText(styleText, majorChange);
  }
  static async formatStyle(styleText, indentation, endIndentation) {
    const doubleIndent = indentation.substring(endIndentation.length) + indentation;
    if (indentation) {
      indentation = "\n" + indentation;
    }
    let result = "";
    let propertyName = "";
    let propertyText = "";
    let insideProperty = false;
    let needsSemi = false;
    const tokenize = TextUtils3.CodeMirrorUtils.createCssTokenizer();
    await tokenize("*{" + styleText + "}", processToken);
    if (insideProperty) {
      result += propertyText;
    }
    result = result.substring(2, result.length - 1).trimEnd();
    return result + (indentation ? "\n" + endIndentation : "");
    function processToken(token, tokenType) {
      if (!insideProperty) {
        const disabledProperty = tokenType?.includes("comment") && isDisabledProperty(token);
        const isPropertyStart = tokenType?.includes("def") || tokenType?.includes("string") || tokenType?.includes("meta") || tokenType?.includes("property") || tokenType?.includes("variableName") && tokenType !== "variableName.function";
        if (disabledProperty) {
          result = result.trimEnd() + indentation + token;
        } else if (isPropertyStart) {
          insideProperty = true;
          propertyText = token;
        } else if (token !== ";" || needsSemi) {
          result += token;
          if (token.trim() && !tokenType?.includes("comment")) {
            needsSemi = token !== ";";
          }
        }
        if (token === "{" && !tokenType) {
          needsSemi = false;
        }
        return;
      }
      if (token === "}" || token === ";") {
        const trimmedPropertyText = propertyText.trim();
        result = result.trimEnd() + indentation + trimmedPropertyText + (trimmedPropertyText.endsWith(":") ? " " : "") + token;
        needsSemi = false;
        insideProperty = false;
        propertyName = "";
        return;
      }
      if (cssMetadata().isGridAreaDefiningProperty(propertyName)) {
        const rowResult = GridAreaRowRegex.exec(token);
        if (rowResult && rowResult.index === 0 && !propertyText.trimEnd().endsWith("]")) {
          propertyText = propertyText.trimEnd() + "\n" + doubleIndent;
        }
      }
      if (!propertyName && token === ":") {
        propertyName = propertyText;
      }
      propertyText += token;
    }
    function isDisabledProperty(text) {
      const colon = text.indexOf(":");
      if (colon === -1) {
        return false;
      }
      const propertyName2 = text.substring(2, colon).trim();
      return cssMetadata().isCSSPropertyName(propertyName2);
    }
  }
  detectIndentation(text) {
    const lines = text.split("\n");
    if (lines.length < 2) {
      return "";
    }
    return TextUtils3.TextUtils.Utils.lineIndent(lines[1]);
  }
  setValue(newValue, majorChange, overwrite, userCallback) {
    const text = this.name + ": " + newValue + (this.important ? " !important" : "") + ";";
    void this.setText(text, majorChange, overwrite).then(userCallback);
  }
  async setDisabled(disabled) {
    if (!this.ownerStyle) {
      return false;
    }
    if (disabled === this.disabled) {
      return true;
    }
    if (!this.text) {
      return true;
    }
    const propertyText = this.text.trim();
    const appendSemicolonIfMissing = (propertyText2) => propertyText2 + (propertyText2.endsWith(";") ? "" : ";");
    let text;
    if (disabled) {
      text = "/* " + appendSemicolonIfMissing(stripComments(propertyText)) + " */";
    } else {
      text = appendSemicolonIfMissing(this.text.substring(2, propertyText.length - 2).trim());
    }
    return this.setText(text, true, true);
  }
  /**
   * This stores the warning string when a CSS Property is improperly parsed.
   */
  setDisplayedStringForInvalidProperty(invalidString) {
    this.#invalidString = invalidString;
  }
  /**
   * Retrieve the warning string for a screen reader to announce when editing the property.
   */
  getInvalidStringForInvalidProperty() {
    return this.#invalidString;
  }
  getLonghandProperties() {
    return this.#longhandProperties;
  }
};

// gen/front_end/core/sdk/CSSRule.js
var CSSRule_exports = {};
__export(CSSRule_exports, {
  CSSFontPaletteValuesRule: () => CSSFontPaletteValuesRule,
  CSSKeyframeRule: () => CSSKeyframeRule,
  CSSKeyframesRule: () => CSSKeyframesRule,
  CSSPositionTryRule: () => CSSPositionTryRule,
  CSSPropertyRule: () => CSSPropertyRule,
  CSSRule: () => CSSRule,
  CSSStyleRule: () => CSSStyleRule
});
import * as TextUtils11 from "./../../models/text_utils/text_utils.js";
import * as Platform5 from "./../platform/platform.js";

// gen/front_end/core/sdk/CSSContainerQuery.js
var CSSContainerQuery_exports = {};
__export(CSSContainerQuery_exports, {
  CSSContainerQuery: () => CSSContainerQuery,
  CSSContainerQueryContainer: () => CSSContainerQueryContainer,
  PhysicalAxis: () => PhysicalAxis,
  QueryAxis: () => QueryAxis,
  getPhysicalAxisFromQueryAxis: () => getPhysicalAxisFromQueryAxis,
  getQueryAxisFromContainerType: () => getQueryAxisFromContainerType
});
import * as TextUtils5 from "./../../models/text_utils/text_utils.js";

// gen/front_end/core/sdk/CSSQuery.js
var CSSQuery_exports = {};
__export(CSSQuery_exports, {
  CSSQuery: () => CSSQuery
});
var CSSQuery = class {
  text = "";
  range;
  styleSheetId;
  cssModel;
  constructor(cssModel) {
    this.cssModel = cssModel;
  }
  rebase(edit) {
    if (this.styleSheetId !== edit.styleSheetId || !this.range) {
      return;
    }
    if (edit.oldRange.equal(this.range)) {
      this.reinitialize(edit.payload);
    } else {
      this.range = this.range.rebaseAfterTextEdit(edit.oldRange, edit.newRange);
    }
  }
  equal(other) {
    if (!this.styleSheetId || !this.range || !other.range) {
      return false;
    }
    return this.styleSheetId === other.styleSheetId && this.range.equal(other.range);
  }
  lineNumberInSource() {
    if (!this.range) {
      return void 0;
    }
    return this.header()?.lineNumberInSource(this.range.startLine);
  }
  columnNumberInSource() {
    if (!this.range) {
      return void 0;
    }
    return this.header()?.columnNumberInSource(this.range.startLine, this.range.startColumn);
  }
  header() {
    return this.styleSheetId ? this.cssModel.styleSheetHeaderForId(this.styleSheetId) : null;
  }
  rawLocation() {
    const header = this.header();
    if (!header || this.lineNumberInSource() === void 0) {
      return null;
    }
    const lineNumber = Number(this.lineNumberInSource());
    return new CSSLocation(header, lineNumber, this.columnNumberInSource());
  }
};

// gen/front_end/core/sdk/CSSContainerQuery.js
var CSSContainerQuery = class _CSSContainerQuery extends CSSQuery {
  name;
  physicalAxes;
  logicalAxes;
  queriesScrollState;
  static parseContainerQueriesPayload(cssModel, payload) {
    return payload.map((cq) => new _CSSContainerQuery(cssModel, cq));
  }
  constructor(cssModel, payload) {
    super(cssModel);
    this.reinitialize(payload);
  }
  reinitialize(payload) {
    this.text = payload.text;
    this.range = payload.range ? TextUtils5.TextRange.TextRange.fromObject(payload.range) : null;
    this.styleSheetId = payload.styleSheetId;
    this.name = payload.name;
    this.physicalAxes = payload.physicalAxes;
    this.logicalAxes = payload.logicalAxes;
    this.queriesScrollState = payload.queriesScrollState;
  }
  active() {
    return true;
  }
  async getContainerForNode(nodeId) {
    const containerNode = await this.cssModel.domModel().getContainerForNode(
      nodeId,
      this.name,
      this.physicalAxes,
      this.logicalAxes,
      this.queriesScrollState
    );
    if (!containerNode) {
      return;
    }
    return new CSSContainerQueryContainer(containerNode);
  }
};
var CSSContainerQueryContainer = class {
  containerNode;
  constructor(containerNode) {
    this.containerNode = containerNode;
  }
  async getContainerSizeDetails() {
    const styles = await this.containerNode.domModel().cssModel().getComputedStyle(this.containerNode.id);
    if (!styles) {
      return;
    }
    const containerType = styles.get("container-type");
    const writingMode = styles.get("writing-mode");
    if (!containerType || !writingMode) {
      return;
    }
    const queryAxis = getQueryAxisFromContainerType(`${containerType}`);
    const physicalAxis = getPhysicalAxisFromQueryAxis(queryAxis, writingMode);
    let width, height;
    if (physicalAxis === "Both" || physicalAxis === "Horizontal") {
      width = styles.get("width");
    }
    if (physicalAxis === "Both" || physicalAxis === "Vertical") {
      height = styles.get("height");
    }
    return {
      queryAxis,
      physicalAxis,
      width,
      height
    };
  }
};
var getQueryAxisFromContainerType = (propertyValue) => {
  const segments = propertyValue.split(" ");
  let isInline = false;
  for (const segment of segments) {
    if (segment === "size") {
      return "size";
    }
    isInline = isInline || segment === "inline-size";
  }
  if (isInline) {
    return "inline-size";
  }
  return "";
};
var getPhysicalAxisFromQueryAxis = (queryAxis, writingMode) => {
  const isVerticalWritingMode = writingMode.startsWith("vertical");
  switch (queryAxis) {
    case "":
      return "";
    case "size":
      return "Both";
    case "inline-size":
      return isVerticalWritingMode ? "Vertical" : "Horizontal";
    case "block-size":
      return isVerticalWritingMode ? "Horizontal" : "Vertical";
  }
};
var QueryAxis = /* @__PURE__ */ ((QueryAxis2) => {
  QueryAxis2["NONE"] = "";
  QueryAxis2["INLINE"] = "inline-size";
  QueryAxis2["BLOCK"] = "block-size";
  QueryAxis2["BOTH"] = "size";
  return QueryAxis2;
})(QueryAxis || {});
var PhysicalAxis = /* @__PURE__ */ ((PhysicalAxis2) => {
  PhysicalAxis2["NONE"] = "";
  PhysicalAxis2["HORIZONTAL"] = "Horizontal";
  PhysicalAxis2["VERTICAL"] = "Vertical";
  PhysicalAxis2["BOTH"] = "Both";
  return PhysicalAxis2;
})(PhysicalAxis || {});

// gen/front_end/core/sdk/CSSLayer.js
var CSSLayer_exports = {};
__export(CSSLayer_exports, {
  CSSLayer: () => CSSLayer
});
import * as TextUtils6 from "./../../models/text_utils/text_utils.js";
var CSSLayer = class _CSSLayer extends CSSQuery {
  static parseLayerPayload(cssModel, payload) {
    return payload.map((supports) => new _CSSLayer(cssModel, supports));
  }
  constructor(cssModel, payload) {
    super(cssModel);
    this.reinitialize(payload);
  }
  reinitialize(payload) {
    this.text = payload.text;
    this.range = payload.range ? TextUtils6.TextRange.TextRange.fromObject(payload.range) : null;
    this.styleSheetId = payload.styleSheetId;
  }
  active() {
    return true;
  }
};

// gen/front_end/core/sdk/CSSMedia.js
var CSSMedia_exports = {};
__export(CSSMedia_exports, {
  CSSMedia: () => CSSMedia,
  CSSMediaQuery: () => CSSMediaQuery,
  CSSMediaQueryExpression: () => CSSMediaQueryExpression,
  Source: () => Source
});
import * as TextUtils7 from "./../../models/text_utils/text_utils.js";
var CSSMediaQuery = class _CSSMediaQuery {
  #activeInternal;
  #expressionsInternal;
  constructor(payload) {
    this.#activeInternal = payload.active;
    this.#expressionsInternal = [];
    for (let j = 0; j < payload.expressions.length; ++j) {
      this.#expressionsInternal.push(CSSMediaQueryExpression.parsePayload(payload.expressions[j]));
    }
  }
  static parsePayload(payload) {
    return new _CSSMediaQuery(payload);
  }
  active() {
    return this.#activeInternal;
  }
  expressions() {
    return this.#expressionsInternal;
  }
};
var CSSMediaQueryExpression = class _CSSMediaQueryExpression {
  #valueInternal;
  #unitInternal;
  #featureInternal;
  #valueRangeInternal;
  #computedLengthInternal;
  constructor(payload) {
    this.#valueInternal = payload.value;
    this.#unitInternal = payload.unit;
    this.#featureInternal = payload.feature;
    this.#valueRangeInternal = payload.valueRange ? TextUtils7.TextRange.TextRange.fromObject(payload.valueRange) : null;
    this.#computedLengthInternal = payload.computedLength || null;
  }
  static parsePayload(payload) {
    return new _CSSMediaQueryExpression(payload);
  }
  value() {
    return this.#valueInternal;
  }
  unit() {
    return this.#unitInternal;
  }
  feature() {
    return this.#featureInternal;
  }
  valueRange() {
    return this.#valueRangeInternal;
  }
  computedLength() {
    return this.#computedLengthInternal;
  }
};
var CSSMedia = class _CSSMedia extends CSSQuery {
  source;
  sourceURL;
  mediaList;
  static parseMediaArrayPayload(cssModel, payload) {
    return payload.map((mq) => new _CSSMedia(cssModel, mq));
  }
  constructor(cssModel, payload) {
    super(cssModel);
    this.reinitialize(payload);
  }
  reinitialize(payload) {
    this.text = payload.text;
    this.source = payload.source;
    this.sourceURL = payload.sourceURL || "";
    this.range = payload.range ? TextUtils7.TextRange.TextRange.fromObject(payload.range) : null;
    this.styleSheetId = payload.styleSheetId;
    this.mediaList = null;
    if (payload.mediaList) {
      this.mediaList = [];
      for (let i = 0; i < payload.mediaList.length; ++i) {
        this.mediaList.push(CSSMediaQuery.parsePayload(payload.mediaList[i]));
      }
    }
  }
  active() {
    if (!this.mediaList) {
      return true;
    }
    for (let i = 0; i < this.mediaList.length; ++i) {
      if (this.mediaList[i].active()) {
        return true;
      }
    }
    return false;
  }
};
var Source = {
  LINKED_SHEET: "linkedSheet",
  INLINE_SHEET: "inlineSheet",
  MEDIA_RULE: "mediaRule",
  IMPORT_RULE: "importRule"
};

// gen/front_end/core/sdk/CSSScope.js
var CSSScope_exports = {};
__export(CSSScope_exports, {
  CSSScope: () => CSSScope
});
import * as TextUtils8 from "./../../models/text_utils/text_utils.js";
var CSSScope = class _CSSScope extends CSSQuery {
  static parseScopesPayload(cssModel, payload) {
    return payload.map((scope) => new _CSSScope(cssModel, scope));
  }
  constructor(cssModel, payload) {
    super(cssModel);
    this.reinitialize(payload);
  }
  reinitialize(payload) {
    this.text = payload.text;
    this.range = payload.range ? TextUtils8.TextRange.TextRange.fromObject(payload.range) : null;
    this.styleSheetId = payload.styleSheetId;
  }
  active() {
    return true;
  }
};

// gen/front_end/core/sdk/CSSStyleDeclaration.js
var CSSStyleDeclaration_exports = {};
__export(CSSStyleDeclaration_exports, {
  CSSStyleDeclaration: () => CSSStyleDeclaration,
  Type: () => Type3
});
import * as TextUtils9 from "./../../models/text_utils/text_utils.js";
var CSSStyleDeclaration = class {
  #cssModelInternal;
  parentRule;
  #allPropertiesInternal;
  styleSheetId;
  range;
  cssText;
  #shorthandValues;
  #shorthandIsImportant;
  #activePropertyMap;
  #leadingPropertiesInternal;
  type;
  constructor(cssModel, parentRule, payload, type) {
    this.#cssModelInternal = cssModel;
    this.parentRule = parentRule;
    this.#reinitialize(payload);
    this.type = type;
  }
  rebase(edit) {
    if (this.styleSheetId !== edit.styleSheetId || !this.range) {
      return;
    }
    if (edit.oldRange.equal(this.range)) {
      this.#reinitialize(edit.payload);
    } else {
      this.range = this.range.rebaseAfterTextEdit(edit.oldRange, edit.newRange);
      for (let i = 0; i < this.#allPropertiesInternal.length; ++i) {
        this.#allPropertiesInternal[i].rebase(edit);
      }
    }
  }
  #reinitialize(payload) {
    this.styleSheetId = payload.styleSheetId;
    this.range = payload.range ? TextUtils9.TextRange.TextRange.fromObject(payload.range) : null;
    const shorthandEntries = payload.shorthandEntries;
    this.#shorthandValues = /* @__PURE__ */ new Map();
    this.#shorthandIsImportant = /* @__PURE__ */ new Set();
    for (let i = 0; i < shorthandEntries.length; ++i) {
      this.#shorthandValues.set(shorthandEntries[i].name, shorthandEntries[i].value);
      if (shorthandEntries[i].important) {
        this.#shorthandIsImportant.add(shorthandEntries[i].name);
      }
    }
    this.#allPropertiesInternal = [];
    if (payload.cssText && this.range) {
      const longhands = [];
      for (const cssProperty of payload.cssProperties) {
        const range = cssProperty.range;
        if (!range) {
          continue;
        }
        const parsedProperty = CSSProperty.parsePayload(this, this.#allPropertiesInternal.length, cssProperty);
        this.#allPropertiesInternal.push(parsedProperty);
        for (const longhand of parsedProperty.getLonghandProperties()) {
          longhands.push(longhand);
        }
      }
      for (const longhand of longhands) {
        longhand.index = this.#allPropertiesInternal.length;
        this.#allPropertiesInternal.push(longhand);
      }
    } else {
      for (const cssProperty of payload.cssProperties) {
        this.#allPropertiesInternal.push(
          CSSProperty.parsePayload(this, this.#allPropertiesInternal.length, cssProperty)
        );
      }
    }
    this.#generateSyntheticPropertiesIfNeeded();
    this.#computeInactiveProperties();
    this.#activePropertyMap = /* @__PURE__ */ new Map();
    for (const property of this.#allPropertiesInternal) {
      if (!property.activeInStyle()) {
        continue;
      }
      this.#activePropertyMap.set(property.name, property);
    }
    this.cssText = payload.cssText;
    this.#leadingPropertiesInternal = null;
  }
  #generateSyntheticPropertiesIfNeeded() {
    if (this.range) {
      return;
    }
    if (!this.#shorthandValues.size) {
      return;
    }
    const propertiesSet = /* @__PURE__ */ new Set();
    for (const property of this.#allPropertiesInternal) {
      propertiesSet.add(property.name);
    }
    const generatedProperties2 = [];
    for (const property of this.#allPropertiesInternal) {
      const shorthands = cssMetadata().getShorthands(property.name) || [];
      for (const shorthand of shorthands) {
        if (propertiesSet.has(shorthand)) {
          continue;
        }
        const shorthandValue = this.#shorthandValues.get(shorthand);
        if (!shorthandValue) {
          continue;
        }
        const shorthandImportance = Boolean(this.#shorthandIsImportant.has(shorthand));
        const shorthandProperty = new CSSProperty(
          this,
          this.allProperties().length,
          shorthand,
          shorthandValue,
          shorthandImportance,
          false,
          true,
          false
        );
        generatedProperties2.push(shorthandProperty);
        propertiesSet.add(shorthand);
      }
    }
    this.#allPropertiesInternal = this.#allPropertiesInternal.concat(generatedProperties2);
  }
  #computeLeadingProperties() {
    function propertyHasRange(property) {
      return Boolean(property.range);
    }
    if (this.range) {
      return this.#allPropertiesInternal.filter(propertyHasRange);
    }
    const leadingProperties = [];
    for (const property of this.#allPropertiesInternal) {
      const shorthands = cssMetadata().getShorthands(property.name) || [];
      let belongToAnyShorthand = false;
      for (const shorthand of shorthands) {
        if (this.#shorthandValues.get(shorthand)) {
          belongToAnyShorthand = true;
          break;
        }
      }
      if (!belongToAnyShorthand) {
        leadingProperties.push(property);
      }
    }
    return leadingProperties;
  }
  leadingProperties() {
    if (!this.#leadingPropertiesInternal) {
      this.#leadingPropertiesInternal = this.#computeLeadingProperties();
    }
    return this.#leadingPropertiesInternal;
  }
  target() {
    return this.#cssModelInternal.target();
  }
  cssModel() {
    return this.#cssModelInternal;
  }
  #computeInactiveProperties() {
    const activeProperties = /* @__PURE__ */ new Map();
    const processedLonghands = /* @__PURE__ */ new Set();
    for (const property of this.#allPropertiesInternal) {
      const metadata = cssMetadata();
      const canonicalName = metadata.canonicalPropertyName(property.name);
      if (property.disabled || !property.parsedOk) {
        if (!property.disabled && metadata.isCustomProperty(property.name)) {
          activeProperties.get(canonicalName)?.setActive(false);
          activeProperties.delete(canonicalName);
        }
        property.setActive(false);
        continue;
      }
      if (processedLonghands.has(property)) {
        continue;
      }
      for (const longhand of property.getLonghandProperties()) {
        const activeLonghand = activeProperties.get(longhand.name);
        if (!activeLonghand) {
          activeProperties.set(longhand.name, longhand);
        } else if (!activeLonghand.important || longhand.important) {
          activeLonghand.setActive(false);
          activeProperties.set(longhand.name, longhand);
        } else {
          longhand.setActive(false);
        }
        processedLonghands.add(longhand);
      }
      const activeProperty = activeProperties.get(canonicalName);
      if (!activeProperty) {
        activeProperties.set(canonicalName, property);
      } else if (!activeProperty.important || property.important) {
        activeProperty.setActive(false);
        activeProperties.set(canonicalName, property);
      } else {
        property.setActive(false);
      }
    }
  }
  allProperties() {
    return this.#allPropertiesInternal;
  }
  hasActiveProperty(name) {
    return this.#activePropertyMap.has(name);
  }
  getPropertyValue(name) {
    const property = this.#activePropertyMap.get(name);
    return property ? property.value : "";
  }
  isPropertyImplicit(name) {
    const property = this.#activePropertyMap.get(name);
    return property ? property.implicit : false;
  }
  propertyAt(index) {
    return index < this.allProperties().length ? this.allProperties()[index] : null;
  }
  pastLastSourcePropertyIndex() {
    for (let i = this.allProperties().length - 1; i >= 0; --i) {
      if (this.allProperties()[i].range) {
        return i + 1;
      }
    }
    return 0;
  }
  #insertionRange(index) {
    const property = this.propertyAt(index);
    if (property && property.range) {
      return property.range.collapseToStart();
    }
    if (!this.range) {
      throw new Error("CSSStyleDeclaration.range is null");
    }
    return this.range.collapseToEnd();
  }
  newBlankProperty(index) {
    index = typeof index === "undefined" ? this.pastLastSourcePropertyIndex() : index;
    const property = new CSSProperty(this, index, "", "", false, false, true, false, "", this.#insertionRange(index));
    return property;
  }
  setText(text, majorChange) {
    if (!this.range || !this.styleSheetId) {
      return Promise.resolve(false);
    }
    return this.#cssModelInternal.setStyleText(this.styleSheetId, this.range, text, majorChange);
  }
  insertPropertyAt(index, name, value, userCallback) {
    void this.newBlankProperty(index).setText(name + ": " + value + ";", false, true).then(userCallback);
  }
  appendProperty(name, value, userCallback) {
    this.insertPropertyAt(this.allProperties().length, name, value, userCallback);
  }
};
var Type3 = /* @__PURE__ */ ((Type22) => {
  Type22["Regular"] = "Regular";
  Type22["Inline"] = "Inline";
  Type22["Attributes"] = "Attributes";
  Type22["Pseudo"] = "Pseudo";
  return Type22;
})(Type3 || {});

// gen/front_end/core/sdk/CSSSupports.js
var CSSSupports_exports = {};
__export(CSSSupports_exports, {
  CSSSupports: () => CSSSupports
});
import * as TextUtils10 from "./../../models/text_utils/text_utils.js";
var CSSSupports = class _CSSSupports extends CSSQuery {
  static parseSupportsPayload(cssModel, payload) {
    return payload.map((supports) => new _CSSSupports(cssModel, supports));
  }
  #active = true;
  constructor(cssModel, payload) {
    super(cssModel);
    this.reinitialize(payload);
  }
  reinitialize(payload) {
    this.text = payload.text;
    this.range = payload.range ? TextUtils10.TextRange.TextRange.fromObject(payload.range) : null;
    this.styleSheetId = payload.styleSheetId;
    this.#active = payload.active;
  }
  active() {
    return this.#active;
  }
};

// gen/front_end/core/sdk/CSSRule.js
var CSSRule = class {
  cssModelInternal;
  styleSheetId;
  sourceURL;
  origin;
  style;
  constructor(cssModel, payload) {
    this.cssModelInternal = cssModel;
    this.styleSheetId = payload.styleSheetId;
    if (this.styleSheetId) {
      const styleSheetHeader = this.getStyleSheetHeader(this.styleSheetId);
      this.sourceURL = styleSheetHeader.sourceURL;
    }
    this.origin = payload.origin;
    this.style = new CSSStyleDeclaration(this.cssModelInternal, this, payload.style, Type3.Regular);
  }
  rebase(edit) {
    if (this.styleSheetId !== edit.styleSheetId) {
      return;
    }
    this.style.rebase(edit);
  }
  resourceURL() {
    if (!this.styleSheetId) {
      return Platform5.DevToolsPath.EmptyUrlString;
    }
    const styleSheetHeader = this.getStyleSheetHeader(this.styleSheetId);
    return styleSheetHeader.resourceURL();
  }
  isUserAgent() {
    return this.origin === CSS2.StyleSheetOrigin.UserAgent;
  }
  isInjected() {
    return this.origin === CSS2.StyleSheetOrigin.Injected;
  }
  isViaInspector() {
    return this.origin === CSS2.StyleSheetOrigin.Inspector;
  }
  isRegular() {
    return this.origin === CSS2.StyleSheetOrigin.Regular;
  }
  isKeyframeRule() {
    return false;
  }
  cssModel() {
    return this.cssModelInternal;
  }
  getStyleSheetHeader(styleSheetId) {
    const styleSheetHeader = this.cssModelInternal.styleSheetHeaderForId(styleSheetId);
    console.assert(styleSheetHeader !== null);
    return styleSheetHeader;
  }
};
var CSSValue = class {
  text;
  range;
  specificity;
  constructor(payload) {
    this.text = payload.text;
    if (payload.range) {
      this.range = TextUtils11.TextRange.TextRange.fromObject(payload.range);
    }
    if (payload.specificity) {
      this.specificity = payload.specificity;
    }
  }
  rebase(edit) {
    if (!this.range) {
      return;
    }
    this.range = this.range.rebaseAfterTextEdit(edit.oldRange, edit.newRange);
  }
};
var CSSStyleRule = class _CSSStyleRule extends CSSRule {
  selectors;
  nestingSelectors;
  media;
  containerQueries;
  supports;
  scopes;
  layers;
  ruleTypes;
  wasUsed;
  constructor(cssModel, payload, wasUsed) {
    super(cssModel, { origin: payload.origin, style: payload.style, styleSheetId: payload.styleSheetId });
    this.reinitializeSelectors(payload.selectorList);
    this.nestingSelectors = payload.nestingSelectors;
    this.media = payload.media ? CSSMedia.parseMediaArrayPayload(cssModel, payload.media) : [];
    this.containerQueries = payload.containerQueries ? CSSContainerQuery.parseContainerQueriesPayload(cssModel, payload.containerQueries) : [];
    this.scopes = payload.scopes ? CSSScope.parseScopesPayload(cssModel, payload.scopes) : [];
    this.supports = payload.supports ? CSSSupports.parseSupportsPayload(cssModel, payload.supports) : [];
    this.layers = payload.layers ? CSSLayer.parseLayerPayload(cssModel, payload.layers) : [];
    this.ruleTypes = payload.ruleTypes || [];
    this.wasUsed = wasUsed || false;
  }
  static createDummyRule(cssModel, selectorText) {
    const dummyPayload = {
      selectorList: {
        text: "",
        selectors: [{ text: selectorText, value: void 0 }]
      },
      style: {
        styleSheetId: "0",
        range: new TextUtils11.TextRange.TextRange(0, 0, 0, 0),
        shorthandEntries: [],
        cssProperties: []
      },
      origin: CSS2.StyleSheetOrigin.Inspector
    };
    return new _CSSStyleRule(cssModel, dummyPayload);
  }
  reinitializeSelectors(selectorList) {
    this.selectors = [];
    for (let i = 0; i < selectorList.selectors.length; ++i) {
      this.selectors.push(new CSSValue(selectorList.selectors[i]));
    }
  }
  setSelectorText(newSelector) {
    const styleSheetId = this.styleSheetId;
    if (!styleSheetId) {
      throw "No rule stylesheet id";
    }
    const range = this.selectorRange();
    if (!range) {
      throw "Rule selector is not editable";
    }
    return this.cssModelInternal.setSelectorText(styleSheetId, range, newSelector);
  }
  selectorText() {
    return this.selectors.map((selector) => selector.text).join(", ");
  }
  selectorRange() {
    if (this.selectors.length === 0) {
      return null;
    }
    const firstRange = this.selectors[0].range;
    const lastRange = this.selectors[this.selectors.length - 1].range;
    if (!firstRange || !lastRange) {
      return null;
    }
    return new TextUtils11.TextRange.TextRange(
      firstRange.startLine,
      firstRange.startColumn,
      lastRange.endLine,
      lastRange.endColumn
    );
  }
  lineNumberInSource(selectorIndex) {
    const selector = this.selectors[selectorIndex];
    if (!selector || !selector.range || !this.styleSheetId) {
      return 0;
    }
    const styleSheetHeader = this.getStyleSheetHeader(this.styleSheetId);
    return styleSheetHeader.lineNumberInSource(selector.range.startLine);
  }
  columnNumberInSource(selectorIndex) {
    const selector = this.selectors[selectorIndex];
    if (!selector || !selector.range || !this.styleSheetId) {
      return void 0;
    }
    const styleSheetHeader = this.getStyleSheetHeader(this.styleSheetId);
    return styleSheetHeader.columnNumberInSource(selector.range.startLine, selector.range.startColumn);
  }
  rebase(edit) {
    if (this.styleSheetId !== edit.styleSheetId) {
      return;
    }
    const range = this.selectorRange();
    if (range && range.equal(edit.oldRange)) {
      this.reinitializeSelectors(edit.payload);
    } else {
      for (let i = 0; i < this.selectors.length; ++i) {
        this.selectors[i].rebase(edit);
      }
    }
    this.media.forEach((media) => media.rebase(edit));
    this.containerQueries.forEach((cq) => cq.rebase(edit));
    this.scopes.forEach((scope) => scope.rebase(edit));
    this.supports.forEach((supports) => supports.rebase(edit));
    super.rebase(edit);
  }
};
var CSSPropertyRule = class extends CSSRule {
  #name;
  constructor(cssModel, payload) {
    super(cssModel, { origin: payload.origin, style: payload.style, styleSheetId: payload.styleSheetId });
    this.#name = new CSSValue(payload.propertyName);
  }
  propertyName() {
    return this.#name;
  }
  initialValue() {
    return this.style.hasActiveProperty("initial-value") ? this.style.getPropertyValue("initial-value") : null;
  }
  syntax() {
    return this.style.getPropertyValue("syntax");
  }
  inherits() {
    return this.style.getPropertyValue("inherits") === "true";
  }
  setPropertyName(newPropertyName) {
    const styleSheetId = this.styleSheetId;
    if (!styleSheetId) {
      throw new Error("No rule stylesheet id");
    }
    const range = this.#name.range;
    if (!range) {
      throw new Error("Property name is not editable");
    }
    return this.cssModelInternal.setPropertyRulePropertyName(styleSheetId, range, newPropertyName);
  }
};
var CSSFontPaletteValuesRule = class extends CSSRule {
  #paletteName;
  constructor(cssModel, payload) {
    super(cssModel, { origin: payload.origin, style: payload.style, styleSheetId: payload.styleSheetId });
    this.#paletteName = new CSSValue(payload.fontPaletteName);
  }
  name() {
    return this.#paletteName;
  }
};
var CSSKeyframesRule = class {
  #animationName;
  #keyframesInternal;
  constructor(cssModel, payload) {
    this.#animationName = new CSSValue(payload.animationName);
    this.#keyframesInternal = payload.keyframes.map((keyframeRule) => new CSSKeyframeRule(cssModel, keyframeRule));
  }
  name() {
    return this.#animationName;
  }
  keyframes() {
    return this.#keyframesInternal;
  }
};
var CSSKeyframeRule = class extends CSSRule {
  #keyText;
  constructor(cssModel, payload) {
    super(cssModel, { origin: payload.origin, style: payload.style, styleSheetId: payload.styleSheetId });
    this.reinitializeKey(payload.keyText);
  }
  key() {
    return this.#keyText;
  }
  reinitializeKey(payload) {
    this.#keyText = new CSSValue(payload);
  }
  rebase(edit) {
    if (this.styleSheetId !== edit.styleSheetId || !this.#keyText.range) {
      return;
    }
    if (edit.oldRange.equal(this.#keyText.range)) {
      this.reinitializeKey(edit.payload);
    } else {
      this.#keyText.rebase(edit);
    }
    super.rebase(edit);
  }
  isKeyframeRule() {
    return true;
  }
  setKeyText(newKeyText) {
    const styleSheetId = this.styleSheetId;
    if (!styleSheetId) {
      throw "No rule stylesheet id";
    }
    const range = this.#keyText.range;
    if (!range) {
      throw "Keyframe key is not editable";
    }
    return this.cssModelInternal.setKeyframeKey(styleSheetId, range, newKeyText);
  }
};
var CSSPositionTryRule = class extends CSSRule {
  #name;
  #active;
  constructor(cssModel, payload) {
    super(cssModel, { origin: payload.origin, style: payload.style, styleSheetId: payload.styleSheetId });
    this.#name = new CSSValue(payload.name);
    this.#active = payload.active;
  }
  name() {
    return this.#name;
  }
  active() {
    return this.#active;
  }
};

// gen/front_end/core/sdk/CSSMatchedStyles.js
function containsStyle(styles, query) {
  if (!query.styleSheetId || !query.range) {
    return false;
  }
  for (const style of styles) {
    if (query.styleSheetId === style.styleSheetId && style.range && query.range.equal(style.range)) {
      return true;
    }
  }
  return false;
}
function containsCustomProperties(style) {
  const properties = style.allProperties();
  return properties.some((property) => cssMetadata().isCustomProperty(property.name));
}
function containsInherited(style) {
  const properties = style.allProperties();
  for (let i = 0; i < properties.length; ++i) {
    const property = properties[i];
    if (property.activeInStyle() && cssMetadata().isPropertyInherited(property.name)) {
      return true;
    }
  }
  return false;
}
function cleanUserAgentPayload(payload) {
  for (const ruleMatch of payload) {
    cleanUserAgentSelectors(ruleMatch);
  }
  const cleanMatchedPayload = [];
  for (const ruleMatch of payload) {
    const lastMatch = cleanMatchedPayload[cleanMatchedPayload.length - 1];
    if (!lastMatch || ruleMatch.rule.origin !== "user-agent" || lastMatch.rule.origin !== "user-agent" || ruleMatch.rule.selectorList.text !== lastMatch.rule.selectorList.text || mediaText(ruleMatch) !== mediaText(lastMatch)) {
      cleanMatchedPayload.push(ruleMatch);
      continue;
    }
    mergeRule(ruleMatch, lastMatch);
  }
  return cleanMatchedPayload;
  function mergeRule(from, to) {
    const shorthands = /* @__PURE__ */ new Map();
    const properties = /* @__PURE__ */ new Map();
    for (const entry of to.rule.style.shorthandEntries) {
      shorthands.set(entry.name, entry.value);
    }
    for (const entry of to.rule.style.cssProperties) {
      properties.set(entry.name, entry.value);
    }
    for (const entry of from.rule.style.shorthandEntries) {
      shorthands.set(entry.name, entry.value);
    }
    for (const entry of from.rule.style.cssProperties) {
      properties.set(entry.name, entry.value);
    }
    to.rule.style.shorthandEntries = [...shorthands.entries()].map(([name, value]) => ({ name, value }));
    to.rule.style.cssProperties = [...properties.entries()].map(([name, value]) => ({ name, value }));
  }
  function mediaText(ruleMatch) {
    if (!ruleMatch.rule.media) {
      return null;
    }
    return ruleMatch.rule.media.map((media) => media.text).join(", ");
  }
  function cleanUserAgentSelectors(ruleMatch) {
    const { matchingSelectors, rule } = ruleMatch;
    if (rule.origin !== "user-agent" || !matchingSelectors.length) {
      return;
    }
    rule.selectorList.selectors = rule.selectorList.selectors.filter((item, i) => matchingSelectors.includes(i));
    rule.selectorList.text = rule.selectorList.selectors.map((item) => item.text).join(", ");
    ruleMatch.matchingSelectors = matchingSelectors.map((item, i) => i);
  }
}
function customHighlightNamesToMatchingSelectorIndices(ruleMatch) {
  const highlightNamesToMatchingSelectors = /* @__PURE__ */ new Map();
  for (let i = 0; i < ruleMatch.matchingSelectors.length; i++) {
    const matchingSelectorIndex = ruleMatch.matchingSelectors[i];
    const selectorText = ruleMatch.rule.selectorList.selectors[matchingSelectorIndex].text;
    const highlightNameMatch = selectorText.match(/::highlight\((.*)\)/);
    if (highlightNameMatch) {
      const highlightName = highlightNameMatch[1];
      const selectorsForName = highlightNamesToMatchingSelectors.get(highlightName);
      if (selectorsForName) {
        selectorsForName.push(matchingSelectorIndex);
      } else {
        highlightNamesToMatchingSelectors.set(highlightName, [matchingSelectorIndex]);
      }
    }
  }
  return highlightNamesToMatchingSelectors;
}
function queryMatches(style) {
  if (!style.parentRule) {
    return true;
  }
  const parentRule = style.parentRule;
  const queries = [...parentRule.media, ...parentRule.containerQueries, ...parentRule.supports, ...parentRule.scopes];
  for (const query of queries) {
    if (!query.active()) {
      return false;
    }
  }
  return true;
}
var CSSRegisteredProperty = class {
  #registration;
  #cssModel;
  #style;
  constructor(cssModel, registration) {
    this.#cssModel = cssModel;
    this.#registration = registration;
  }
  isAtProperty() {
    return this.#registration instanceof CSSPropertyRule;
  }
  propertyName() {
    return this.#registration instanceof CSSPropertyRule ? this.#registration.propertyName().text : this.#registration.propertyName;
  }
  initialValue() {
    return this.#registration instanceof CSSPropertyRule ? this.#registration.initialValue() : this.#registration.initialValue?.text ?? null;
  }
  inherits() {
    return this.#registration instanceof CSSPropertyRule ? this.#registration.inherits() : this.#registration.inherits;
  }
  syntax() {
    return this.#registration instanceof CSSPropertyRule ? this.#registration.syntax() : `"${this.#registration.syntax}"`;
  }
  #asCSSProperties() {
    if (this.#registration instanceof CSSPropertyRule) {
      return [];
    }
    const { inherits, initialValue, syntax } = this.#registration;
    const properties = [
      { name: "inherits", value: `${inherits}` },
      { name: "syntax", value: `"${syntax}"` }
    ];
    if (initialValue !== void 0) {
      properties.push({ name: "initial-value", value: initialValue.text });
    }
    return properties;
  }
  style() {
    if (!this.#style) {
      this.#style = this.#registration instanceof CSSPropertyRule ? this.#registration.style : new CSSStyleDeclaration(
        this.#cssModel,
        null,
        { cssProperties: this.#asCSSProperties(), shorthandEntries: [] },
        Type3.Pseudo
      );
    }
    return this.#style;
  }
};
var CSSMatchedStyles = class _CSSMatchedStyles {
  #cssModelInternal;
  #nodeInternal;
  #addedStyles;
  #matchingSelectors;
  #keyframesInternal;
  #registeredProperties;
  #registeredPropertyMap = /* @__PURE__ */ new Map();
  #nodeForStyleInternal;
  #inheritedStyles;
  #styleToDOMCascade;
  #parentLayoutNodeId;
  #positionTryRules;
  #activePositionFallbackIndex;
  #mainDOMCascade;
  #pseudoDOMCascades;
  #customHighlightPseudoDOMCascades;
  #fontPaletteValuesRule;
  static async create(payload) {
    const cssMatchedStyles = new _CSSMatchedStyles(payload);
    await cssMatchedStyles.init(payload);
    return cssMatchedStyles;
  }
  constructor({
    cssModel,
    node,
    animationsPayload,
    parentLayoutNodeId,
    positionTryRules,
    propertyRules,
    cssPropertyRegistrations,
    fontPaletteValuesRule,
    activePositionFallbackIndex
  }) {
    this.#cssModelInternal = cssModel;
    this.#nodeInternal = node;
    this.#addedStyles = /* @__PURE__ */ new Map();
    this.#matchingSelectors = /* @__PURE__ */ new Map();
    this.#registeredProperties = [
      ...propertyRules.map((rule) => new CSSPropertyRule(cssModel, rule)),
      ...cssPropertyRegistrations
    ].map((r) => new CSSRegisteredProperty(cssModel, r));
    this.#keyframesInternal = [];
    if (animationsPayload) {
      this.#keyframesInternal = animationsPayload.map((rule) => new CSSKeyframesRule(cssModel, rule));
    }
    this.#positionTryRules = positionTryRules.map((rule) => new CSSPositionTryRule(cssModel, rule));
    this.#parentLayoutNodeId = parentLayoutNodeId;
    this.#fontPaletteValuesRule = fontPaletteValuesRule ? new CSSFontPaletteValuesRule(cssModel, fontPaletteValuesRule) : void 0;
    this.#nodeForStyleInternal = /* @__PURE__ */ new Map();
    this.#inheritedStyles = /* @__PURE__ */ new Set();
    this.#styleToDOMCascade = /* @__PURE__ */ new Map();
    this.#registeredPropertyMap = /* @__PURE__ */ new Map();
    this.#activePositionFallbackIndex = activePositionFallbackIndex;
  }
  async init({
    matchedPayload,
    inheritedPayload,
    inlinePayload,
    attributesPayload,
    pseudoPayload,
    inheritedPseudoPayload
  }) {
    matchedPayload = cleanUserAgentPayload(matchedPayload);
    for (const inheritedResult of inheritedPayload) {
      inheritedResult.matchedCSSRules = cleanUserAgentPayload(inheritedResult.matchedCSSRules);
    }
    this.#mainDOMCascade = await this.buildMainCascade(inlinePayload, attributesPayload, matchedPayload, inheritedPayload);
    [this.#pseudoDOMCascades, this.#customHighlightPseudoDOMCascades] = this.buildPseudoCascades(pseudoPayload, inheritedPseudoPayload);
    for (const domCascade of Array.from(this.#customHighlightPseudoDOMCascades.values()).concat(Array.from(this.#pseudoDOMCascades.values())).concat(this.#mainDOMCascade)) {
      for (const style of domCascade.styles()) {
        this.#styleToDOMCascade.set(style, domCascade);
      }
    }
    for (const prop of this.#registeredProperties) {
      this.#registeredPropertyMap.set(prop.propertyName(), prop);
    }
  }
  async buildMainCascade(inlinePayload, attributesPayload, matchedPayload, inheritedPayload) {
    const nodeCascades = [];
    const nodeStyles = [];
    function addAttributesStyle() {
      if (!attributesPayload) {
        return;
      }
      const style = new CSSStyleDeclaration(this.#cssModelInternal, null, attributesPayload, Type3.Attributes);
      this.#nodeForStyleInternal.set(style, this.#nodeInternal);
      nodeStyles.push(style);
    }
    if (inlinePayload && this.#nodeInternal.nodeType() === Node.ELEMENT_NODE) {
      const style = new CSSStyleDeclaration(this.#cssModelInternal, null, inlinePayload, Type3.Inline);
      this.#nodeForStyleInternal.set(style, this.#nodeInternal);
      nodeStyles.push(style);
    }
    let addedAttributesStyle;
    for (let i = matchedPayload.length - 1; i >= 0; --i) {
      const rule = new CSSStyleRule(this.#cssModelInternal, matchedPayload[i].rule);
      if ((rule.isInjected() || rule.isUserAgent()) && !addedAttributesStyle) {
        addedAttributesStyle = true;
        addAttributesStyle.call(this);
      }
      this.#nodeForStyleInternal.set(rule.style, this.#nodeInternal);
      nodeStyles.push(rule.style);
      this.addMatchingSelectors(this.#nodeInternal, rule, matchedPayload[i].matchingSelectors);
    }
    if (!addedAttributesStyle) {
      addAttributesStyle.call(this);
    }
    nodeCascades.push(new NodeCascade(
      this,
      nodeStyles,
      false
      /* #isInherited */
    ));
    let parentNode = this.#nodeInternal.parentNode;
    const traverseParentInFlatTree = async (node) => {
      if (node.hasAssignedSlot()) {
        return await node.assignedSlot?.deferredNode.resolvePromise() ?? null;
      }
      return node.parentNode;
    };
    for (let i = 0; parentNode && inheritedPayload && i < inheritedPayload.length; ++i) {
      const inheritedStyles = [];
      const entryPayload = inheritedPayload[i];
      const inheritedInlineStyle = entryPayload.inlineStyle ? new CSSStyleDeclaration(this.#cssModelInternal, null, entryPayload.inlineStyle, Type3.Inline) : null;
      if (inheritedInlineStyle && containsInherited(inheritedInlineStyle)) {
        this.#nodeForStyleInternal.set(inheritedInlineStyle, parentNode);
        inheritedStyles.push(inheritedInlineStyle);
        this.#inheritedStyles.add(inheritedInlineStyle);
      }
      const inheritedMatchedCSSRules = entryPayload.matchedCSSRules || [];
      for (let j = inheritedMatchedCSSRules.length - 1; j >= 0; --j) {
        const inheritedRule = new CSSStyleRule(this.#cssModelInternal, inheritedMatchedCSSRules[j].rule);
        this.addMatchingSelectors(parentNode, inheritedRule, inheritedMatchedCSSRules[j].matchingSelectors);
        if (!containsInherited(inheritedRule.style)) {
          continue;
        }
        if (!containsCustomProperties(inheritedRule.style)) {
          if (containsStyle(nodeStyles, inheritedRule.style) || containsStyle(this.#inheritedStyles, inheritedRule.style)) {
            continue;
          }
        }
        this.#nodeForStyleInternal.set(inheritedRule.style, parentNode);
        inheritedStyles.push(inheritedRule.style);
        this.#inheritedStyles.add(inheritedRule.style);
      }
      parentNode = await traverseParentInFlatTree(parentNode);
      nodeCascades.push(new NodeCascade(
        this,
        inheritedStyles,
        true
        /* #isInherited */
      ));
    }
    return new DOMInheritanceCascade(nodeCascades, this.#registeredProperties);
  }
  /**
   * Pseudo rule matches received via the inspector protocol are grouped by pseudo type.
   * For custom highlight pseudos, we need to instead group the rule matches by highlight
   * name in order to produce separate cascades for each highlight name. This is necessary
   * so that styles of ::highlight(foo) are not shown as overriding styles of ::highlight(bar).
   *
   * This helper function takes a list of rule matches and generates separate NodeCascades
   * for each custom highlight name that was matched.
   */
  buildSplitCustomHighlightCascades(rules, node, isInherited, pseudoCascades) {
    const splitHighlightRules = /* @__PURE__ */ new Map();
    for (let j = rules.length - 1; j >= 0; --j) {
      const highlightNamesToMatchingSelectorIndices = customHighlightNamesToMatchingSelectorIndices(rules[j]);
      for (const [highlightName, matchingSelectors] of highlightNamesToMatchingSelectorIndices) {
        const pseudoRule = new CSSStyleRule(this.#cssModelInternal, rules[j].rule);
        this.#nodeForStyleInternal.set(pseudoRule.style, node);
        if (isInherited) {
          this.#inheritedStyles.add(pseudoRule.style);
        }
        this.addMatchingSelectors(node, pseudoRule, matchingSelectors);
        const ruleListForHighlightName = splitHighlightRules.get(highlightName);
        if (ruleListForHighlightName) {
          ruleListForHighlightName.push(pseudoRule.style);
        } else {
          splitHighlightRules.set(highlightName, [pseudoRule.style]);
        }
      }
    }
    for (const [highlightName, highlightStyles] of splitHighlightRules) {
      const nodeCascade = new NodeCascade(
        this,
        highlightStyles,
        isInherited,
        true
        /* #isHighlightPseudoCascade*/
      );
      const cascadeListForHighlightName = pseudoCascades.get(highlightName);
      if (cascadeListForHighlightName) {
        cascadeListForHighlightName.push(nodeCascade);
      } else {
        pseudoCascades.set(highlightName, [nodeCascade]);
      }
    }
  }
  buildPseudoCascades(pseudoPayload, inheritedPseudoPayload) {
    const pseudoInheritanceCascades = /* @__PURE__ */ new Map();
    const customHighlightPseudoInheritanceCascades = /* @__PURE__ */ new Map();
    if (!pseudoPayload) {
      return [pseudoInheritanceCascades, customHighlightPseudoInheritanceCascades];
    }
    const pseudoCascades = /* @__PURE__ */ new Map();
    const customHighlightPseudoCascades = /* @__PURE__ */ new Map();
    for (let i = 0; i < pseudoPayload.length; ++i) {
      const entryPayload = pseudoPayload[i];
      const pseudoElement = this.#nodeInternal.pseudoElements().get(entryPayload.pseudoType)?.at(-1) || null;
      const pseudoStyles = [];
      const rules = entryPayload.matches || [];
      if (entryPayload.pseudoType === DOM.PseudoType.Highlight) {
        this.buildSplitCustomHighlightCascades(
          rules,
          this.#nodeInternal,
          false,
          customHighlightPseudoCascades
        );
      } else {
        for (let j = rules.length - 1; j >= 0; --j) {
          const pseudoRule = new CSSStyleRule(this.#cssModelInternal, rules[j].rule);
          pseudoStyles.push(pseudoRule.style);
          const nodeForStyle = cssMetadata().isHighlightPseudoType(entryPayload.pseudoType) ? this.#nodeInternal : pseudoElement;
          this.#nodeForStyleInternal.set(pseudoRule.style, nodeForStyle);
          if (nodeForStyle) {
            this.addMatchingSelectors(nodeForStyle, pseudoRule, rules[j].matchingSelectors);
          }
        }
        const isHighlightPseudoCascade = cssMetadata().isHighlightPseudoType(entryPayload.pseudoType);
        const nodeCascade = new NodeCascade(
          this,
          pseudoStyles,
          false,
          isHighlightPseudoCascade
          /* #isHighlightPseudoCascade*/
        );
        pseudoCascades.set(entryPayload.pseudoType, [nodeCascade]);
      }
    }
    if (inheritedPseudoPayload) {
      let parentNode = this.#nodeInternal.parentNode;
      for (let i = 0; parentNode && i < inheritedPseudoPayload.length; ++i) {
        const inheritedPseudoMatches = inheritedPseudoPayload[i].pseudoElements;
        for (let j = 0; j < inheritedPseudoMatches.length; ++j) {
          const inheritedEntryPayload = inheritedPseudoMatches[j];
          const rules = inheritedEntryPayload.matches || [];
          if (inheritedEntryPayload.pseudoType === DOM.PseudoType.Highlight) {
            this.buildSplitCustomHighlightCascades(
              rules,
              parentNode,
              true,
              customHighlightPseudoCascades
            );
          } else {
            const pseudoStyles = [];
            for (let k = rules.length - 1; k >= 0; --k) {
              const pseudoRule = new CSSStyleRule(this.#cssModelInternal, rules[k].rule);
              pseudoStyles.push(pseudoRule.style);
              this.#nodeForStyleInternal.set(pseudoRule.style, parentNode);
              this.#inheritedStyles.add(pseudoRule.style);
              this.addMatchingSelectors(parentNode, pseudoRule, rules[k].matchingSelectors);
            }
            const isHighlightPseudoCascade = cssMetadata().isHighlightPseudoType(inheritedEntryPayload.pseudoType);
            const nodeCascade = new NodeCascade(
              this,
              pseudoStyles,
              true,
              isHighlightPseudoCascade
              /* #isHighlightPseudoCascade*/
            );
            const cascadeListForPseudoType = pseudoCascades.get(inheritedEntryPayload.pseudoType);
            if (cascadeListForPseudoType) {
              cascadeListForPseudoType.push(nodeCascade);
            } else {
              pseudoCascades.set(inheritedEntryPayload.pseudoType, [nodeCascade]);
            }
          }
        }
        parentNode = parentNode.parentNode;
      }
    }
    for (const [pseudoType, nodeCascade] of pseudoCascades.entries()) {
      pseudoInheritanceCascades.set(pseudoType, new DOMInheritanceCascade(nodeCascade, this.#registeredProperties));
    }
    for (const [highlightName, nodeCascade] of customHighlightPseudoCascades.entries()) {
      customHighlightPseudoInheritanceCascades.set(
        highlightName,
        new DOMInheritanceCascade(nodeCascade, this.#registeredProperties)
      );
    }
    return [pseudoInheritanceCascades, customHighlightPseudoInheritanceCascades];
  }
  addMatchingSelectors(node, rule, matchingSelectorIndices) {
    for (const matchingSelectorIndex of matchingSelectorIndices) {
      const selector = rule.selectors[matchingSelectorIndex];
      if (selector) {
        this.setSelectorMatches(node, selector.text, true);
      }
    }
  }
  node() {
    return this.#nodeInternal;
  }
  cssModel() {
    return this.#cssModelInternal;
  }
  hasMatchingSelectors(rule) {
    return (rule.selectors.length === 0 || this.getMatchingSelectors(rule).length > 0) && queryMatches(rule.style);
  }
  getParentLayoutNodeId() {
    return this.#parentLayoutNodeId;
  }
  getMatchingSelectors(rule) {
    const node = this.nodeForStyle(rule.style);
    if (!node || typeof node.id !== "number") {
      return [];
    }
    const map = this.#matchingSelectors.get(node.id);
    if (!map) {
      return [];
    }
    const result = [];
    for (let i = 0; i < rule.selectors.length; ++i) {
      if (map.get(rule.selectors[i].text)) {
        result.push(i);
      }
    }
    return result;
  }
  async recomputeMatchingSelectors(rule) {
    const node = this.nodeForStyle(rule.style);
    if (!node) {
      return;
    }
    const promises = [];
    for (const selector of rule.selectors) {
      promises.push(querySelector.call(this, node, selector.text));
    }
    await Promise.all(promises);
    async function querySelector(node2, selectorText) {
      const ownerDocument = node2.ownerDocument;
      if (!ownerDocument) {
        return;
      }
      if (typeof node2.id === "number") {
        const map = this.#matchingSelectors.get(node2.id);
        if (map && map.has(selectorText)) {
          return;
        }
      }
      if (typeof ownerDocument.id !== "number") {
        return;
      }
      const matchingNodeIds = await this.#nodeInternal.domModel().querySelectorAll(ownerDocument.id, selectorText);
      if (matchingNodeIds) {
        if (typeof node2.id === "number") {
          this.setSelectorMatches(node2, selectorText, matchingNodeIds.indexOf(node2.id) !== -1);
        } else {
          this.setSelectorMatches(node2, selectorText, false);
        }
      }
    }
  }
  addNewRule(rule, node) {
    this.#addedStyles.set(rule.style, node);
    return this.recomputeMatchingSelectors(rule);
  }
  setSelectorMatches(node, selectorText, value) {
    if (typeof node.id !== "number") {
      return;
    }
    let map = this.#matchingSelectors.get(node.id);
    if (!map) {
      map = /* @__PURE__ */ new Map();
      this.#matchingSelectors.set(node.id, map);
    }
    map.set(selectorText, value);
  }
  nodeStyles() {
    Platform6.assertNotNullOrUndefined(this.#mainDOMCascade);
    return this.#mainDOMCascade.styles();
  }
  registeredProperties() {
    return this.#registeredProperties;
  }
  getRegisteredProperty(name) {
    return this.#registeredPropertyMap.get(name);
  }
  fontPaletteValuesRule() {
    return this.#fontPaletteValuesRule;
  }
  keyframes() {
    return this.#keyframesInternal;
  }
  positionTryRules() {
    return this.#positionTryRules;
  }
  activePositionFallbackIndex() {
    return this.#activePositionFallbackIndex;
  }
  pseudoStyles(pseudoType) {
    Platform6.assertNotNullOrUndefined(this.#pseudoDOMCascades);
    const domCascade = this.#pseudoDOMCascades.get(pseudoType);
    return domCascade ? domCascade.styles() : [];
  }
  pseudoTypes() {
    Platform6.assertNotNullOrUndefined(this.#pseudoDOMCascades);
    return new Set(this.#pseudoDOMCascades.keys());
  }
  customHighlightPseudoStyles(highlightName) {
    Platform6.assertNotNullOrUndefined(this.#customHighlightPseudoDOMCascades);
    const domCascade = this.#customHighlightPseudoDOMCascades.get(highlightName);
    return domCascade ? domCascade.styles() : [];
  }
  customHighlightPseudoNames() {
    Platform6.assertNotNullOrUndefined(this.#customHighlightPseudoDOMCascades);
    return new Set(this.#customHighlightPseudoDOMCascades.keys());
  }
  nodeForStyle(style) {
    return this.#addedStyles.get(style) || this.#nodeForStyleInternal.get(style) || null;
  }
  availableCSSVariables(style) {
    const domCascade = this.#styleToDOMCascade.get(style);
    return domCascade ? domCascade.findAvailableCSSVariables(style) : [];
  }
  computeCSSVariable(style, variableName) {
    const domCascade = this.#styleToDOMCascade.get(style);
    return domCascade ? domCascade.computeCSSVariable(style, variableName) : null;
  }
  resolveGlobalKeyword(property, keyword) {
    const resolved = this.#styleToDOMCascade.get(property.ownerStyle)?.resolveGlobalKeyword(property, keyword);
    return resolved ? new CSSValueSource(resolved) : null;
  }
  isInherited(style) {
    return this.#inheritedStyles.has(style);
  }
  propertyState(property) {
    const domCascade = this.#styleToDOMCascade.get(property.ownerStyle);
    return domCascade ? domCascade.propertyState(property) : null;
  }
  resetActiveProperties() {
    Platform6.assertNotNullOrUndefined(this.#mainDOMCascade);
    Platform6.assertNotNullOrUndefined(this.#pseudoDOMCascades);
    Platform6.assertNotNullOrUndefined(this.#customHighlightPseudoDOMCascades);
    this.#mainDOMCascade.reset();
    for (const domCascade of this.#pseudoDOMCascades.values()) {
      domCascade.reset();
    }
    for (const domCascade of this.#customHighlightPseudoDOMCascades.values()) {
      domCascade.reset();
    }
  }
};
var NodeCascade = class {
  #matchedStyles;
  styles;
  #isInherited;
  #isHighlightPseudoCascade;
  propertiesState;
  activeProperties;
  constructor(matchedStyles, styles, isInherited, isHighlightPseudoCascade = false) {
    this.#matchedStyles = matchedStyles;
    this.styles = styles;
    this.#isInherited = isInherited;
    this.#isHighlightPseudoCascade = isHighlightPseudoCascade;
    this.propertiesState = /* @__PURE__ */ new Map();
    this.activeProperties = /* @__PURE__ */ new Map();
  }
  computeActiveProperties() {
    this.propertiesState.clear();
    this.activeProperties.clear();
    for (let i = this.styles.length - 1; i >= 0; i--) {
      const style = this.styles[i];
      const rule = style.parentRule;
      if (rule && !(rule instanceof CSSStyleRule)) {
        continue;
      }
      if (rule && !this.#matchedStyles.hasMatchingSelectors(rule)) {
        continue;
      }
      for (const property of style.allProperties()) {
        const metadata = cssMetadata();
        if (this.#isInherited && !this.#isHighlightPseudoCascade && !metadata.isPropertyInherited(property.name)) {
          continue;
        }
        if (style.range && !property.range) {
          continue;
        }
        if (!property.activeInStyle()) {
          this.propertiesState.set(
            property,
            "Overloaded"
            /* OVERLOADED */
          );
          continue;
        }
        if (this.#isInherited) {
          const registration = this.#matchedStyles.getRegisteredProperty(property.name);
          if (registration && !registration.inherits()) {
            this.propertiesState.set(
              property,
              "Overloaded"
              /* OVERLOADED */
            );
            continue;
          }
        }
        const canonicalName = metadata.canonicalPropertyName(property.name);
        this.updatePropertyState(property, canonicalName);
        for (const longhand of property.getLonghandProperties()) {
          if (metadata.isCSSPropertyName(longhand.name)) {
            this.updatePropertyState(longhand, longhand.name);
          }
        }
      }
    }
  }
  updatePropertyState(propertyWithHigherSpecificity, canonicalName) {
    const activeProperty = this.activeProperties.get(canonicalName);
    if (activeProperty?.important && !propertyWithHigherSpecificity.important) {
      this.propertiesState.set(
        propertyWithHigherSpecificity,
        "Overloaded"
        /* OVERLOADED */
      );
      return;
    }
    if (activeProperty) {
      this.propertiesState.set(
        activeProperty,
        "Overloaded"
        /* OVERLOADED */
      );
    }
    this.propertiesState.set(
      propertyWithHigherSpecificity,
      "Active"
      /* ACTIVE */
    );
    this.activeProperties.set(canonicalName, propertyWithHigherSpecificity);
  }
};
function isRegular(declaration2) {
  return "ownerStyle" in declaration2;
}
var CSSValueSource = class {
  declaration;
  constructor(declaration2) {
    this.declaration = declaration2;
  }
  get value() {
    return isRegular(this.declaration) ? this.declaration.value : this.declaration.initialValue();
  }
  get style() {
    return isRegular(this.declaration) ? this.declaration.ownerStyle : this.declaration.style();
  }
  get name() {
    return isRegular(this.declaration) ? this.declaration.name : this.declaration.propertyName();
  }
};
var SCCRecordEntry = class {
  constructor(nodeCascade, name, discoveryTime) {
    this.nodeCascade = nodeCascade;
    this.name = name;
    this.discoveryTime = discoveryTime;
    this.rootDiscoveryTime = discoveryTime;
  }
  rootDiscoveryTime;
  get isRootEntry() {
    return this.rootDiscoveryTime === this.discoveryTime;
  }
  updateRoot(neighbor) {
    this.rootDiscoveryTime = Math.min(this.rootDiscoveryTime, neighbor.rootDiscoveryTime);
  }
};
var SCCRecord = class {
  #time = 0;
  #stack = [];
  #entries = /* @__PURE__ */ new Map();
  get(nodeCascade, variable) {
    return this.#entries.get(nodeCascade)?.get(variable);
  }
  add(nodeCascade, variable) {
    const existing = this.get(nodeCascade, variable);
    if (existing) {
      return existing;
    }
    const entry = new SCCRecordEntry(nodeCascade, variable, this.#time++);
    this.#stack.push(entry);
    let map = this.#entries.get(nodeCascade);
    if (!map) {
      map = /* @__PURE__ */ new Map();
      this.#entries.set(nodeCascade, map);
    }
    map.set(variable, entry);
    return entry;
  }
  isInInProgressSCC(childRecord) {
    return this.#stack.includes(childRecord);
  }
  finishSCC(root) {
    const startIndex = this.#stack.lastIndexOf(root);
    console.assert(startIndex >= 0, "Root is not an in-progress scc");
    return this.#stack.splice(startIndex);
  }
};
function* forEach(array, startAfter) {
  const startIdx = startAfter !== void 0 ? array.indexOf(startAfter) + 1 : 0;
  for (let i = startIdx; i < array.length; ++i) {
    yield array[i];
  }
}
var DOMInheritanceCascade = class {
  #nodeCascades;
  #propertiesState;
  #availableCSSVariables;
  #computedCSSVariables;
  #initialized;
  #styleToNodeCascade;
  #registeredProperties;
  constructor(nodeCascades, registeredProperties) {
    this.#nodeCascades = nodeCascades;
    this.#propertiesState = /* @__PURE__ */ new Map();
    this.#availableCSSVariables = /* @__PURE__ */ new Map();
    this.#computedCSSVariables = /* @__PURE__ */ new Map();
    this.#initialized = false;
    this.#registeredProperties = registeredProperties;
    this.#styleToNodeCascade = /* @__PURE__ */ new Map();
    for (const nodeCascade of nodeCascades) {
      for (const style of nodeCascade.styles) {
        this.#styleToNodeCascade.set(style, nodeCascade);
      }
    }
  }
  findAvailableCSSVariables(style) {
    const nodeCascade = this.#styleToNodeCascade.get(style);
    if (!nodeCascade) {
      return [];
    }
    this.ensureInitialized();
    const availableCSSVariables = this.#availableCSSVariables.get(nodeCascade);
    if (!availableCSSVariables) {
      return [];
    }
    return Array.from(availableCSSVariables.keys());
  }
  #findPropertyInPreviousStyle(property, filter) {
    const cascade = this.#styleToNodeCascade.get(property.ownerStyle);
    if (!cascade) {
      return null;
    }
    for (const style of forEach(cascade.styles, property.ownerStyle)) {
      const candidate = style.allProperties().findLast((candidate2) => candidate2.name === property.name && filter(candidate2));
      if (candidate) {
        return candidate;
      }
    }
    return null;
  }
  #findPropertyInParentCascade(property) {
    const nodeCascade = this.#styleToNodeCascade.get(property.ownerStyle);
    if (!nodeCascade) {
      return null;
    }
    for (const cascade of forEach(this.#nodeCascades, nodeCascade)) {
      for (const style of cascade.styles) {
        const inheritedProperty = style.allProperties().findLast((inheritedProperty2) => inheritedProperty2.name === property.name);
        if (inheritedProperty) {
          return inheritedProperty;
        }
      }
    }
    return null;
  }
  #findPropertyInParentCascadeIfInherited(property) {
    if (!cssMetadata().isPropertyInherited(property.name) || !(this.#findCustomPropertyRegistration(property)?.inherits() ?? true)) {
      return null;
    }
    return this.#findPropertyInParentCascade(property);
  }
  #findCustomPropertyRegistration(property) {
    const registration = this.#registeredProperties.find((registration2) => registration2.propertyName() === property.name);
    return registration ? registration : null;
  }
  resolveGlobalKeyword(property, keyword) {
    const isPreviousLayer = (other) => {
      if (!(other.ownerStyle.parentRule instanceof CSSStyleRule)) {
        return false;
      }
      if (property.ownerStyle.type === Type3.Inline) {
        return true;
      }
      if (property.ownerStyle.parentRule instanceof CSSStyleRule && other.ownerStyle.parentRule?.origin === CSS2.StyleSheetOrigin.Regular) {
        return JSON.stringify(other.ownerStyle.parentRule.layers) !== JSON.stringify(property.ownerStyle.parentRule.layers);
      }
      return false;
    };
    switch (keyword) {
      case CSSWideKeyword.INITIAL:
        return this.#findCustomPropertyRegistration(property);
      case CSSWideKeyword.INHERIT:
        return this.#findPropertyInParentCascade(property) ?? this.#findCustomPropertyRegistration(property);
      case CSSWideKeyword.REVERT:
        return this.#findPropertyInPreviousStyle(
          property,
          (other) => other.ownerStyle.parentRule !== null && other.ownerStyle.parentRule.origin !== (property.ownerStyle.parentRule?.origin ?? CSS2.StyleSheetOrigin.Regular)
        ) ?? this.resolveGlobalKeyword(property, CSSWideKeyword.UNSET);
      case CSSWideKeyword.REVERT_LAYER:
        return this.#findPropertyInPreviousStyle(property, isPreviousLayer) ?? this.resolveGlobalKeyword(property, CSSWideKeyword.REVERT);
      case CSSWideKeyword.UNSET:
        return this.#findPropertyInParentCascadeIfInherited(property) ?? this.#findCustomPropertyRegistration(property);
    }
  }
  computeCSSVariable(style, variableName) {
    const nodeCascade = this.#styleToNodeCascade.get(style);
    if (!nodeCascade) {
      return null;
    }
    this.ensureInitialized();
    return this.innerComputeCSSVariable(nodeCascade, variableName);
  }
  innerComputeCSSVariable(nodeCascade, variableName, sccRecord = new SCCRecord()) {
    const availableCSSVariables = this.#availableCSSVariables.get(nodeCascade);
    const computedCSSVariables = this.#computedCSSVariables.get(nodeCascade);
    if (!computedCSSVariables || !availableCSSVariables?.has(variableName)) {
      return null;
    }
    if (computedCSSVariables?.has(variableName)) {
      return computedCSSVariables.get(variableName) || null;
    }
    let definedValue = availableCSSVariables.get(variableName);
    if (definedValue === void 0 || definedValue === null) {
      return null;
    }
    if (definedValue.declaration.declaration instanceof CSSProperty && definedValue.declaration.value && CSSMetadata.isCSSWideKeyword(definedValue.declaration.value)) {
      const resolvedProperty = this.resolveGlobalKeyword(definedValue.declaration.declaration, definedValue.declaration.value);
      if (!resolvedProperty) {
        return definedValue;
      }
      const declaration2 = new CSSValueSource(resolvedProperty);
      const { value } = declaration2;
      if (!value) {
        return definedValue;
      }
      definedValue = { declaration: declaration2, value };
    }
    const ast = tokenizeDeclaration(`--${variableName}`, definedValue.value);
    if (!ast) {
      return null;
    }
    const record = sccRecord.add(nodeCascade, variableName);
    const matching = BottomUpTreeMatching.walk(
      ast,
      [new VariableMatcher((match) => {
        const parentStyle = definedValue.declaration.style;
        const nodeCascade2 = this.#styleToNodeCascade.get(parentStyle);
        if (!nodeCascade2) {
          return null;
        }
        const childRecord = sccRecord.get(nodeCascade2, match.name);
        if (childRecord) {
          if (sccRecord.isInInProgressSCC(childRecord)) {
            record.updateRoot(childRecord);
            return null;
          }
          return this.#computedCSSVariables.get(nodeCascade2)?.get(match.name)?.value ?? null;
        }
        const cssVariableValue2 = this.innerComputeCSSVariable(nodeCascade2, match.name, sccRecord);
        const newChildRecord = sccRecord.get(nodeCascade2, match.name);
        newChildRecord && record.updateRoot(newChildRecord);
        if (cssVariableValue2?.value !== void 0) {
          return cssVariableValue2.value;
        }
        if (match.fallback.length === 0 || match.matching.hasUnresolvedVarsRange(match.fallback[0], match.fallback[match.fallback.length - 1])) {
          return null;
        }
        return match.matching.getComputedTextRange(match.fallback[0], match.fallback[match.fallback.length - 1]);
      })]
    );
    const decl = ASTUtils.siblings(ASTUtils.declValue(matching.ast.tree));
    const computedText = decl.length > 0 ? matching.getComputedTextRange(decl[0], decl[decl.length - 1]) : "";
    if (record.isRootEntry) {
      const scc = sccRecord.finishSCC(record);
      if (scc.length > 1) {
        for (const entry of scc) {
          console.assert(entry.nodeCascade === nodeCascade, "Circles should be within the cascade");
          computedCSSVariables.set(entry.name, null);
        }
        return null;
      }
    }
    if (decl.length > 0 && matching.hasUnresolvedVarsRange(decl[0], decl[decl.length - 1])) {
      computedCSSVariables.set(variableName, null);
      return null;
    }
    const cssVariableValue = { value: computedText, declaration: definedValue.declaration };
    computedCSSVariables.set(variableName, cssVariableValue);
    return cssVariableValue;
  }
  styles() {
    return Array.from(this.#styleToNodeCascade.keys());
  }
  propertyState(property) {
    this.ensureInitialized();
    return this.#propertiesState.get(property) || null;
  }
  reset() {
    this.#initialized = false;
    this.#propertiesState.clear();
    this.#availableCSSVariables.clear();
    this.#computedCSSVariables.clear();
  }
  ensureInitialized() {
    if (this.#initialized) {
      return;
    }
    this.#initialized = true;
    const activeProperties = /* @__PURE__ */ new Map();
    for (const nodeCascade of this.#nodeCascades) {
      nodeCascade.computeActiveProperties();
      for (const [property, state] of nodeCascade.propertiesState) {
        if (state === "Overloaded") {
          this.#propertiesState.set(
            property,
            "Overloaded"
            /* OVERLOADED */
          );
          continue;
        }
        const canonicalName = cssMetadata().canonicalPropertyName(property.name);
        if (activeProperties.has(canonicalName)) {
          this.#propertiesState.set(
            property,
            "Overloaded"
            /* OVERLOADED */
          );
          continue;
        }
        activeProperties.set(canonicalName, property);
        this.#propertiesState.set(
          property,
          "Active"
          /* ACTIVE */
        );
      }
    }
    for (const [canonicalName, shorthandProperty] of activeProperties) {
      const shorthandStyle = shorthandProperty.ownerStyle;
      const longhands = shorthandProperty.getLonghandProperties();
      if (!longhands.length) {
        continue;
      }
      let hasActiveLonghands = false;
      for (const longhand of longhands) {
        const longhandCanonicalName = cssMetadata().canonicalPropertyName(longhand.name);
        const longhandActiveProperty = activeProperties.get(longhandCanonicalName);
        if (!longhandActiveProperty) {
          continue;
        }
        if (longhandActiveProperty.ownerStyle === shorthandStyle) {
          hasActiveLonghands = true;
          break;
        }
      }
      if (hasActiveLonghands) {
        continue;
      }
      activeProperties.delete(canonicalName);
      this.#propertiesState.set(
        shorthandProperty,
        "Overloaded"
        /* OVERLOADED */
      );
    }
    const accumulatedCSSVariables = /* @__PURE__ */ new Map();
    for (const rule of this.#registeredProperties) {
      const initialValue = rule.initialValue();
      accumulatedCSSVariables.set(
        rule.propertyName(),
        initialValue !== null ? { value: initialValue, declaration: new CSSValueSource(rule) } : null
      );
    }
    for (let i = this.#nodeCascades.length - 1; i >= 0; --i) {
      const nodeCascade = this.#nodeCascades[i];
      const variableNames = [];
      for (const entry of nodeCascade.activeProperties.entries()) {
        const propertyName = entry[0];
        const property = entry[1];
        if (propertyName.startsWith("--")) {
          accumulatedCSSVariables.set(propertyName, { value: property.value, declaration: new CSSValueSource(property) });
          variableNames.push(propertyName);
        }
      }
      const availableCSSVariablesMap = new Map(accumulatedCSSVariables);
      const computedVariablesMap = /* @__PURE__ */ new Map();
      this.#availableCSSVariables.set(nodeCascade, availableCSSVariablesMap);
      this.#computedCSSVariables.set(nodeCascade, computedVariablesMap);
      for (const variableName of variableNames) {
        const prevValue = accumulatedCSSVariables.get(variableName);
        accumulatedCSSVariables.delete(variableName);
        const computedValue = this.innerComputeCSSVariable(nodeCascade, variableName);
        if (prevValue && computedValue?.value === prevValue.value) {
          computedValue.declaration = prevValue.declaration;
        }
        accumulatedCSSVariables.set(variableName, computedValue);
      }
    }
  }
};
var PropertyState = /* @__PURE__ */ ((PropertyState2) => {
  PropertyState2["ACTIVE"] = "Active";
  PropertyState2["OVERLOADED"] = "Overloaded";
  return PropertyState2;
})(PropertyState || {});

// gen/front_end/core/sdk/CSSStyleSheetHeader.js
var CSSStyleSheetHeader_exports = {};
__export(CSSStyleSheetHeader_exports, {
  CSSStyleSheetHeader: () => CSSStyleSheetHeader
});
import * as TextUtils12 from "./../../models/text_utils/text_utils.js";
import * as Common7 from "./../common/common.js";
import * as i18n3 from "./../i18n/i18n.js";
import * as Platform7 from "./../platform/platform.js";
import * as Root2 from "./../root/root.js";
var UIStrings2 = {
  /**
   *@description Error message for when a CSS file can't be loaded
   */
  couldNotFindTheOriginalStyle: "Could not find the original style sheet.",
  /**
   *@description Error message to display when a source CSS file could not be retrieved.
   */
  thereWasAnErrorRetrievingThe: "There was an error retrieving the source styles."
};
var str_2 = i18n3.i18n.registerUIStrings("core/sdk/CSSStyleSheetHeader.ts", UIStrings2);
var i18nString2 = i18n3.i18n.getLocalizedString.bind(void 0, str_2);
var CSSStyleSheetHeader = class {
  #cssModelInternal;
  id;
  frameId;
  sourceURL;
  hasSourceURL;
  origin;
  title;
  disabled;
  isInline;
  isMutable;
  isConstructed;
  startLine;
  startColumn;
  endLine;
  endColumn;
  contentLength;
  ownerNode;
  sourceMapURL;
  loadingFailed;
  #originalContentProviderInternal;
  constructor(cssModel, payload) {
    this.#cssModelInternal = cssModel;
    this.id = payload.styleSheetId;
    this.frameId = payload.frameId;
    this.sourceURL = payload.sourceURL;
    this.hasSourceURL = Boolean(payload.hasSourceURL);
    this.origin = payload.origin;
    this.title = payload.title;
    this.disabled = payload.disabled;
    this.isInline = payload.isInline;
    this.isMutable = payload.isMutable;
    this.isConstructed = payload.isConstructed;
    this.startLine = payload.startLine;
    this.startColumn = payload.startColumn;
    this.endLine = payload.endLine;
    this.endColumn = payload.endColumn;
    this.contentLength = payload.length;
    if (payload.ownerNode) {
      this.ownerNode = new DeferredDOMNode(cssModel.target(), payload.ownerNode);
    }
    this.sourceMapURL = payload.sourceMapURL;
    this.loadingFailed = payload.loadingFailed ?? false;
    this.#originalContentProviderInternal = null;
  }
  originalContentProvider() {
    if (!this.#originalContentProviderInternal) {
      const lazyContent = async () => {
        const originalText = await this.#cssModelInternal.originalStyleSheetText(this);
        if (originalText === null) {
          return { error: i18nString2(UIStrings2.couldNotFindTheOriginalStyle) };
        }
        return new TextUtils12.ContentData.ContentData(
          originalText,
          /* isBase64=*/
          false,
          "text/css"
        );
      };
      this.#originalContentProviderInternal = new TextUtils12.StaticContentProvider.StaticContentProvider(this.contentURL(), this.contentType(), lazyContent);
    }
    return this.#originalContentProviderInternal;
  }
  setSourceMapURL(sourceMapURL) {
    this.sourceMapURL = sourceMapURL;
  }
  cssModel() {
    return this.#cssModelInternal;
  }
  isAnonymousInlineStyleSheet() {
    return !this.resourceURL() && !this.#cssModelInternal.sourceMapManager().sourceMapForClient(this);
  }
  isConstructedByNew() {
    return this.isConstructed && this.sourceURL.length === 0;
  }
  resourceURL() {
    const url = this.isViaInspector() ? this.viaInspectorResourceURL() : this.sourceURL;
    if (!url && Root2.Runtime.experiments.isEnabled(Root2.Runtime.ExperimentName.STYLES_PANE_CSS_CHANGES)) {
      return this.dynamicStyleURL();
    }
    return url;
  }
  getFrameURLPath() {
    const model = this.#cssModelInternal.target().model(ResourceTreeModel);
    console.assert(Boolean(model));
    if (!model) {
      return "";
    }
    const frame = model.frameForId(this.frameId);
    if (!frame) {
      return "";
    }
    console.assert(Boolean(frame));
    const parsedURL = new Common7.ParsedURL.ParsedURL(frame.url);
    let urlPath = parsedURL.host + parsedURL.folderPathComponents;
    if (!urlPath.endsWith("/")) {
      urlPath += "/";
    }
    return urlPath;
  }
  viaInspectorResourceURL() {
    return `inspector://${this.getFrameURLPath()}inspector-stylesheet`;
  }
  dynamicStyleURL() {
    return `stylesheet://${this.getFrameURLPath()}style#${this.id}`;
  }
  lineNumberInSource(lineNumberInStyleSheet) {
    return this.startLine + lineNumberInStyleSheet;
  }
  columnNumberInSource(lineNumberInStyleSheet, columnNumberInStyleSheet) {
    return (lineNumberInStyleSheet ? 0 : this.startColumn) + columnNumberInStyleSheet;
  }
  /**
   * Checks whether the position is in this style sheet. Assumes that the
   * position's columnNumber is consistent with line endings.
   */
  containsLocation(lineNumber, columnNumber) {
    const afterStart = lineNumber === this.startLine && columnNumber >= this.startColumn || lineNumber > this.startLine;
    const beforeEnd = lineNumber < this.endLine || lineNumber === this.endLine && columnNumber <= this.endColumn;
    return afterStart && beforeEnd;
  }
  contentURL() {
    return this.resourceURL();
  }
  contentType() {
    return Common7.ResourceType.resourceTypes.Stylesheet;
  }
  requestContent() {
    return this.requestContentData().then(TextUtils12.ContentData.ContentData.asDeferredContent.bind(void 0));
  }
  async requestContentData() {
    const cssText = await this.#cssModelInternal.getStyleSheetText(this.id);
    if (cssText === null) {
      return { error: i18nString2(UIStrings2.thereWasAnErrorRetrievingThe) };
    }
    return new TextUtils12.ContentData.ContentData(
      cssText,
      /* isBase64=*/
      false,
      "text/css"
    );
  }
  async searchInContent(query, caseSensitive, isRegex) {
    const contentData = await this.requestContentData();
    return TextUtils12.TextUtils.performSearchInContentData(contentData, query, caseSensitive, isRegex);
  }
  isViaInspector() {
    return this.origin === "inspector";
  }
  createPageResourceLoadInitiator() {
    return {
      target: this.#cssModelInternal.target(),
      frameId: this.frameId,
      initiatorUrl: this.hasSourceURL ? Platform7.DevToolsPath.EmptyUrlString : this.sourceURL
    };
  }
};

// gen/front_end/core/sdk/SourceMapManager.js
var SourceMapManager_exports = {};
__export(SourceMapManager_exports, {
  Events: () => Events7,
  SourceMapManager: () => SourceMapManager
});
import * as Common12 from "./../common/common.js";
import * as Platform9 from "./../platform/platform.js";

// gen/front_end/core/sdk/PageResourceLoader.js
var PageResourceLoader_exports = {};
__export(PageResourceLoader_exports, {
  Events: () => Events6,
  PageResourceLoader: () => PageResourceLoader,
  ResourceKey: () => ResourceKey,
  getLoadThroughTargetSetting: () => getLoadThroughTargetSetting
});
import * as Common10 from "./../common/common.js";
import * as Host3 from "./../host/host.js";
import * as i18n5 from "./../i18n/i18n.js";

// gen/front_end/core/sdk/FrameManager.js
var FrameManager_exports = {};
__export(FrameManager_exports, {
  Events: () => Events5,
  FrameManager: () => FrameManager
});
import * as Common8 from "./../common/common.js";
var frameManagerInstance = null;
var FrameManager = class _FrameManager extends Common8.ObjectWrapper.ObjectWrapper {
  #eventListeners = /* @__PURE__ */ new WeakMap();
  // Maps frameIds to #frames and a count of how many ResourceTreeModels contain this frame.
  // (OOPIFs are usually first attached to a new target and then detached from their old target,
  // therefore being contained in 2 models for a short period of time.)
  #frames = /* @__PURE__ */ new Map();
  #framesForTarget = /* @__PURE__ */ new Map();
  #outermostFrame = null;
  #transferringFramesDataCache = /* @__PURE__ */ new Map();
  #awaitedFrames = /* @__PURE__ */ new Map();
  constructor() {
    super();
    TargetManager.instance().observeModels(ResourceTreeModel, this);
  }
  static instance({ forceNew } = { forceNew: false }) {
    if (!frameManagerInstance || forceNew) {
      frameManagerInstance = new _FrameManager();
    }
    return frameManagerInstance;
  }
  static removeInstance() {
    frameManagerInstance = null;
  }
  modelAdded(resourceTreeModel) {
    const addListener = resourceTreeModel.addEventListener(Events4.FrameAdded, this.frameAdded, this);
    const detachListener = resourceTreeModel.addEventListener(Events4.FrameDetached, this.frameDetached, this);
    const navigatedListener = resourceTreeModel.addEventListener(Events4.FrameNavigated, this.frameNavigated, this);
    const resourceAddedListener = resourceTreeModel.addEventListener(Events4.ResourceAdded, this.resourceAdded, this);
    this.#eventListeners.set(
      resourceTreeModel,
      [addListener, detachListener, navigatedListener, resourceAddedListener]
    );
    this.#framesForTarget.set(resourceTreeModel.target().id(), /* @__PURE__ */ new Set());
  }
  modelRemoved(resourceTreeModel) {
    const listeners = this.#eventListeners.get(resourceTreeModel);
    if (listeners) {
      Common8.EventTarget.removeEventListeners(listeners);
    }
    const frameSet = this.#framesForTarget.get(resourceTreeModel.target().id());
    if (frameSet) {
      for (const frameId of frameSet) {
        this.decreaseOrRemoveFrame(frameId);
      }
    }
    this.#framesForTarget.delete(resourceTreeModel.target().id());
  }
  frameAdded(event) {
    const frame = event.data;
    const frameData = this.#frames.get(frame.id);
    if (frameData) {
      frame.setCreationStackTrace(frameData.frame.getCreationStackTraceData());
      this.#frames.set(frame.id, { frame, count: frameData.count + 1 });
    } else {
      const cachedFrameAttributes = this.#transferringFramesDataCache.get(frame.id);
      if (cachedFrameAttributes?.creationStackTrace && cachedFrameAttributes?.creationStackTraceTarget) {
        frame.setCreationStackTrace({
          creationStackTrace: cachedFrameAttributes.creationStackTrace,
          creationStackTraceTarget: cachedFrameAttributes.creationStackTraceTarget
        });
      }
      this.#frames.set(frame.id, { frame, count: 1 });
      this.#transferringFramesDataCache.delete(frame.id);
    }
    this.resetOutermostFrame();
    const frameSet = this.#framesForTarget.get(frame.resourceTreeModel().target().id());
    if (frameSet) {
      frameSet.add(frame.id);
    }
    this.dispatchEventToListeners("FrameAddedToTarget", { frame });
    this.resolveAwaitedFrame(frame);
  }
  frameDetached(event) {
    const { frame, isSwap } = event.data;
    this.decreaseOrRemoveFrame(frame.id);
    if (isSwap && !this.#frames.get(frame.id)) {
      const traceData = frame.getCreationStackTraceData();
      const cachedFrameAttributes = {
        ...traceData.creationStackTrace && { creationStackTrace: traceData.creationStackTrace },
        ...traceData.creationStackTrace && { creationStackTraceTarget: traceData.creationStackTraceTarget }
      };
      this.#transferringFramesDataCache.set(frame.id, cachedFrameAttributes);
    }
    const frameSet = this.#framesForTarget.get(frame.resourceTreeModel().target().id());
    if (frameSet) {
      frameSet.delete(frame.id);
    }
  }
  frameNavigated(event) {
    const frame = event.data;
    this.dispatchEventToListeners("FrameNavigated", { frame });
    if (frame.isOutermostFrame()) {
      this.dispatchEventToListeners("OutermostFrameNavigated", { frame });
    }
  }
  resourceAdded(event) {
    this.dispatchEventToListeners("ResourceAdded", { resource: event.data });
  }
  decreaseOrRemoveFrame(frameId) {
    const frameData = this.#frames.get(frameId);
    if (frameData) {
      if (frameData.count === 1) {
        this.#frames.delete(frameId);
        this.resetOutermostFrame();
        this.dispatchEventToListeners("FrameRemoved", { frameId });
      } else {
        frameData.count--;
      }
    }
  }
  /**
   * Looks for the outermost frame in `#frames` and sets `#outermostFrame` accordingly.
   *
   * Important: This method needs to be called everytime `#frames` is updated.
   */
  resetOutermostFrame() {
    const outermostFrames = this.getAllFrames().filter((frame) => frame.isOutermostFrame());
    this.#outermostFrame = outermostFrames.length > 0 ? outermostFrames[0] : null;
  }
  /**
   * Returns the ResourceTreeFrame with a given frameId.
   * When a frame is being detached a new ResourceTreeFrame but with the same
   * frameId is created. Consequently getFrame() will return a different
   * ResourceTreeFrame after detachment. Callers of getFrame() should therefore
   * immediately use the function return value and not store it for later use.
   */
  getFrame(frameId) {
    const frameData = this.#frames.get(frameId);
    if (frameData) {
      return frameData.frame;
    }
    return null;
  }
  getAllFrames() {
    return Array.from(this.#frames.values(), (frameData) => frameData.frame);
  }
  getOutermostFrame() {
    return this.#outermostFrame;
  }
  async getOrWaitForFrame(frameId, notInTarget) {
    const frame = this.getFrame(frameId);
    if (frame && (!notInTarget || notInTarget !== frame.resourceTreeModel().target())) {
      return frame;
    }
    return new Promise((resolve) => {
      const waiting = this.#awaitedFrames.get(frameId);
      if (waiting) {
        waiting.push({ notInTarget, resolve });
      } else {
        this.#awaitedFrames.set(frameId, [{ notInTarget, resolve }]);
      }
    });
  }
  resolveAwaitedFrame(frame) {
    const waiting = this.#awaitedFrames.get(frame.id);
    if (!waiting) {
      return;
    }
    const newWaiting = waiting.filter(({ notInTarget, resolve }) => {
      if (!notInTarget || notInTarget !== frame.resourceTreeModel().target()) {
        resolve(frame);
        return false;
      }
      return true;
    });
    if (newWaiting.length > 0) {
      this.#awaitedFrames.set(frame.id, newWaiting);
    } else {
      this.#awaitedFrames.delete(frame.id);
    }
  }
};
var Events5 = /* @__PURE__ */ ((Events210) => {
  Events210["FRAME_ADDED_TO_TARGET"] = "FrameAddedToTarget";
  Events210["FRAME_NAVIGATED"] = "FrameNavigated";
  Events210["FRAME_REMOVED"] = "FrameRemoved";
  Events210["RESOURCE_ADDED"] = "ResourceAdded";
  Events210["OUTERMOST_FRAME_NAVIGATED"] = "OutermostFrameNavigated";
  return Events210;
})(Events5 || {});

// gen/front_end/core/sdk/IOModel.js
var IOModel_exports = {};
__export(IOModel_exports, {
  IOModel: () => IOModel
});
import * as Common9 from "./../common/common.js";

// gen/front_end/core/sdk/RemoteObject.js
var RemoteObject_exports = {};
__export(RemoteObject_exports, {
  LinearMemoryInspectable: () => LinearMemoryInspectable,
  LocalJSONObject: () => LocalJSONObject,
  RemoteArray: () => RemoteArray,
  RemoteArrayBuffer: () => RemoteArrayBuffer,
  RemoteError: () => RemoteError,
  RemoteFunction: () => RemoteFunction,
  RemoteObject: () => RemoteObject,
  RemoteObjectImpl: () => RemoteObjectImpl,
  RemoteObjectProperty: () => RemoteObjectProperty,
  ScopeRef: () => ScopeRef,
  ScopeRemoteObject: () => ScopeRemoteObject
});
var RemoteObject = class _RemoteObject {
  static fromLocalObject(value) {
    return new LocalJSONObject(value);
  }
  static type(remoteObject) {
    if (remoteObject === null) {
      return "null";
    }
    const type = typeof remoteObject;
    if (type !== "object" && type !== "function") {
      return type;
    }
    return remoteObject.type;
  }
  static isNullOrUndefined(remoteObject) {
    if (remoteObject === void 0) {
      return true;
    }
    switch (remoteObject.type) {
      case Runtime.RemoteObjectType.Object:
        return remoteObject.subtype === Runtime.RemoteObjectSubtype.Null;
      case Runtime.RemoteObjectType.Undefined:
        return true;
      default:
        return false;
    }
  }
  static arrayNameFromDescription(description) {
    return description.replace(descriptionLengthParenRegex, "").replace(descriptionLengthSquareRegex, "");
  }
  static arrayLength(object) {
    if (object.subtype !== "array" && object.subtype !== "typedarray") {
      return 0;
    }
    const parenMatches = object.description && object.description.match(descriptionLengthParenRegex);
    const squareMatches = object.description && object.description.match(descriptionLengthSquareRegex);
    return parenMatches ? parseInt(parenMatches[1], 10) : squareMatches ? parseInt(squareMatches[1], 10) : 0;
  }
  static arrayBufferByteLength(object) {
    if (object.subtype !== "arraybuffer") {
      return 0;
    }
    const matches = object.description && object.description.match(descriptionLengthParenRegex);
    return matches ? parseInt(matches[1], 10) : 0;
  }
  static unserializableDescription(object) {
    if (typeof object === "number") {
      const description = String(object);
      if (object === 0 && 1 / object < 0) {
        return "-0";
      }
      if (description === "NaN" || description === "Infinity" || description === "-Infinity") {
        return description;
      }
    }
    if (typeof object === "bigint") {
      return object + "n";
    }
    return null;
  }
  static toCallArgument(object) {
    const type = typeof object;
    if (type === "undefined") {
      return {};
    }
    const unserializableDescription = _RemoteObject.unserializableDescription(object);
    if (type === "number") {
      if (unserializableDescription !== null) {
        return { unserializableValue: unserializableDescription };
      }
      return { value: object };
    }
    if (type === "bigint") {
      return { unserializableValue: unserializableDescription };
    }
    if (type === "string" || type === "boolean") {
      return { value: object };
    }
    if (!object) {
      return { value: null };
    }
    const objectAsProtocolRemoteObject = object;
    if (object instanceof _RemoteObject) {
      const unserializableValue = object.unserializableValue();
      if (unserializableValue !== void 0) {
        return { unserializableValue };
      }
    } else if (objectAsProtocolRemoteObject.unserializableValue !== void 0) {
      return { unserializableValue: objectAsProtocolRemoteObject.unserializableValue };
    }
    if (typeof objectAsProtocolRemoteObject.objectId !== "undefined") {
      return { objectId: objectAsProtocolRemoteObject.objectId };
    }
    return { value: objectAsProtocolRemoteObject.value };
  }
  static async loadFromObjectPerProto(object, generatePreview, nonIndexedPropertiesOnly = false) {
    const result = await Promise.all([
      object.getAllProperties(true, generatePreview, nonIndexedPropertiesOnly),
      object.getOwnProperties(generatePreview, nonIndexedPropertiesOnly)
    ]);
    const accessorProperties = result[0].properties;
    const ownProperties = result[1].properties;
    const internalProperties = result[1].internalProperties;
    if (!ownProperties || !accessorProperties) {
      return { properties: null, internalProperties: null };
    }
    const propertiesMap = /* @__PURE__ */ new Map();
    const propertySymbols = [];
    for (let i = 0; i < accessorProperties.length; i++) {
      const property = accessorProperties[i];
      if (property.symbol) {
        propertySymbols.push(property);
      } else if (property.isOwn || property.name !== "__proto__") {
        propertiesMap.set(property.name, property);
      }
    }
    for (let i = 0; i < ownProperties.length; i++) {
      const property = ownProperties[i];
      if (property.isAccessorProperty()) {
        continue;
      }
      if (property.private || property.symbol) {
        propertySymbols.push(property);
      } else {
        propertiesMap.set(property.name, property);
      }
    }
    return {
      properties: [...propertiesMap.values()].concat(propertySymbols),
      internalProperties: internalProperties ? internalProperties : null
    };
  }
  customPreview() {
    return null;
  }
  get objectId() {
    return "Not implemented";
  }
  get type() {
    throw "Not implemented";
  }
  get subtype() {
    throw "Not implemented";
  }
  // TODO(crbug.com/1172300) Ignored during the jsdoc to ts migration
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  get value() {
    throw "Not implemented";
  }
  unserializableValue() {
    throw "Not implemented";
  }
  get description() {
    throw "Not implemented";
  }
  set description(description) {
    throw "Not implemented";
  }
  get hasChildren() {
    throw "Not implemented";
  }
  get preview() {
    return void 0;
  }
  get className() {
    return null;
  }
  arrayLength() {
    throw "Not implemented";
  }
  arrayBufferByteLength() {
    throw "Not implemented";
  }
  getOwnProperties(_generatePreview, _nonIndexedPropertiesOnly) {
    throw "Not implemented";
  }
  getAllProperties(_accessorPropertiesOnly, _generatePreview, _nonIndexedPropertiesOnly) {
    throw "Not implemented";
  }
  async deleteProperty(_name) {
    throw "Not implemented";
  }
  async setPropertyValue(_name, _value) {
    throw "Not implemented";
  }
  callFunction(_functionDeclaration, _args) {
    throw "Not implemented";
  }
  callFunctionJSON(_functionDeclaration, _args) {
    throw "Not implemented";
  }
  release() {
  }
  debuggerModel() {
    throw new Error("DebuggerModel-less object");
  }
  runtimeModel() {
    throw new Error("RuntimeModel-less object");
  }
  isNode() {
    return false;
  }
  /**
   * Checks whether this object can be inspected with the Linear memory inspector.
   * @returns `true` if this object can be inspected with the Linear memory inspector.
   */
  isLinearMemoryInspectable() {
    return false;
  }
  webIdl;
};
var RemoteObjectImpl = class extends RemoteObject {
  runtimeModelInternal;
  #runtimeAgent;
  #typeInternal;
  #subtypeInternal;
  #objectIdInternal;
  #descriptionInternal;
  hasChildrenInternal;
  #previewInternal;
  #unserializableValueInternal;
  #valueInternal;
  #customPreviewInternal;
  #classNameInternal;
  constructor(runtimeModel, objectId, type, subtype, value, unserializableValue, description, preview, customPreview, className) {
    super();
    this.runtimeModelInternal = runtimeModel;
    this.#runtimeAgent = runtimeModel.target().runtimeAgent();
    this.#typeInternal = type;
    this.#subtypeInternal = subtype;
    if (objectId) {
      this.#objectIdInternal = objectId;
      this.#descriptionInternal = description;
      this.hasChildrenInternal = type !== "symbol";
      this.#previewInternal = preview;
    } else {
      this.#descriptionInternal = description;
      if (!this.description && unserializableValue) {
        this.#descriptionInternal = unserializableValue;
      }
      if (!this.#descriptionInternal && (typeof value !== "object" || value === null)) {
        this.#descriptionInternal = String(value);
      }
      this.hasChildrenInternal = false;
      if (typeof unserializableValue === "string") {
        this.#unserializableValueInternal = unserializableValue;
        if (unserializableValue === "Infinity" || unserializableValue === "-Infinity" || unserializableValue === "-0" || unserializableValue === "NaN") {
          this.#valueInternal = Number(unserializableValue);
        } else if (type === "bigint" && unserializableValue.endsWith("n")) {
          this.#valueInternal = BigInt(unserializableValue.substring(0, unserializableValue.length - 1));
        } else {
          this.#valueInternal = unserializableValue;
        }
      } else {
        this.#valueInternal = value;
      }
    }
    this.#customPreviewInternal = customPreview || null;
    this.#classNameInternal = typeof className === "string" ? className : null;
  }
  customPreview() {
    return this.#customPreviewInternal;
  }
  get objectId() {
    return this.#objectIdInternal;
  }
  get type() {
    return this.#typeInternal;
  }
  get subtype() {
    return this.#subtypeInternal;
  }
  get value() {
    return this.#valueInternal;
  }
  unserializableValue() {
    return this.#unserializableValueInternal;
  }
  get description() {
    return this.#descriptionInternal;
  }
  set description(description) {
    this.#descriptionInternal = description;
  }
  get hasChildren() {
    return this.hasChildrenInternal;
  }
  get preview() {
    return this.#previewInternal;
  }
  get className() {
    return this.#classNameInternal;
  }
  getOwnProperties(generatePreview, nonIndexedPropertiesOnly = false) {
    return this.doGetProperties(true, false, nonIndexedPropertiesOnly, generatePreview);
  }
  getAllProperties(accessorPropertiesOnly, generatePreview, nonIndexedPropertiesOnly = false) {
    return this.doGetProperties(false, accessorPropertiesOnly, nonIndexedPropertiesOnly, generatePreview);
  }
  async createRemoteObject(object) {
    return this.runtimeModelInternal.createRemoteObject(object);
  }
  async doGetProperties(ownProperties, accessorPropertiesOnly, nonIndexedPropertiesOnly, generatePreview) {
    if (!this.#objectIdInternal) {
      return { properties: null, internalProperties: null };
    }
    const response = await this.#runtimeAgent.invoke_getProperties({
      objectId: this.#objectIdInternal,
      ownProperties,
      accessorPropertiesOnly,
      nonIndexedPropertiesOnly,
      generatePreview
    });
    if (response.getError()) {
      return { properties: null, internalProperties: null };
    }
    if (response.exceptionDetails) {
      this.runtimeModelInternal.exceptionThrown(Date.now(), response.exceptionDetails);
      return { properties: null, internalProperties: null };
    }
    const { result: properties = [], internalProperties = [], privateProperties = [] } = response;
    const result = [];
    for (const property of properties) {
      const propertyValue = property.value ? await this.createRemoteObject(property.value) : null;
      const propertySymbol = property.symbol ? this.runtimeModelInternal.createRemoteObject(property.symbol) : null;
      const remoteProperty = new RemoteObjectProperty(
        property.name,
        propertyValue,
        Boolean(property.enumerable),
        Boolean(property.writable),
        Boolean(property.isOwn),
        Boolean(property.wasThrown),
        propertySymbol
      );
      if (typeof property.value === "undefined") {
        if (property.get && property.get.type !== "undefined") {
          remoteProperty.getter = this.runtimeModelInternal.createRemoteObject(property.get);
        }
        if (property.set && property.set.type !== "undefined") {
          remoteProperty.setter = this.runtimeModelInternal.createRemoteObject(property.set);
        }
      }
      result.push(remoteProperty);
    }
    for (const property of privateProperties) {
      const propertyValue = property.value ? this.runtimeModelInternal.createRemoteObject(property.value) : null;
      const remoteProperty = new RemoteObjectProperty(
        property.name,
        propertyValue,
        true,
        true,
        true,
        false,
        void 0,
        false,
        void 0,
        true
      );
      if (typeof property.value === "undefined") {
        if (property.get && property.get.type !== "undefined") {
          remoteProperty.getter = this.runtimeModelInternal.createRemoteObject(property.get);
        }
        if (property.set && property.set.type !== "undefined") {
          remoteProperty.setter = this.runtimeModelInternal.createRemoteObject(property.set);
        }
      }
      result.push(remoteProperty);
    }
    const internalPropertiesResult = [];
    for (const property of internalProperties) {
      if (!property.value) {
        continue;
      }
      const propertyValue = this.runtimeModelInternal.createRemoteObject(property.value);
      internalPropertiesResult.push(
        new RemoteObjectProperty(property.name, propertyValue, true, false, void 0, void 0, void 0, true)
      );
    }
    return { properties: result, internalProperties: internalPropertiesResult };
  }
  async setPropertyValue(name, value) {
    if (!this.#objectIdInternal) {
      return "Can\u2019t set a property of non-object.";
    }
    const response = await this.#runtimeAgent.invoke_evaluate({ expression: value, silent: true });
    if (response.getError() || response.exceptionDetails) {
      return response.getError() || (response.result.type !== "string" ? response.result.description : response.result.value);
    }
    if (typeof name === "string") {
      name = RemoteObject.toCallArgument(name);
    }
    const resultPromise = this.doSetObjectPropertyValue(response.result, name);
    if (response.result.objectId) {
      void this.#runtimeAgent.invoke_releaseObject({ objectId: response.result.objectId });
    }
    return resultPromise;
  }
  async doSetObjectPropertyValue(result, name) {
    const setPropertyValueFunction = "function(a, b) { this[a] = b; }";
    const argv = [name, RemoteObject.toCallArgument(result)];
    const response = await this.#runtimeAgent.invoke_callFunctionOn({
      objectId: this.#objectIdInternal,
      functionDeclaration: setPropertyValueFunction,
      arguments: argv,
      silent: true
    });
    const error = response.getError();
    return error || response.exceptionDetails ? error || response.result.description : void 0;
  }
  async deleteProperty(name) {
    if (!this.#objectIdInternal) {
      return "Can\u2019t delete a property of non-object.";
    }
    const deletePropertyFunction = "function(a) { delete this[a]; return !(a in this); }";
    const response = await this.#runtimeAgent.invoke_callFunctionOn({
      objectId: this.#objectIdInternal,
      functionDeclaration: deletePropertyFunction,
      arguments: [name],
      silent: true
    });
    if (response.getError() || response.exceptionDetails) {
      return response.getError() || response.result.description;
    }
    if (!response.result.value) {
      return "Failed to delete property.";
    }
    return void 0;
  }
  async callFunction(functionDeclaration, args) {
    const response = await this.#runtimeAgent.invoke_callFunctionOn({
      objectId: this.#objectIdInternal,
      functionDeclaration: functionDeclaration.toString(),
      arguments: args,
      silent: true
    });
    if (response.getError()) {
      return { object: null, wasThrown: false };
    }
    return {
      object: this.runtimeModelInternal.createRemoteObject(response.result),
      wasThrown: Boolean(response.exceptionDetails)
    };
  }
  async callFunctionJSON(functionDeclaration, args) {
    const response = await this.#runtimeAgent.invoke_callFunctionOn({
      objectId: this.#objectIdInternal,
      functionDeclaration: functionDeclaration.toString(),
      arguments: args,
      silent: true,
      returnByValue: true
    });
    return response.getError() || response.exceptionDetails ? null : response.result.value;
  }
  release() {
    if (!this.#objectIdInternal) {
      return;
    }
    void this.#runtimeAgent.invoke_releaseObject({ objectId: this.#objectIdInternal });
  }
  arrayLength() {
    return RemoteObject.arrayLength(this);
  }
  arrayBufferByteLength() {
    return RemoteObject.arrayBufferByteLength(this);
  }
  debuggerModel() {
    return this.runtimeModelInternal.debuggerModel();
  }
  runtimeModel() {
    return this.runtimeModelInternal;
  }
  isNode() {
    return Boolean(this.#objectIdInternal) && this.type === "object" && this.subtype === "node";
  }
  isLinearMemoryInspectable() {
    return this.type === "object" && this.subtype !== void 0 && ["webassemblymemory", "typedarray", "dataview", "arraybuffer"].includes(this.subtype);
  }
};
var ScopeRemoteObject = class extends RemoteObjectImpl {
  #scopeRef;
  #savedScopeProperties;
  constructor(runtimeModel, objectId, scopeRef, type, subtype, value, unserializableValue, description, preview) {
    super(runtimeModel, objectId, type, subtype, value, unserializableValue, description, preview);
    this.#scopeRef = scopeRef;
    this.#savedScopeProperties = void 0;
  }
  async doGetProperties(ownProperties, accessorPropertiesOnly, _generatePreview) {
    if (accessorPropertiesOnly) {
      return { properties: [], internalProperties: [] };
    }
    if (this.#savedScopeProperties) {
      return { properties: this.#savedScopeProperties.slice(), internalProperties: null };
    }
    const allProperties = await super.doGetProperties(
      ownProperties,
      accessorPropertiesOnly,
      false,
      true
      /* generatePreview */
    );
    if (Array.isArray(allProperties.properties)) {
      this.#savedScopeProperties = allProperties.properties.slice();
      for (const property of this.#savedScopeProperties) {
        property.writable = false;
      }
    }
    return allProperties;
  }
  async doSetObjectPropertyValue(result, argumentName) {
    const name = argumentName.value;
    const error = await this.debuggerModel().setVariableValue(
      this.#scopeRef.number,
      name,
      RemoteObject.toCallArgument(result),
      this.#scopeRef.callFrameId
    );
    if (error) {
      return error;
    }
    if (this.#savedScopeProperties) {
      for (const property of this.#savedScopeProperties) {
        if (property.name === name) {
          property.value = this.runtimeModel().createRemoteObject(result);
        }
      }
    }
    return;
  }
};
var ScopeRef = class {
  number;
  callFrameId;
  constructor(number, callFrameId) {
    this.number = number;
    this.callFrameId = callFrameId;
  }
};
var RemoteObjectProperty = class _RemoteObjectProperty {
  name;
  value;
  enumerable;
  writable;
  isOwn;
  wasThrown;
  symbol;
  synthetic;
  syntheticSetter;
  private;
  getter;
  setter;
  webIdl;
  constructor(name, value, enumerable, writable, isOwn, wasThrown, symbol, synthetic, syntheticSetter, isPrivate) {
    this.name = name;
    this.value = value !== null ? value : void 0;
    this.enumerable = typeof enumerable !== "undefined" ? enumerable : true;
    const isNonSyntheticOrSyntheticWritable = !synthetic || Boolean(syntheticSetter);
    this.writable = typeof writable !== "undefined" ? writable : isNonSyntheticOrSyntheticWritable;
    this.isOwn = Boolean(isOwn);
    this.wasThrown = Boolean(wasThrown);
    if (symbol) {
      this.symbol = symbol;
    }
    this.synthetic = Boolean(synthetic);
    if (syntheticSetter) {
      this.syntheticSetter = syntheticSetter;
    }
    this.private = Boolean(isPrivate);
  }
  async setSyntheticValue(expression) {
    if (!this.syntheticSetter) {
      return false;
    }
    const result = await this.syntheticSetter(expression);
    if (result) {
      this.value = result;
    }
    return Boolean(result);
  }
  isAccessorProperty() {
    return Boolean(this.getter || this.setter);
  }
  match({ includeNullOrUndefinedValues, regex }) {
    if (regex !== null) {
      if (!regex.test(this.name) && !regex.test(this.value?.description ?? "")) {
        return false;
      }
    }
    if (!includeNullOrUndefinedValues) {
      if (!this.isAccessorProperty() && RemoteObject.isNullOrUndefined(this.value)) {
        return false;
      }
    }
    return true;
  }
  cloneWithNewName(newName) {
    const property = new _RemoteObjectProperty(
      newName,
      this.value ?? null,
      this.enumerable,
      this.writable,
      this.isOwn,
      this.wasThrown,
      this.symbol,
      this.synthetic,
      this.syntheticSetter,
      this.private
    );
    property.getter = this.getter;
    property.setter = this.setter;
    return property;
  }
};
var LocalJSONObject = class extends RemoteObject {
  valueInternal;
  #cachedDescription;
  #cachedChildren;
  constructor(value) {
    super();
    this.valueInternal = value;
  }
  get objectId() {
    return void 0;
  }
  get value() {
    return this.valueInternal;
  }
  unserializableValue() {
    const unserializableDescription = RemoteObject.unserializableDescription(this.valueInternal);
    return unserializableDescription || void 0;
  }
  get description() {
    if (this.#cachedDescription) {
      return this.#cachedDescription;
    }
    function formatArrayItem(property) {
      return this.formatValue(property.value || null);
    }
    function formatObjectItem(property) {
      let name = property.name;
      if (/^\s|\s$|^$|\n/.test(name)) {
        name = '"' + name.replace(/\n/g, "\u21B5") + '"';
      }
      return name + ": " + this.formatValue(property.value || null);
    }
    if (this.type === "object") {
      switch (this.subtype) {
        case "array":
          this.#cachedDescription = this.concatenate("[", "]", formatArrayItem.bind(this));
          break;
        case "date":
          this.#cachedDescription = String(this.valueInternal);
          break;
        case "null":
          this.#cachedDescription = "null";
          break;
        default:
          this.#cachedDescription = this.concatenate("{", "}", formatObjectItem.bind(this));
      }
    } else {
      this.#cachedDescription = String(this.valueInternal);
    }
    return this.#cachedDescription;
  }
  formatValue(value) {
    if (!value) {
      return "undefined";
    }
    const description = value.description || "";
    if (value.type === "string") {
      return '"' + description.replace(/\n/g, "\u21B5") + '"';
    }
    return description;
  }
  concatenate(prefix, suffix, formatProperty) {
    const previewChars = 100;
    let buffer = prefix;
    const children = this.children();
    for (let i = 0; i < children.length; ++i) {
      const itemDescription = formatProperty(children[i]);
      if (buffer.length + itemDescription.length > previewChars) {
        buffer += ",\u2026";
        break;
      }
      if (i) {
        buffer += ", ";
      }
      buffer += itemDescription;
    }
    buffer += suffix;
    return buffer;
  }
  get type() {
    return typeof this.valueInternal;
  }
  get subtype() {
    if (this.valueInternal === null) {
      return "null";
    }
    if (Array.isArray(this.valueInternal)) {
      return "array";
    }
    if (this.valueInternal instanceof Date) {
      return "date";
    }
    return void 0;
  }
  get hasChildren() {
    if (typeof this.valueInternal !== "object" || this.valueInternal === null) {
      return false;
    }
    return Boolean(Object.keys(this.valueInternal).length);
  }
  async getOwnProperties(_generatePreview, nonIndexedPropertiesOnly = false) {
    function isArrayIndex(name) {
      const index = Number(name) >>> 0;
      return String(index) === name;
    }
    let properties = this.children();
    if (nonIndexedPropertiesOnly) {
      properties = properties.filter((property) => !isArrayIndex(property.name));
    }
    return { properties, internalProperties: null };
  }
  async getAllProperties(accessorPropertiesOnly, generatePreview, nonIndexedPropertiesOnly = false) {
    if (accessorPropertiesOnly) {
      return { properties: [], internalProperties: null };
    }
    return await this.getOwnProperties(generatePreview, nonIndexedPropertiesOnly);
  }
  children() {
    if (!this.hasChildren) {
      return [];
    }
    if (!this.#cachedChildren) {
      this.#cachedChildren = Object.entries(this.valueInternal).map(([name, value]) => {
        return new RemoteObjectProperty(
          name,
          value instanceof RemoteObject ? value : RemoteObject.fromLocalObject(value)
        );
      });
    }
    return this.#cachedChildren;
  }
  arrayLength() {
    return Array.isArray(this.valueInternal) ? this.valueInternal.length : 0;
  }
  async callFunction(functionDeclaration, args) {
    const target = this.valueInternal;
    const rawArgs = args ? args.map((arg) => arg.value) : [];
    let result;
    let wasThrown = false;
    try {
      result = functionDeclaration.apply(target, rawArgs);
    } catch (e) {
      wasThrown = true;
    }
    const object = RemoteObject.fromLocalObject(result);
    return { object, wasThrown };
  }
  async callFunctionJSON(functionDeclaration, args) {
    const target = this.valueInternal;
    const rawArgs = args ? args.map((arg) => arg.value) : [];
    let result;
    try {
      result = functionDeclaration.apply(target, rawArgs);
    } catch (e) {
      result = null;
    }
    return result;
  }
};
var RemoteArrayBuffer = class {
  #objectInternal;
  constructor(object) {
    if (object.type !== "object" || object.subtype !== "arraybuffer") {
      throw new Error("Object is not an arraybuffer");
    }
    this.#objectInternal = object;
  }
  byteLength() {
    return this.#objectInternal.arrayBufferByteLength();
  }
  async bytes(start = 0, end = this.byteLength()) {
    if (start < 0 || start >= this.byteLength()) {
      throw new RangeError("start is out of range");
    }
    if (end < start || end > this.byteLength()) {
      throw new RangeError("end is out of range");
    }
    return await this.#objectInternal.callFunctionJSON(bytes, [{ value: start }, { value: end - start }]);
    function bytes(offset, length) {
      return [...new Uint8Array(this, offset, length)];
    }
  }
  object() {
    return this.#objectInternal;
  }
};
var RemoteArray = class _RemoteArray {
  #objectInternal;
  constructor(object) {
    this.#objectInternal = object;
  }
  static objectAsArray(object) {
    if (!object || object.type !== "object" || object.subtype !== "array" && object.subtype !== "typedarray") {
      throw new Error("Object is empty or not an array");
    }
    return new _RemoteArray(object);
  }
  static async createFromRemoteObjects(objects) {
    if (!objects.length) {
      throw new Error("Input array is empty");
    }
    const result = await objects[0].callFunction(createArray, objects.map(RemoteObject.toCallArgument));
    if (result.wasThrown || !result.object) {
      throw new Error("Call function throws exceptions or returns empty value");
    }
    return _RemoteArray.objectAsArray(result.object);
    function createArray(...args) {
      return args;
    }
  }
  async at(index) {
    if (index < 0 || index > this.#objectInternal.arrayLength()) {
      throw new Error("Out of range");
    }
    const result = await this.#objectInternal.callFunction(at, [RemoteObject.toCallArgument(index)]);
    if (result.wasThrown || !result.object) {
      throw new Error("Exception in callFunction or result value is empty");
    }
    return result.object;
    function at(index2) {
      return this[index2];
    }
  }
  length() {
    return this.#objectInternal.arrayLength();
  }
  map(func) {
    const promises = [];
    for (let i = 0; i < this.length(); ++i) {
      promises.push(this.at(i).then(func));
    }
    return Promise.all(promises);
  }
  object() {
    return this.#objectInternal;
  }
};
var RemoteFunction = class _RemoteFunction {
  #object;
  constructor(object) {
    this.#object = object;
  }
  static objectAsFunction(object) {
    if (object.type !== "function") {
      throw new Error("Object is empty or not a function");
    }
    return new _RemoteFunction(object);
  }
  async targetFunction() {
    const ownProperties = await this.#object.getOwnProperties(
      false
      /* generatePreview */
    );
    const targetFunction = ownProperties.internalProperties?.find(({ name }) => name === "[[TargetFunction]]");
    return targetFunction?.value ?? this.#object;
  }
  async targetFunctionDetails() {
    const targetFunction = await this.targetFunction();
    const functionDetails = await targetFunction.debuggerModel().functionDetailsPromise(targetFunction);
    if (this.#object !== targetFunction) {
      targetFunction.release();
    }
    return functionDetails;
  }
};
var RemoteError = class _RemoteError {
  #object;
  #exceptionDetails;
  #cause;
  constructor(object) {
    this.#object = object;
  }
  static objectAsError(object) {
    if (object.subtype !== "error") {
      throw new Error(`Object of type ${object.subtype} is not an error`);
    }
    return new _RemoteError(object);
  }
  get errorStack() {
    return this.#object.description ?? "";
  }
  exceptionDetails() {
    if (!this.#exceptionDetails) {
      this.#exceptionDetails = this.#lookupExceptionDetails();
    }
    return this.#exceptionDetails;
  }
  #lookupExceptionDetails() {
    if (this.#object.objectId) {
      return this.#object.runtimeModel().getExceptionDetails(this.#object.objectId);
    }
    return Promise.resolve(void 0);
  }
  cause() {
    if (!this.#cause) {
      this.#cause = this.#lookupCause();
    }
    return this.#cause;
  }
  async #lookupCause() {
    const allProperties = await this.#object.getAllProperties(
      false,
      false
      /* generatePreview */
    );
    const cause = allProperties.properties?.find((prop) => prop.name === "cause");
    return cause?.value;
  }
};
var descriptionLengthParenRegex = /\(([0-9]+)\)/;
var descriptionLengthSquareRegex = /\[([0-9]+)\]/;
var LinearMemoryInspectable = class {
  /** The linear memory inspectable {@link RemoteObject}. */
  object;
  /** The name of the variable or the field holding the `object`. */
  expression;
  /**
   * Wrap `object` and `expression` into a reveable structure.
   *
   * @param object A linear memory inspectable {@link RemoteObject}.
   * @param expression An optional name of the field or variable holding the `object`.
   */
  constructor(object, expression) {
    if (!object.isLinearMemoryInspectable()) {
      throw new Error("object must be linear memory inspectable");
    }
    this.object = object;
    this.expression = expression;
  }
};

// gen/front_end/core/sdk/IOModel.js
var IOModel = class extends SDKModel {
  constructor(target) {
    super(target);
  }
  async read(handle, size, offset) {
    const result = await this.target().ioAgent().invoke_read({ handle, offset, size });
    if (result.getError()) {
      throw new Error(result.getError());
    }
    if (result.eof) {
      return null;
    }
    if (result.base64Encoded) {
      return Common9.Base64.decode(result.data);
    }
    return result.data;
  }
  async close(handle) {
    const result = await this.target().ioAgent().invoke_close({ handle });
    if (result.getError()) {
      console.error("Could not close stream.");
    }
  }
  async resolveBlob(objectOrObjectId) {
    const objectId = objectOrObjectId instanceof RemoteObject ? objectOrObjectId.objectId : objectOrObjectId;
    if (!objectId) {
      throw new Error("Remote object has undefined objectId");
    }
    const result = await this.target().ioAgent().invoke_resolveBlob({ objectId });
    if (result.getError()) {
      throw new Error(result.getError());
    }
    return `blob:${result.uuid}`;
  }
  async readToString(handle) {
    const strings = [];
    const decoder = new TextDecoder();
    for (; ; ) {
      const data = await this.read(handle, 1024 * 1024);
      if (data === null) {
        strings.push(decoder.decode());
        break;
      }
      if (data instanceof ArrayBuffer) {
        strings.push(decoder.decode(data, { stream: true }));
      } else {
        strings.push(data);
      }
    }
    return strings.join("");
  }
};
SDKModel.register(IOModel, { capabilities: Capability.IO, autostart: true });

// gen/front_end/core/sdk/PageResourceLoader.js
var UIStrings3 = {
  /**
   *@description Error message for canceled source map loads
   */
  loadCanceledDueToReloadOf: "Load canceled due to reload of inspected page"
};
var str_3 = i18n5.i18n.registerUIStrings("core/sdk/PageResourceLoader.ts", UIStrings3);
var i18nString3 = i18n5.i18n.getLocalizedString.bind(void 0, str_3);
function isExtensionInitiator(initiator) {
  return "extensionId" in initiator;
}
var ResourceKey = class {
  key;
  constructor(key) {
    this.key = key;
  }
};
var pageResourceLoader = null;
var PageResourceLoader = class _PageResourceLoader extends Common10.ObjectWrapper.ObjectWrapper {
  #currentlyLoading;
  #currentlyLoadingPerTarget;
  #maxConcurrentLoads;
  #pageResources;
  #queuedLoads;
  #loadOverride;
  constructor(loadOverride, maxConcurrentLoads) {
    super();
    this.#currentlyLoading = 0;
    this.#currentlyLoadingPerTarget = /* @__PURE__ */ new Map();
    this.#maxConcurrentLoads = maxConcurrentLoads;
    this.#pageResources = /* @__PURE__ */ new Map();
    this.#queuedLoads = [];
    TargetManager.instance().addModelListener(
      ResourceTreeModel,
      Events4.PrimaryPageChanged,
      this.onPrimaryPageChanged,
      this
    );
    this.#loadOverride = loadOverride;
  }
  static instance({ forceNew, loadOverride, maxConcurrentLoads } = {
    forceNew: false,
    loadOverride: null,
    maxConcurrentLoads: 500
  }) {
    if (!pageResourceLoader || forceNew) {
      pageResourceLoader = new _PageResourceLoader(loadOverride, maxConcurrentLoads);
    }
    return pageResourceLoader;
  }
  static removeInstance() {
    pageResourceLoader = null;
  }
  onPrimaryPageChanged(event) {
    const { frame: mainFrame, type } = event.data;
    if (!mainFrame.isOutermostFrame()) {
      return;
    }
    for (const { reject } of this.#queuedLoads) {
      reject(new Error(i18nString3(UIStrings3.loadCanceledDueToReloadOf)));
    }
    this.#queuedLoads = [];
    const mainFrameTarget = mainFrame.resourceTreeModel().target();
    const keptResources = /* @__PURE__ */ new Map();
    for (const [key, pageResource] of this.#pageResources.entries()) {
      if (type === PrimaryPageChangeType.ACTIVATION && mainFrameTarget === pageResource.initiator.target) {
        keptResources.set(key, pageResource);
      }
    }
    this.#pageResources = keptResources;
    this.dispatchEventToListeners(
      "Update"
      /* UPDATE */
    );
  }
  getResourcesLoaded() {
    return this.#pageResources;
  }
  getScopedResourcesLoaded() {
    return new Map([...this.#pageResources].filter(
      ([_, pageResource]) => TargetManager.instance().isInScope(pageResource.initiator.target) || isExtensionInitiator(pageResource.initiator)
    ));
  }
  /**
   * Loading is the number of currently loading and queued items. Resources is the total number of resources,
   * including loading and queued resources, but not including resources that are still loading but scheduled
   * for cancelation.;
   */
  getNumberOfResources() {
    return { loading: this.#currentlyLoading, queued: this.#queuedLoads.length, resources: this.#pageResources.size };
  }
  getScopedNumberOfResources() {
    const targetManager = TargetManager.instance();
    let loadingCount = 0;
    for (const [targetId, count] of this.#currentlyLoadingPerTarget) {
      const target = targetManager.targetById(targetId);
      if (targetManager.isInScope(target)) {
        loadingCount += count;
      }
    }
    return { loading: loadingCount, resources: this.getScopedResourcesLoaded().size };
  }
  async acquireLoadSlot(target) {
    this.#currentlyLoading++;
    if (target) {
      const currentCount = this.#currentlyLoadingPerTarget.get(target.id()) || 0;
      this.#currentlyLoadingPerTarget.set(target.id(), currentCount + 1);
    }
    if (this.#currentlyLoading > this.#maxConcurrentLoads) {
      const entry = { resolve: () => {
      }, reject: () => {
      } };
      const waitForCapacity = new Promise((resolve, reject) => {
        entry.resolve = resolve;
        entry.reject = reject;
      });
      this.#queuedLoads.push(entry);
      await waitForCapacity;
    }
  }
  releaseLoadSlot(target) {
    this.#currentlyLoading--;
    if (target) {
      const currentCount = this.#currentlyLoadingPerTarget.get(target.id());
      if (currentCount) {
        this.#currentlyLoadingPerTarget.set(target.id(), currentCount - 1);
      }
    }
    const entry = this.#queuedLoads.shift();
    if (entry) {
      entry.resolve();
    }
  }
  static makeExtensionKey(url, initiator) {
    if (isExtensionInitiator(initiator) && initiator.extensionId) {
      return `${url}-${initiator.extensionId}`;
    }
    throw new Error("Invalid initiator");
  }
  static makeKey(url, initiator) {
    if (initiator.frameId) {
      return `${url}-${initiator.frameId}`;
    }
    if (initiator.target) {
      return `${url}-${initiator.target.id()}`;
    }
    throw new Error("Invalid initiator");
  }
  resourceLoadedThroughExtension(pageResource) {
    const key = _PageResourceLoader.makeExtensionKey(pageResource.url, pageResource.initiator);
    this.#pageResources.set(key, pageResource);
    this.dispatchEventToListeners(
      "Update"
      /* UPDATE */
    );
  }
  async loadResource(url, initiator) {
    if (isExtensionInitiator(initiator)) {
      throw new Error("Invalid initiator");
    }
    const key = _PageResourceLoader.makeKey(url, initiator);
    const pageResource = { success: null, size: null, errorMessage: void 0, url, initiator };
    this.#pageResources.set(key, pageResource);
    this.dispatchEventToListeners(
      "Update"
      /* UPDATE */
    );
    try {
      await this.acquireLoadSlot(initiator.target);
      const resultPromise = this.dispatchLoad(url, initiator);
      const result = await resultPromise;
      pageResource.errorMessage = result.errorDescription.message;
      pageResource.success = result.success;
      if (result.success) {
        pageResource.size = result.content.length;
        return { content: result.content };
      }
      throw new Error(result.errorDescription.message);
    } catch (e) {
      if (pageResource.errorMessage === void 0) {
        pageResource.errorMessage = e.message;
      }
      if (pageResource.success === null) {
        pageResource.success = false;
      }
      throw e;
    } finally {
      this.releaseLoadSlot(initiator.target);
      this.dispatchEventToListeners(
        "Update"
        /* UPDATE */
      );
    }
  }
  async dispatchLoad(url, initiator) {
    if (isExtensionInitiator(initiator)) {
      throw new Error("Invalid initiator");
    }
    let failureReason = null;
    if (this.#loadOverride) {
      return this.#loadOverride(url);
    }
    const parsedURL = new Common10.ParsedURL.ParsedURL(url);
    const eligibleForLoadFromTarget = getLoadThroughTargetSetting().get() && parsedURL && parsedURL.scheme !== "file" && parsedURL.scheme !== "data" && parsedURL.scheme !== "devtools";
    Host3.userMetrics.developerResourceScheme(this.getDeveloperResourceScheme(parsedURL));
    if (eligibleForLoadFromTarget) {
      try {
        if (initiator.target) {
          Host3.userMetrics.developerResourceLoaded(
            Host3.UserMetrics.DeveloperResourceLoaded.LOAD_THROUGH_PAGE_VIA_TARGET
          );
          const result2 = await this.loadFromTarget(initiator.target, initiator.frameId, url);
          return result2;
        }
        const frame = FrameManager.instance().getFrame(initiator.frameId);
        if (frame) {
          Host3.userMetrics.developerResourceLoaded(
            Host3.UserMetrics.DeveloperResourceLoaded.LOAD_THROUGH_PAGE_VIA_FRAME
          );
          const result2 = await this.loadFromTarget(frame.resourceTreeModel().target(), initiator.frameId, url);
          return result2;
        }
      } catch (e) {
        if (e instanceof Error) {
          Host3.userMetrics.developerResourceLoaded(Host3.UserMetrics.DeveloperResourceLoaded.LOAD_THROUGH_PAGE_FAILURE);
          failureReason = e.message;
        }
      }
      Host3.userMetrics.developerResourceLoaded(Host3.UserMetrics.DeveloperResourceLoaded.LOAD_THROUGH_PAGE_FALLBACK);
    } else {
      const code = getLoadThroughTargetSetting().get() ? Host3.UserMetrics.DeveloperResourceLoaded.FALLBACK_PER_PROTOCOL : Host3.UserMetrics.DeveloperResourceLoaded.FALLBACK_PER_OVERRIDE;
      Host3.userMetrics.developerResourceLoaded(code);
    }
    const result = await MultitargetNetworkManager.instance().loadResource(url);
    if (eligibleForLoadFromTarget && !result.success) {
      Host3.userMetrics.developerResourceLoaded(Host3.UserMetrics.DeveloperResourceLoaded.FALLBACK_FAILURE);
    }
    if (failureReason) {
      result.errorDescription.message = `Fetch through target failed: ${failureReason}; Fallback: ${result.errorDescription.message}`;
    }
    return result;
  }
  getDeveloperResourceScheme(parsedURL) {
    if (!parsedURL || parsedURL.scheme === "") {
      return Host3.UserMetrics.DeveloperResourceScheme.UKNOWN;
    }
    const isLocalhost = parsedURL.host === "localhost" || parsedURL.host.endsWith(".localhost");
    switch (parsedURL.scheme) {
      case "file":
        return Host3.UserMetrics.DeveloperResourceScheme.FILE;
      case "data":
        return Host3.UserMetrics.DeveloperResourceScheme.DATA;
      case "blob":
        return Host3.UserMetrics.DeveloperResourceScheme.BLOB;
      case "http":
        return isLocalhost ? Host3.UserMetrics.DeveloperResourceScheme.HTTP_LOCALHOST : Host3.UserMetrics.DeveloperResourceScheme.HTTP;
      case "https":
        return isLocalhost ? Host3.UserMetrics.DeveloperResourceScheme.HTTPS_LOCALHOST : Host3.UserMetrics.DeveloperResourceScheme.HTTPS;
    }
    return Host3.UserMetrics.DeveloperResourceScheme.OTHER;
  }
  async loadFromTarget(target, frameId, url) {
    const networkManager = target.model(NetworkManager);
    const ioModel = target.model(IOModel);
    const disableCache = Common10.Settings.Settings.instance().moduleSetting("cache-disabled").get();
    const resource = await networkManager.loadNetworkResource(frameId, url, { disableCache, includeCredentials: true });
    try {
      const content = resource.stream ? await ioModel.readToString(resource.stream) : "";
      return {
        success: resource.success,
        content,
        errorDescription: {
          statusCode: resource.httpStatusCode || 0,
          netError: resource.netError,
          netErrorName: resource.netErrorName,
          message: Host3.ResourceLoader.netErrorToMessage(
            resource.netError,
            resource.httpStatusCode,
            resource.netErrorName
          ) || "",
          urlValid: void 0
        }
      };
    } finally {
      if (resource.stream) {
        void ioModel.close(resource.stream);
      }
    }
  }
};
function getLoadThroughTargetSetting() {
  return Common10.Settings.Settings.instance().createSetting("load-through-target", true);
}
var Events6 = /* @__PURE__ */ ((Events210) => {
  Events210["UPDATE"] = "Update";
  return Events210;
})(Events6 || {});

// gen/front_end/core/sdk/SourceMap.js
var SourceMap_exports = {};
__export(SourceMap_exports, {
  SourceMap: () => SourceMap,
  SourceMapEntry: () => SourceMapEntry,
  TokenIterator: () => TokenIterator,
  parseSourceMap: () => parseSourceMap
});
import * as TextUtils14 from "./../../models/text_utils/text_utils.js";
import * as Common11 from "./../common/common.js";
import * as Platform8 from "./../platform/platform.js";
import * as Root3 from "./../root/root.js";

// gen/front_end/core/sdk/SourceMapScopesInfo.js
var SourceMapScopesInfo_exports = {};
__export(SourceMapScopesInfo_exports, {
  SourceMapScopesInfo: () => SourceMapScopesInfo,
  contains: () => contains
});

// gen/front_end/core/sdk/SourceMapScopeChainEntry.js
var SourceMapScopeChainEntry_exports = {};
__export(SourceMapScopeChainEntry_exports, {
  SourceMapScopeChainEntry: () => SourceMapScopeChainEntry
});
import * as i18n7 from "./../i18n/i18n.js";
var UIStrings4 = {
  /**
   *@description Title of a section in the debugger showing local JavaScript variables.
   */
  local: "Local",
  /**
   *@description Text that refers to closure as a programming term
   */
  closure: "Closure",
  /**
   *@description Noun that represents a section or block of code in the Debugger Model. Shown in the Sources tab, while paused on a breakpoint.
   */
  block: "Block",
  /**
   *@description Title of a section in the debugger showing JavaScript variables from the global scope.
   */
  global: "Global",
  /**
   *@description Text in Scope Chain Sidebar Pane of the Sources panel
   */
  returnValue: "Return value"
};
var str_4 = i18n7.i18n.registerUIStrings("core/sdk/SourceMapScopeChainEntry.ts", UIStrings4);
var i18nString4 = i18n7.i18n.getLocalizedString.bind(void 0, str_4);
var SourceMapScopeChainEntry = class {
  #callFrame;
  #scope;
  #range;
  #isInnerMostFunction;
  #returnValue;
  /**
   * @param isInnerMostFunction If `scope` is the innermost 'function' scope. Only used for labeling as we name the
   * scope of the paused function 'Local', while other outer 'function' scopes are named 'Closure'.
   */
  constructor(callFrame, scope, range, isInnerMostFunction, returnValue) {
    this.#callFrame = callFrame;
    this.#scope = scope;
    this.#range = range;
    this.#isInnerMostFunction = isInnerMostFunction;
    this.#returnValue = returnValue;
  }
  extraProperties() {
    if (this.#returnValue) {
      return [new RemoteObjectProperty(
        i18nString4(UIStrings4.returnValue),
        this.#returnValue,
        void 0,
        void 0,
        void 0,
        void 0,
        void 0,
        /* synthetic */
        true
      )];
    }
    return [];
  }
  callFrame() {
    return this.#callFrame;
  }
  type() {
    switch (this.#scope.kind) {
      case "global":
        return Debugger.ScopeType.Global;
      case "function":
        return this.#isInnerMostFunction ? Debugger.ScopeType.Local : Debugger.ScopeType.Closure;
      case "block":
        return Debugger.ScopeType.Block;
    }
    return this.#scope.kind ?? "";
  }
  typeName() {
    switch (this.#scope.kind) {
      case "global":
        return i18nString4(UIStrings4.global);
      case "function":
        return this.#isInnerMostFunction ? i18nString4(UIStrings4.local) : i18nString4(UIStrings4.closure);
      case "block":
        return i18nString4(UIStrings4.block);
    }
    return this.#scope.kind ?? "";
  }
  name() {
    return this.#scope.name;
  }
  range() {
    return null;
  }
  object() {
    return new SourceMapScopeRemoteObject(this.#callFrame, this.#scope, this.#range);
  }
  description() {
    return "";
  }
  icon() {
    return void 0;
  }
};
var SourceMapScopeRemoteObject = class _SourceMapScopeRemoteObject extends RemoteObjectImpl {
  #callFrame;
  #scope;
  #range;
  constructor(callFrame, scope, range) {
    super(
      callFrame.debuggerModel.runtimeModel(),
      /* objectId */
      void 0,
      "object",
      /* sub type */
      void 0,
      /* value */
      null
    );
    this.#callFrame = callFrame;
    this.#scope = scope;
    this.#range = range;
  }
  async doGetProperties(_ownProperties, accessorPropertiesOnly, generatePreview) {
    if (accessorPropertiesOnly) {
      return { properties: [], internalProperties: [] };
    }
    const properties = [];
    for (const [index, variable] of this.#scope.variables.entries()) {
      const expression = this.#findExpression(index);
      if (expression === null) {
        properties.push(_SourceMapScopeRemoteObject.#unavailableProperty(variable));
        continue;
      }
      const result = await this.#callFrame.evaluate({ expression, generatePreview });
      if ("error" in result || result.exceptionDetails) {
        properties.push(_SourceMapScopeRemoteObject.#unavailableProperty(variable));
      } else {
        properties.push(new RemoteObjectProperty(
          variable,
          result.object,
          /* enumerable */
          false,
          /* writable */
          false,
          /* isOwn */
          true,
          /* wasThrown */
          false
        ));
      }
    }
    return { properties, internalProperties: [] };
  }
  /** @returns null if the variable is unavailable at the current paused location */
  #findExpression(index) {
    if (!this.#range) {
      return null;
    }
    const expressionOrSubRanges = this.#range.values[index];
    if (typeof expressionOrSubRanges === "string") {
      return expressionOrSubRanges;
    }
    if (expressionOrSubRanges === void 0) {
      return null;
    }
    const pausedPosition = this.#callFrame.location();
    for (const range of expressionOrSubRanges) {
      if (contains({ start: range.from, end: range.to }, pausedPosition.lineNumber, pausedPosition.columnNumber)) {
        return range.value ?? null;
      }
    }
    return null;
  }
  static #unavailableProperty(name) {
    return new RemoteObjectProperty(
      name,
      null,
      /* enumerable */
      false,
      /* writeable */
      false,
      /* isOwn */
      true,
      /* wasThrown */
      false
    );
  }
};

// gen/front_end/core/sdk/SourceMapScopes.js
var SourceMapScopes_exports = {};
__export(SourceMapScopes_exports, {
  EncodedGeneratedRangeFlag: () => EncodedGeneratedRangeFlag,
  EncodedOriginalScopeFlag: () => EncodedOriginalScopeFlag,
  decodeGeneratedRanges: () => decodeGeneratedRanges,
  decodeOriginalScopes: () => decodeOriginalScopes
});
function decodeOriginalScopes(encodedOriginalScopes, names) {
  return encodedOriginalScopes.map((scope) => decodeOriginalScope(scope, names));
}
function decodeOriginalScope(encodedOriginalScope, names) {
  const scopeForItemIndex = /* @__PURE__ */ new Map();
  const scopeStack = [];
  let line = 0;
  let kindIdx = 0;
  for (const [index, item] of decodeOriginalScopeItems(encodedOriginalScope)) {
    line += item.line;
    const { column } = item;
    if (isStart(item)) {
      let kind;
      if (item.kind !== void 0) {
        kindIdx += item.kind;
        kind = resolveName(kindIdx, names);
      }
      const name = resolveName(item.name, names);
      const variables = item.variables.map((idx) => names[idx]);
      const scope = {
        start: { line, column },
        end: { line, column },
        kind,
        name,
        isStackFrame: Boolean(
          item.flags & 4
          /* IS_STACK_FRAME */
        ),
        variables,
        children: []
      };
      scopeStack.push(scope);
      scopeForItemIndex.set(index, scope);
    } else {
      const scope = scopeStack.pop();
      if (!scope) {
        throw new Error('Scope items not nested properly: encountered "end" item without "start" item');
      }
      scope.end = { line, column };
      if (scopeStack.length === 0) {
        return { root: scope, scopeForItemIndex };
      }
      scope.parent = scopeStack[scopeStack.length - 1];
      scopeStack[scopeStack.length - 1].children.push(scope);
    }
  }
  throw new Error("Malformed original scope encoding");
}
var EncodedOriginalScopeFlag = /* @__PURE__ */ ((EncodedOriginalScopeFlag2) => {
  EncodedOriginalScopeFlag2[EncodedOriginalScopeFlag2["HAS_NAME"] = 1] = "HAS_NAME";
  EncodedOriginalScopeFlag2[EncodedOriginalScopeFlag2["HAS_KIND"] = 2] = "HAS_KIND";
  EncodedOriginalScopeFlag2[EncodedOriginalScopeFlag2["IS_STACK_FRAME"] = 4] = "IS_STACK_FRAME";
  return EncodedOriginalScopeFlag2;
})(EncodedOriginalScopeFlag || {});
function isStart(item) {
  return "flags" in item;
}
function* decodeOriginalScopeItems(encodedOriginalScope) {
  const iter = new TokenIterator(encodedOriginalScope);
  let prevColumn = 0;
  let itemCount = 0;
  while (iter.hasNext()) {
    if (iter.peek() === ",") {
      iter.next();
    }
    const [line, column] = [iter.nextVLQ(), iter.nextVLQ()];
    if (line === 0 && column < prevColumn) {
      throw new Error("Malformed original scope encoding: start/end items must be ordered w.r.t. source positions");
    }
    prevColumn = column;
    if (!iter.hasNext() || iter.peek() === ",") {
      yield [itemCount++, { line, column }];
      continue;
    }
    const startItem = {
      line,
      column,
      flags: iter.nextVLQ(),
      variables: []
    };
    if (startItem.flags & 1) {
      startItem.name = iter.nextVLQ();
    }
    if (startItem.flags & 2) {
      startItem.kind = iter.nextVLQ();
    }
    while (iter.hasNext() && iter.peek() !== ",") {
      startItem.variables.push(iter.nextVLQ());
    }
    yield [itemCount++, startItem];
  }
}
function decodeGeneratedRanges(encodedGeneratedRange, originalScopeTrees, names) {
  const rangeStack = [{
    start: { line: 0, column: 0 },
    end: { line: 0, column: 0 },
    isStackFrame: false,
    isHidden: false,
    children: [],
    values: []
  }];
  const rangeToStartItem = /* @__PURE__ */ new Map();
  for (const item of decodeGeneratedRangeItems(encodedGeneratedRange)) {
    if (isRangeStart(item)) {
      const range = {
        start: { line: item.line, column: item.column },
        end: { line: item.line, column: item.column },
        isStackFrame: Boolean(
          item.flags & 4
          /* IS_STACK_FRAME */
        ),
        isHidden: Boolean(
          item.flags & 8
          /* IS_HIDDEN */
        ),
        values: [],
        children: []
      };
      if (item.definition) {
        const { scopeIdx, sourceIdx } = item.definition;
        if (!originalScopeTrees[sourceIdx]) {
          throw new Error("Invalid source index!");
        }
        const originalScope = originalScopeTrees[sourceIdx].scopeForItemIndex.get(scopeIdx);
        if (!originalScope) {
          throw new Error("Invalid original scope index!");
        }
        range.originalScope = originalScope;
      }
      if (item.callsite) {
        const { sourceIdx, line, column } = item.callsite;
        if (!originalScopeTrees[sourceIdx]) {
          throw new Error("Invalid source index!");
        }
        range.callsite = {
          sourceIndex: sourceIdx,
          line,
          column
        };
      }
      rangeToStartItem.set(range, item);
      rangeStack.push(range);
    } else {
      const range = rangeStack.pop();
      if (!range) {
        throw new Error('Range items not nested properly: encountered "end" item without "start" item');
      }
      range.end = { line: item.line, column: item.column };
      resolveBindings(range, names, rangeToStartItem.get(range)?.bindings);
      rangeStack[rangeStack.length - 1].children.push(range);
    }
  }
  if (rangeStack.length !== 1) {
    throw new Error("Malformed generated range encoding");
  }
  return rangeStack[0].children;
}
function resolveBindings(range, names, bindingsForAllVars) {
  if (bindingsForAllVars === void 0) {
    return;
  }
  range.values = bindingsForAllVars.map((bindings) => {
    if (bindings.length === 1) {
      return resolveName(bindings[0].nameIdx, names);
    }
    const bindingRanges = bindings.map((binding) => ({
      from: { line: binding.line, column: binding.column },
      to: { line: binding.line, column: binding.column },
      value: resolveName(binding.nameIdx, names)
    }));
    for (let i = 1; i < bindingRanges.length; ++i) {
      bindingRanges[i - 1].to = { ...bindingRanges[i].from };
    }
    bindingRanges[bindingRanges.length - 1].to = { ...range.end };
    return bindingRanges;
  });
}
var EncodedGeneratedRangeFlag = /* @__PURE__ */ ((EncodedGeneratedRangeFlag2) => {
  EncodedGeneratedRangeFlag2[EncodedGeneratedRangeFlag2["HAS_DEFINITION"] = 1] = "HAS_DEFINITION";
  EncodedGeneratedRangeFlag2[EncodedGeneratedRangeFlag2["HAS_CALLSITE"] = 2] = "HAS_CALLSITE";
  EncodedGeneratedRangeFlag2[EncodedGeneratedRangeFlag2["IS_STACK_FRAME"] = 4] = "IS_STACK_FRAME";
  EncodedGeneratedRangeFlag2[EncodedGeneratedRangeFlag2["IS_HIDDEN"] = 8] = "IS_HIDDEN";
  return EncodedGeneratedRangeFlag2;
})(EncodedGeneratedRangeFlag || {});
function isRangeStart(item) {
  return "flags" in item;
}
function* decodeGeneratedRangeItems(encodedGeneratedRange) {
  const iter = new TokenIterator(encodedGeneratedRange);
  let line = 0;
  const state = {
    line: 0,
    column: 0,
    defSourceIdx: 0,
    defScopeIdx: 0,
    callsiteSourceIdx: 0,
    callsiteLine: 0,
    callsiteColumn: 0
  };
  while (iter.hasNext()) {
    if (iter.peek() === ";") {
      iter.next();
      ++line;
      continue;
    } else if (iter.peek() === ",") {
      iter.next();
      continue;
    }
    state.column = iter.nextVLQ() + (line === state.line ? state.column : 0);
    state.line = line;
    if (iter.peekVLQ() === null) {
      yield { line, column: state.column };
      continue;
    }
    const startItem = {
      line,
      column: state.column,
      flags: iter.nextVLQ(),
      bindings: []
    };
    if (startItem.flags & 1) {
      const sourceIdx = iter.nextVLQ();
      const scopeIdx = iter.nextVLQ();
      state.defScopeIdx = scopeIdx + (sourceIdx === 0 ? state.defScopeIdx : 0);
      state.defSourceIdx += sourceIdx;
      startItem.definition = {
        sourceIdx: state.defSourceIdx,
        scopeIdx: state.defScopeIdx
      };
    }
    if (startItem.flags & 2) {
      const sourceIdx = iter.nextVLQ();
      const line2 = iter.nextVLQ();
      const column = iter.nextVLQ();
      state.callsiteColumn = column + (line2 === 0 && sourceIdx === 0 ? state.callsiteColumn : 0);
      state.callsiteLine = line2 + (sourceIdx === 0 ? state.callsiteLine : 0);
      state.callsiteSourceIdx += sourceIdx;
      startItem.callsite = {
        sourceIdx: state.callsiteSourceIdx,
        line: state.callsiteLine,
        column: state.callsiteColumn
      };
    }
    while (iter.hasNext() && iter.peek() !== ";" && iter.peek() !== ",") {
      const bindings = [];
      startItem.bindings.push(bindings);
      const idxOrSubrangeCount = iter.nextVLQ();
      if (idxOrSubrangeCount >= -1) {
        bindings.push({ line: startItem.line, column: startItem.column, nameIdx: idxOrSubrangeCount });
        continue;
      }
      bindings.push({ line: startItem.line, column: startItem.column, nameIdx: iter.nextVLQ() });
      const rangeCount = -idxOrSubrangeCount;
      for (let i = 0; i < rangeCount - 1; ++i) {
        const line2 = iter.nextVLQ();
        const column = iter.nextVLQ();
        const nameIdx = iter.nextVLQ();
        const lastLine = bindings.at(-1)?.line ?? 0;
        const lastColumn = bindings.at(-1)?.column ?? 0;
        bindings.push({
          line: line2 + lastLine,
          column: column + (line2 === 0 ? lastColumn : 0),
          nameIdx
        });
      }
    }
    yield startItem;
  }
}
function resolveName(idx, names) {
  if (idx === void 0 || idx < 0) {
    return void 0;
  }
  return names[idx];
}

// gen/front_end/core/sdk/SourceMapScopesInfo.js
var SourceMapScopesInfo = class _SourceMapScopesInfo {
  /* eslint-disable-next-line no-unused-private-class-members */
  #sourceMap;
  #originalScopes;
  #generatedRanges;
  #cachedVariablesAndBindingsPresent = null;
  constructor(sourceMap, originalScopes, generatedRanges) {
    this.#sourceMap = sourceMap;
    this.#originalScopes = originalScopes;
    this.#generatedRanges = generatedRanges;
  }
  static parseFromMap(sourceMap, sourceMapJson) {
    if (!sourceMapJson.originalScopes || !sourceMapJson.generatedRanges) {
      throw new Error("Cant create SourceMapScopesInfo without encoded scopes");
    }
    const scopeTrees = decodeOriginalScopes(sourceMapJson.originalScopes, sourceMapJson.names ?? []);
    const originalScopes = scopeTrees.map((tree) => tree.root);
    const generatedRanges = decodeGeneratedRanges(sourceMapJson.generatedRanges, scopeTrees, sourceMapJson.names ?? []);
    return new _SourceMapScopesInfo(sourceMap, originalScopes, generatedRanges);
  }
  /**
   * Given a generated position, returns the original name of the surrounding function as well as
   * all the original function names that got inlined into the surrounding generated function and their
   * respective callsites in the original code (ordered from inner to outer).
   *
   * @returns a list with inlined functions. Every entry in the list has a callsite in the orignal code,
   * except the last function (since the last function didn't get inlined).
   */
  findInlinedFunctions(generatedLine, generatedColumn) {
    const rangeChain = this.#findGeneratedRangeChain(generatedLine, generatedColumn);
    const result = {
      inlinedFunctions: [],
      originalFunctionName: ""
    };
    for (let i = rangeChain.length - 1; i >= 0; --i) {
      const range = rangeChain[i];
      if (range.callsite) {
        result.inlinedFunctions.push({ name: range.originalScope?.name ?? "", callsite: range.callsite });
      }
      if (range.isStackFrame) {
        result.originalFunctionName = range.originalScope?.name ?? "";
        break;
      }
    }
    return result;
  }
  /**
   * Takes a V8 provided call frame and expands any inlined frames into virtual call frames.
   *
   * For call frames where nothing was inlined, the result contains only a single element,
   * the provided frame but with the original name.
   *
   * For call frames where we are paused in inlined code, this function returns a list of
   * call frames from "inner to outer". This is the call frame at index 0
   * signifies the top of this stack trace fragment.
   *
   * The rest are "virtual" call frames and will have an "inlineFrameIndex" set in ascending
   * order, so the condition `result[index] === result[index].inlineFrameIndex` always holds.
   */
  expandCallFrame(callFrame) {
    const { originalFunctionName, inlinedFunctions } = this.findInlinedFunctions(callFrame.location().lineNumber, callFrame.location().columnNumber);
    const result = [];
    for (const [index, fn] of inlinedFunctions.entries()) {
      result.push(callFrame.createVirtualCallFrame(index, fn.name));
    }
    result.push(callFrame.createVirtualCallFrame(result.length, originalFunctionName));
    return result;
  }
  /**
   * Given a generated position, this returns all the surrounding generated ranges from outer
   * to inner.
   */
  #findGeneratedRangeChain(line, column) {
    const result = [];
    (function walkRanges(ranges) {
      for (const range of ranges) {
        if (!contains(range, line, column)) {
          continue;
        }
        result.push(range);
        walkRanges(range.children);
      }
    })(this.#generatedRanges);
    return result;
  }
  /**
   * @returns true if we have enough info (i.e. variable and binding expressions) to build
   * a scope view.
   */
  hasVariablesAndBindings() {
    if (this.#cachedVariablesAndBindingsPresent === null) {
      this.#cachedVariablesAndBindingsPresent = this.#areVariablesAndBindingsPresent();
    }
    return this.#cachedVariablesAndBindingsPresent;
  }
  #areVariablesAndBindingsPresent() {
    function walkTree(nodes) {
      for (const node of nodes) {
        if ("variables" in node && node.variables.length > 0) {
          return true;
        }
        if ("values" in node && node.values.some((v) => v !== void 0)) {
          return true;
        }
        if (walkTree(node.children)) {
          return true;
        }
      }
      return false;
    }
    return walkTree(this.#originalScopes) && walkTree(this.#generatedRanges);
  }
  /**
   * Constructs a scope chain based on the CallFrame's paused position.
   *
   * The algorithm to obtain the original scope chain is straight-forward:
   *
   *   1) Find the inner-most generated range that contains the CallFrame's
   *      paused position.
   *
   *   2) Does the found range have an associated original scope?
   *
   *      2a) If no, return null. This is a "hidden" range and technically
   *          we shouldn't be pausing here in the first place. This code doesn't
   *          correspond to anything in the authored code.
   *
   *      2b) If yes, the associated original scope is the inner-most
   *          original scope in the resulting scope chain.
   *
   *   3) Walk the parent chain of the found original scope outwards. This is
   *      our scope view. For each original scope we also try to find a
   *      corresponding generated range that contains the CallFrame's
   *      paused position. We need the generated range to resolve variable
   *      values.
   */
  resolveMappedScopeChain(callFrame) {
    const rangeChain = this.#findGeneratedRangeChainForFrame(callFrame);
    const innerMostOriginalScope = rangeChain.at(-1)?.originalScope;
    if (innerMostOriginalScope === void 0) {
      return null;
    }
    let seenFunctionScope = false;
    const result = [];
    for (let originalScope = rangeChain.at(-1)?.originalScope; originalScope; originalScope = originalScope.parent) {
      const range = rangeChain.findLast((r) => r.originalScope === originalScope);
      const isFunctionScope = originalScope.kind === "function";
      const isInnerMostFunction = isFunctionScope && !seenFunctionScope;
      const returnValue = isInnerMostFunction ? callFrame.returnValue() : null;
      result.push(
        new SourceMapScopeChainEntry(callFrame, originalScope, range, isInnerMostFunction, returnValue ?? void 0)
      );
      seenFunctionScope ||= isFunctionScope;
    }
    if (callFrame.returnValue() !== null) {
      while (result.length && result[0].type() !== Debugger.ScopeType.Local) {
        result.shift();
      }
    }
    return result;
  }
  /** Similar to #findGeneratedRangeChain, but takes inlineFrameIndex of virtual call frames into account */
  #findGeneratedRangeChainForFrame(callFrame) {
    const rangeChain = this.#findGeneratedRangeChain(callFrame.location().lineNumber, callFrame.location().columnNumber);
    if (callFrame.inlineFrameIndex === 0) {
      return rangeChain;
    }
    for (let inlineIndex = 0; inlineIndex < callFrame.inlineFrameIndex; ) {
      const range = rangeChain.pop();
      if (range?.callsite) {
        ++inlineIndex;
      }
    }
    return rangeChain;
  }
};
function contains(range, line, column) {
  if (range.start.line > line || range.start.line === line && range.start.column > column) {
    return false;
  }
  if (range.end.line < line || range.end.line === line && range.end.column <= column) {
    return false;
  }
  return true;
}

// gen/front_end/core/sdk/SourceMap.js
function parseSourceMap(content) {
  if (content.startsWith(")]}")) {
    content = content.substring(content.indexOf("\n"));
  }
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return JSON.parse(content);
}
var SourceMapEntry = class {
  lineNumber;
  columnNumber;
  sourceIndex;
  sourceURL;
  sourceLineNumber;
  sourceColumnNumber;
  name;
  constructor(lineNumber, columnNumber, sourceIndex, sourceURL, sourceLineNumber, sourceColumnNumber, name) {
    this.lineNumber = lineNumber;
    this.columnNumber = columnNumber;
    this.sourceIndex = sourceIndex;
    this.sourceURL = sourceURL;
    this.sourceLineNumber = sourceLineNumber;
    this.sourceColumnNumber = sourceColumnNumber;
    this.name = name;
  }
  static compare(entry1, entry2) {
    if (entry1.lineNumber !== entry2.lineNumber) {
      return entry1.lineNumber - entry2.lineNumber;
    }
    return entry1.columnNumber - entry2.columnNumber;
  }
};
function comparePositions(a, b) {
  return a.lineNumber - b.lineNumber || a.columnNumber - b.columnNumber;
}
var ScopeTreeEntry = class {
  constructor(startLineNumber, startColumnNumber, endLineNumber, endColumnNumber, name) {
    this.startLineNumber = startLineNumber;
    this.startColumnNumber = startColumnNumber;
    this.endLineNumber = endLineNumber;
    this.endColumnNumber = endColumnNumber;
    this.name = name;
  }
  children = [];
  scopeName() {
    return this.name;
  }
  start() {
    return { lineNumber: this.startLineNumber, columnNumber: this.startColumnNumber };
  }
  end() {
    return { lineNumber: this.endLineNumber, columnNumber: this.endColumnNumber };
  }
};
var sourceMapToSourceList = /* @__PURE__ */ new WeakMap();
var SourceMap = class {
  #json;
  #compiledURLInternal;
  #sourceMappingURL;
  #baseURL;
  #mappingsInternal;
  #sourceInfos;
  /* eslint-disable-next-line no-unused-private-class-members */
  #scopesInfo = null;
  /**
   * Implements Source Map V3 model. See https://github.com/google/closure-compiler/wiki/Source-Maps
   * for format description.
   */
  constructor(compiledURL, sourceMappingURL, payload) {
    this.#json = payload;
    this.#compiledURLInternal = compiledURL;
    this.#sourceMappingURL = sourceMappingURL;
    this.#baseURL = Common11.ParsedURL.schemeIs(sourceMappingURL, "data:") ? compiledURL : sourceMappingURL;
    this.#mappingsInternal = null;
    this.#sourceInfos = /* @__PURE__ */ new Map();
    if ("sections" in this.#json) {
      if (this.#json.sections.find((section) => "url" in section)) {
        Common11.Console.Console.instance().warn(
          `SourceMap "${sourceMappingURL}" contains unsupported "URL" field in one of its sections.`
        );
      }
    }
    this.eachSection(this.parseSources.bind(this));
  }
  compiledURL() {
    return this.#compiledURLInternal;
  }
  url() {
    return this.#sourceMappingURL;
  }
  sourceURLs() {
    return [...this.#sourceInfos.keys()];
  }
  embeddedContentByURL(sourceURL) {
    const entry = this.#sourceInfos.get(sourceURL);
    if (!entry) {
      return null;
    }
    return entry.content;
  }
  hasScopeInfo() {
    this.#ensureMappingsProcessed();
    return this.#scopesInfo !== null;
  }
  findEntry(lineNumber, columnNumber, inlineFrameIndex) {
    this.#ensureMappingsProcessed();
    if (inlineFrameIndex && this.#scopesInfo !== null) {
      const { inlinedFunctions } = this.#scopesInfo.findInlinedFunctions(lineNumber, columnNumber);
      const { callsite } = inlinedFunctions[inlineFrameIndex - 1];
      if (!callsite) {
        console.error("Malformed source map. Expected to have a callsite info for index", inlineFrameIndex);
        return null;
      }
      return {
        lineNumber,
        columnNumber,
        sourceIndex: callsite.sourceIndex,
        sourceURL: this.sourceURLs()[callsite.sourceIndex],
        sourceLineNumber: callsite.line,
        sourceColumnNumber: callsite.column,
        name: void 0
      };
    }
    const mappings = this.mappings();
    const index = Platform8.ArrayUtilities.upperBound(
      mappings,
      void 0,
      (unused, entry) => lineNumber - entry.lineNumber || columnNumber - entry.columnNumber
    );
    return index ? mappings[index - 1] : null;
  }
  findEntryRanges(lineNumber, columnNumber) {
    const mappings = this.mappings();
    const endIndex = Platform8.ArrayUtilities.upperBound(
      mappings,
      void 0,
      (unused, entry) => lineNumber - entry.lineNumber || columnNumber - entry.columnNumber
    );
    if (!endIndex) {
      return null;
    }
    const startIndex = endIndex - 1;
    const sourceURL = mappings[startIndex].sourceURL;
    if (!sourceURL) {
      return null;
    }
    const endLine = endIndex < mappings.length ? mappings[endIndex].lineNumber : 2 ** 31 - 1;
    const endColumn = endIndex < mappings.length ? mappings[endIndex].columnNumber : 2 ** 31 - 1;
    const range = new TextUtils14.TextRange.TextRange(
      mappings[startIndex].lineNumber,
      mappings[startIndex].columnNumber,
      endLine,
      endColumn
    );
    const reverseMappings = this.reversedMappings(sourceURL);
    const startSourceLine = mappings[startIndex].sourceLineNumber;
    const startSourceColumn = mappings[startIndex].sourceColumnNumber;
    const endReverseIndex = Platform8.ArrayUtilities.upperBound(
      reverseMappings,
      void 0,
      (unused, i) => startSourceLine - mappings[i].sourceLineNumber || startSourceColumn - mappings[i].sourceColumnNumber
    );
    if (!endReverseIndex) {
      return null;
    }
    const endSourceLine = endReverseIndex < reverseMappings.length ? mappings[reverseMappings[endReverseIndex]].sourceLineNumber : 2 ** 31 - 1;
    const endSourceColumn = endReverseIndex < reverseMappings.length ? mappings[reverseMappings[endReverseIndex]].sourceColumnNumber : 2 ** 31 - 1;
    const sourceRange = new TextUtils14.TextRange.TextRange(startSourceLine, startSourceColumn, endSourceLine, endSourceColumn);
    return { range, sourceRange, sourceURL };
  }
  sourceLineMapping(sourceURL, lineNumber, columnNumber) {
    const mappings = this.mappings();
    const reverseMappings = this.reversedMappings(sourceURL);
    const first = Platform8.ArrayUtilities.lowerBound(reverseMappings, lineNumber, lineComparator);
    const last = Platform8.ArrayUtilities.upperBound(reverseMappings, lineNumber, lineComparator);
    if (first >= reverseMappings.length || mappings[reverseMappings[first]].sourceLineNumber !== lineNumber) {
      return null;
    }
    const columnMappings = reverseMappings.slice(first, last);
    if (!columnMappings.length) {
      return null;
    }
    const index = Platform8.ArrayUtilities.lowerBound(
      columnMappings,
      columnNumber,
      (columnNumber2, i) => columnNumber2 - mappings[i].sourceColumnNumber
    );
    return index >= columnMappings.length ? mappings[columnMappings[columnMappings.length - 1]] : mappings[columnMappings[index]];
    function lineComparator(lineNumber2, i) {
      return lineNumber2 - mappings[i].sourceLineNumber;
    }
  }
  findReverseIndices(sourceURL, lineNumber, columnNumber) {
    const mappings = this.mappings();
    const reverseMappings = this.reversedMappings(sourceURL);
    const endIndex = Platform8.ArrayUtilities.upperBound(
      reverseMappings,
      void 0,
      (unused, i) => lineNumber - mappings[i].sourceLineNumber || columnNumber - mappings[i].sourceColumnNumber
    );
    let startIndex = endIndex;
    while (startIndex > 0 && mappings[reverseMappings[startIndex - 1]].sourceLineNumber === mappings[reverseMappings[endIndex - 1]].sourceLineNumber && mappings[reverseMappings[startIndex - 1]].sourceColumnNumber === mappings[reverseMappings[endIndex - 1]].sourceColumnNumber) {
      --startIndex;
    }
    return reverseMappings.slice(startIndex, endIndex);
  }
  findReverseEntries(sourceURL, lineNumber, columnNumber) {
    const mappings = this.mappings();
    return this.findReverseIndices(sourceURL, lineNumber, columnNumber).map((i) => mappings[i]);
  }
  findReverseRanges(sourceURL, lineNumber, columnNumber) {
    const mappings = this.mappings();
    const indices = this.findReverseIndices(sourceURL, lineNumber, columnNumber);
    const ranges = [];
    for (let i = 0; i < indices.length; ++i) {
      const startIndex = indices[i];
      let endIndex = startIndex + 1;
      while (i + 1 < indices.length && endIndex === indices[i + 1]) {
        ++endIndex;
        ++i;
      }
      const startLine = mappings[startIndex].lineNumber;
      const startColumn = mappings[startIndex].columnNumber;
      const endLine = endIndex < mappings.length ? mappings[endIndex].lineNumber : 2 ** 31 - 1;
      const endColumn = endIndex < mappings.length ? mappings[endIndex].columnNumber : 2 ** 31 - 1;
      ranges.push(new TextUtils14.TextRange.TextRange(startLine, startColumn, endLine, endColumn));
    }
    return ranges;
  }
  mappings() {
    this.#ensureMappingsProcessed();
    return this.#mappingsInternal ?? [];
  }
  reversedMappings(sourceURL) {
    this.#ensureMappingsProcessed();
    return this.#sourceInfos.get(sourceURL)?.reverseMappings ?? [];
  }
  #ensureMappingsProcessed() {
    if (this.#mappingsInternal === null) {
      this.#mappingsInternal = [];
      try {
        this.eachSection(this.parseMap.bind(this));
      } catch (e) {
        console.error("Failed to parse source map", e);
        this.#mappingsInternal = [];
      }
      this.mappings().sort(SourceMapEntry.compare);
      this.#computeReverseMappings(this.#mappingsInternal);
      this.#json = null;
    }
  }
  #computeReverseMappings(mappings) {
    const reverseMappingsPerUrl = /* @__PURE__ */ new Map();
    for (let i = 0; i < mappings.length; i++) {
      const entryUrl = mappings[i].sourceURL;
      if (!entryUrl) {
        continue;
      }
      let reverseMap = reverseMappingsPerUrl.get(entryUrl);
      if (!reverseMap) {
        reverseMap = [];
        reverseMappingsPerUrl.set(entryUrl, reverseMap);
      }
      reverseMap.push(i);
    }
    for (const [url, reverseMap] of reverseMappingsPerUrl.entries()) {
      const info = this.#sourceInfos.get(url);
      if (!info) {
        continue;
      }
      reverseMap.sort(sourceMappingComparator);
      info.reverseMappings = reverseMap;
    }
    function sourceMappingComparator(indexA, indexB) {
      const a = mappings[indexA];
      const b = mappings[indexB];
      return a.sourceLineNumber - b.sourceLineNumber || a.sourceColumnNumber - b.sourceColumnNumber || a.lineNumber - b.lineNumber || a.columnNumber - b.columnNumber;
    }
  }
  eachSection(callback) {
    if (!this.#json) {
      return;
    }
    if ("sections" in this.#json) {
      for (const section of this.#json.sections) {
        if ("map" in section) {
          callback(section.map, section.offset.line, section.offset.column);
        }
      }
    } else {
      callback(this.#json, 0, 0);
    }
  }
  parseSources(sourceMap) {
    const sourcesList = [];
    const sourceRoot = sourceMap.sourceRoot ?? "";
    const ignoreList = new Set(sourceMap.ignoreList ?? sourceMap.x_google_ignoreList);
    for (let i = 0; i < sourceMap.sources.length; ++i) {
      let href = sourceMap.sources[i];
      if (Common11.ParsedURL.ParsedURL.isRelativeURL(href)) {
        if (sourceRoot && !sourceRoot.endsWith("/") && href && !href.startsWith("/")) {
          href = sourceRoot.concat("/", href);
        } else {
          href = sourceRoot.concat(href);
        }
      }
      const url = Common11.ParsedURL.ParsedURL.completeURL(this.#baseURL, href) || href;
      const source = sourceMap.sourcesContent && sourceMap.sourcesContent[i];
      sourcesList.push(url);
      if (!this.#sourceInfos.has(url)) {
        const content = source ?? null;
        const ignoreListHint = ignoreList.has(i);
        this.#sourceInfos.set(url, { content, ignoreListHint, reverseMappings: null, scopeTree: null });
      }
    }
    sourceMapToSourceList.set(sourceMap, sourcesList);
  }
  parseMap(map, lineNumber, columnNumber) {
    let sourceIndex = 0;
    let sourceLineNumber = 0;
    let sourceColumnNumber = 0;
    let nameIndex = 0;
    const sources = sourceMapToSourceList.get(map);
    const names = map.names ?? [];
    const tokenIter = new TokenIterator(map.mappings);
    let sourceURL = sources && sources[sourceIndex];
    while (true) {
      if (tokenIter.peek() === ",") {
        tokenIter.next();
      } else {
        while (tokenIter.peek() === ";") {
          lineNumber += 1;
          columnNumber = 0;
          tokenIter.next();
        }
        if (!tokenIter.hasNext()) {
          break;
        }
      }
      columnNumber += tokenIter.nextVLQ();
      if (!tokenIter.hasNext() || this.isSeparator(tokenIter.peek())) {
        this.mappings().push(new SourceMapEntry(lineNumber, columnNumber));
        continue;
      }
      const sourceIndexDelta = tokenIter.nextVLQ();
      if (sourceIndexDelta) {
        sourceIndex += sourceIndexDelta;
        if (sources) {
          sourceURL = sources[sourceIndex];
        }
      }
      sourceLineNumber += tokenIter.nextVLQ();
      sourceColumnNumber += tokenIter.nextVLQ();
      if (!tokenIter.hasNext() || this.isSeparator(tokenIter.peek())) {
        this.mappings().push(
          new SourceMapEntry(lineNumber, columnNumber, sourceIndex, sourceURL, sourceLineNumber, sourceColumnNumber)
        );
        continue;
      }
      nameIndex += tokenIter.nextVLQ();
      this.mappings().push(new SourceMapEntry(
        lineNumber,
        columnNumber,
        sourceIndex,
        sourceURL,
        sourceLineNumber,
        sourceColumnNumber,
        names[nameIndex]
      ));
    }
    if (Root3.Runtime.experiments.isEnabled(Root3.Runtime.ExperimentName.USE_SOURCE_MAP_SCOPES)) {
      this.parseBloombergScopes(map);
      this.#parseScopes(map);
    }
  }
  parseBloombergScopes(map) {
    if (!map.x_com_bloomberg_sourcesFunctionMappings) {
      return;
    }
    const sources = sourceMapToSourceList.get(map);
    if (!sources) {
      return;
    }
    const names = map.names ?? [];
    const scopeList = map.x_com_bloomberg_sourcesFunctionMappings;
    for (let i = 0; i < sources?.length; i++) {
      if (!scopeList[i] || !sources[i]) {
        continue;
      }
      const sourceInfo = this.#sourceInfos.get(sources[i]);
      if (!sourceInfo) {
        continue;
      }
      const scopes = scopeList[i];
      let nameIndex = 0;
      let startLineNumber = 0;
      let startColumnNumber = 0;
      let endLineNumber = 0;
      let endColumnNumber = 0;
      const tokenIter = new TokenIterator(scopes);
      const entries = [];
      let atStart = true;
      while (tokenIter.hasNext()) {
        if (atStart) {
          atStart = false;
        } else if (tokenIter.peek() === ",") {
          tokenIter.next();
        } else {
          return;
        }
        nameIndex += tokenIter.nextVLQ();
        startLineNumber += tokenIter.nextVLQ();
        startColumnNumber += tokenIter.nextVLQ();
        endLineNumber += tokenIter.nextVLQ();
        endColumnNumber += tokenIter.nextVLQ();
        entries.push(new ScopeTreeEntry(
          startLineNumber,
          startColumnNumber,
          endLineNumber,
          endColumnNumber,
          names[nameIndex] ?? "<invalid>"
        ));
      }
      sourceInfo.scopeTree = this.buildScopeTree(entries);
    }
  }
  buildScopeTree(entries) {
    const toplevel = [];
    entries.sort((l, r) => comparePositions(l.start(), r.start()));
    const stack = [];
    for (const entry of entries) {
      const start = entry.start();
      while (stack.length > 0) {
        const top = stack[stack.length - 1];
        if (comparePositions(top.end(), start) < 0) {
          stack.pop();
        } else {
          break;
        }
      }
      if (stack.length > 0) {
        stack[stack.length - 1].children.push(entry);
      } else {
        toplevel.push(entry);
      }
      stack.push(entry);
    }
    return toplevel;
  }
  #parseScopes(map) {
    if (map.originalScopes && map.generatedRanges) {
      this.#scopesInfo = SourceMapScopesInfo.parseFromMap(this, map);
    }
  }
  findScopeEntry(sourceURL, sourceLineNumber, sourceColumnNumber) {
    const sourceInfo = this.#sourceInfos.get(sourceURL);
    if (!sourceInfo || !sourceInfo.scopeTree) {
      return null;
    }
    const position = { lineNumber: sourceLineNumber, columnNumber: sourceColumnNumber };
    let current = null;
    while (true) {
      const children = current?.children ?? sourceInfo.scopeTree;
      const match = children.find(
        (child) => comparePositions(child.start(), position) <= 0 && comparePositions(position, child.end()) <= 0
      );
      if (!match) {
        return current;
      }
      current = match;
    }
  }
  isSeparator(char) {
    return char === "," || char === ";";
  }
  /**
   * Finds all the reverse mappings that intersect with the given `textRange` within the
   * source entity identified by the `url`. If the `url` does not have any reverse mappings
   * within this source map, an empty array is returned.
   *
   * @param url the URL of the source entity to query.
   * @param textRange the range of text within the entity to check, considered `[start,end[`.
   * @returns the list of ranges in the generated file that map to locations overlapping the
   *          {@link textRange} in the source file identified by the {@link url}, or `[]`
   *          if the {@link url} does not identify an entity in this source map.
   */
  reverseMapTextRanges(url, textRange) {
    const reverseMappings = this.reversedMappings(url);
    const mappings = this.mappings();
    if (reverseMappings.length === 0) {
      return [];
    }
    let startReverseIndex = Platform8.ArrayUtilities.lowerBound(reverseMappings, textRange, ({ startLine, startColumn }, index) => {
      const { sourceLineNumber, sourceColumnNumber } = mappings[index];
      return startLine - sourceLineNumber || startColumn - sourceColumnNumber;
    });
    while (startReverseIndex === reverseMappings.length || startReverseIndex > 0 && (mappings[reverseMappings[startReverseIndex]].sourceLineNumber > textRange.startLine || mappings[reverseMappings[startReverseIndex]].sourceColumnNumber > textRange.startColumn)) {
      startReverseIndex--;
    }
    let endReverseIndex = startReverseIndex + 1;
    for (; endReverseIndex < reverseMappings.length; ++endReverseIndex) {
      const { sourceLineNumber, sourceColumnNumber } = mappings[reverseMappings[endReverseIndex]];
      if (sourceLineNumber < textRange.endLine || sourceLineNumber === textRange.endLine && sourceColumnNumber < textRange.endColumn) {
        continue;
      }
      break;
    }
    const ranges = [];
    for (let reverseIndex = startReverseIndex; reverseIndex < endReverseIndex; ++reverseIndex) {
      const startIndex = reverseMappings[reverseIndex], endIndex = startIndex + 1;
      const range = TextUtils14.TextRange.TextRange.createUnboundedFromLocation(
        mappings[startIndex].lineNumber,
        mappings[startIndex].columnNumber
      );
      if (endIndex < mappings.length) {
        range.endLine = mappings[endIndex].lineNumber;
        range.endColumn = mappings[endIndex].columnNumber;
      }
      ranges.push(range);
    }
    ranges.sort(TextUtils14.TextRange.TextRange.comparator);
    let j = 0;
    for (let i = 1; i < ranges.length; ++i) {
      if (ranges[j].immediatelyPrecedes(ranges[i])) {
        ranges[j].endLine = ranges[i].endLine;
        ranges[j].endColumn = ranges[i].endColumn;
      } else {
        ranges[++j] = ranges[i];
      }
    }
    ranges.length = j + 1;
    return ranges;
  }
  mapsOrigin() {
    const mappings = this.mappings();
    if (mappings.length > 0) {
      const firstEntry = mappings[0];
      return firstEntry?.lineNumber === 0 || firstEntry.columnNumber === 0;
    }
    return false;
  }
  hasIgnoreListHint(sourceURL) {
    return this.#sourceInfos.get(sourceURL)?.ignoreListHint ?? false;
  }
  /**
   * Returns a list of ranges in the generated script for original sources that
   * match a predicate. Each range is a [begin, end) pair, meaning that code at
   * the beginning location, up to but not including the end location, matches
   * the predicate.
   */
  findRanges(predicate, options) {
    const mappings = this.mappings();
    const ranges = [];
    if (!mappings.length) {
      return [];
    }
    let current = null;
    if ((mappings[0].lineNumber !== 0 || mappings[0].columnNumber !== 0) && options?.isStartMatching) {
      current = TextUtils14.TextRange.TextRange.createUnboundedFromLocation(0, 0);
      ranges.push(current);
    }
    for (const { sourceURL, lineNumber, columnNumber } of mappings) {
      const ignoreListHint = sourceURL && predicate(sourceURL);
      if (!current && ignoreListHint) {
        current = TextUtils14.TextRange.TextRange.createUnboundedFromLocation(lineNumber, columnNumber);
        ranges.push(current);
        continue;
      }
      if (current && !ignoreListHint) {
        current.endLine = lineNumber;
        current.endColumn = columnNumber;
        current = null;
      }
    }
    return ranges;
  }
  /**
   * Determines whether this and the {@link other} `SourceMap` agree on content and ignore-list hint
   * with respect to the {@link sourceURL}.
   *
   * @param sourceURL the URL to test for (might not be provided by either of the sourcemaps).
   * @param other the other `SourceMap` to check.
   * @returns `true` if both this and the {@link other} `SourceMap` either both have the ignore-list
   *          hint for {@link sourceURL} or neither, and if both of them either provide the same
   *          content for the {@link sourceURL} inline or both provide no `sourcesContent` entry
   *          for it.
   */
  compatibleForURL(sourceURL, other) {
    return this.embeddedContentByURL(sourceURL) === other.embeddedContentByURL(sourceURL) && this.hasIgnoreListHint(sourceURL) === other.hasIgnoreListHint(sourceURL);
  }
  expandCallFrame(frame) {
    this.#ensureMappingsProcessed();
    if (this.#scopesInfo === null) {
      return [frame];
    }
    return this.#scopesInfo.expandCallFrame(frame);
  }
  resolveScopeChain(frame) {
    this.#ensureMappingsProcessed();
    if (this.#scopesInfo === null) {
      return null;
    }
    return this.#scopesInfo.resolveMappedScopeChain(frame);
  }
};
var VLQ_BASE_SHIFT = 5;
var VLQ_BASE_MASK = (1 << 5) - 1;
var VLQ_CONTINUATION_MASK = 1 << 5;
var TokenIterator = class {
  #string;
  #position;
  constructor(string) {
    this.#string = string;
    this.#position = 0;
  }
  next() {
    return this.#string.charAt(this.#position++);
  }
  /** Returns the unicode value of the next character and advances the iterator  */
  nextCharCode() {
    return this.#string.charCodeAt(this.#position++);
  }
  peek() {
    return this.#string.charAt(this.#position);
  }
  hasNext() {
    return this.#position < this.#string.length;
  }
  nextVLQ() {
    let result = 0;
    let shift = 0;
    let digit = VLQ_CONTINUATION_MASK;
    while (digit & VLQ_CONTINUATION_MASK) {
      if (!this.hasNext()) {
        throw new Error("Unexpected end of input while decodling VLQ number!");
      }
      const charCode = this.nextCharCode();
      digit = Common11.Base64.BASE64_CODES[charCode];
      if (charCode !== 65 && digit === 0) {
        throw new Error(`Unexpected char '${String.fromCharCode(charCode)}' encountered while decoding`);
      }
      result += (digit & VLQ_BASE_MASK) << shift;
      shift += VLQ_BASE_SHIFT;
    }
    const negative = result & 1;
    result >>= 1;
    return negative ? -result : result;
  }
  /**
   * @returns the next VLQ number without iterating further. Or returns null if
   * the iterator is at the end or it's not a valid number.
   */
  peekVLQ() {
    const pos = this.#position;
    try {
      return this.nextVLQ();
    } catch {
      return null;
    } finally {
      this.#position = pos;
    }
  }
};

// gen/front_end/core/sdk/SourceMapManager.js
var SourceMapManager = class _SourceMapManager extends Common12.ObjectWrapper.ObjectWrapper {
  #target;
  #isEnabled;
  #clientData;
  #sourceMaps;
  #attachingClient;
  constructor(target) {
    super();
    this.#target = target;
    this.#isEnabled = true;
    this.#attachingClient = null;
    this.#clientData = /* @__PURE__ */ new Map();
    this.#sourceMaps = /* @__PURE__ */ new Map();
  }
  setEnabled(isEnabled) {
    if (isEnabled === this.#isEnabled) {
      return;
    }
    const clientData = [...this.#clientData.entries()];
    for (const [client] of clientData) {
      this.detachSourceMap(client);
    }
    this.#isEnabled = isEnabled;
    for (const [client, { relativeSourceURL, relativeSourceMapURL }] of clientData) {
      this.attachSourceMap(client, relativeSourceURL, relativeSourceMapURL);
    }
  }
  static getBaseUrl(target) {
    while (target && target.type() !== Type2.FRAME) {
      target = target.parentTarget();
    }
    return target?.inspectedURL() ?? Platform9.DevToolsPath.EmptyUrlString;
  }
  static resolveRelativeSourceURL(target, url) {
    url = Common12.ParsedURL.ParsedURL.completeURL(_SourceMapManager.getBaseUrl(target), url) ?? url;
    return url;
  }
  sourceMapForClient(client) {
    return this.#clientData.get(client)?.sourceMap;
  }
  // This method actively awaits the source map, if still loading.
  sourceMapForClientPromise(client) {
    const clientData = this.#clientData.get(client);
    if (!clientData) {
      return Promise.resolve(void 0);
    }
    return clientData.sourceMapPromise;
  }
  clientForSourceMap(sourceMap) {
    return this.#sourceMaps.get(sourceMap);
  }
  // TODO(bmeurer): We are lying about the type of |relativeSourceURL| here.
  attachSourceMap(client, relativeSourceURL, relativeSourceMapURL) {
    if (this.#clientData.has(client)) {
      throw new Error("SourceMap is already attached or being attached to client");
    }
    if (!relativeSourceMapURL) {
      return;
    }
    let clientData = {
      relativeSourceURL,
      relativeSourceMapURL,
      sourceMap: void 0,
      sourceMapPromise: Promise.resolve(void 0)
    };
    if (this.#isEnabled) {
      const sourceURL = _SourceMapManager.resolveRelativeSourceURL(this.#target, relativeSourceURL);
      const sourceMapURL = Common12.ParsedURL.ParsedURL.completeURL(sourceURL, relativeSourceMapURL);
      if (sourceMapURL) {
        if (this.#attachingClient) {
          console.error("Attaching source map may cancel previously attaching source map");
        }
        this.#attachingClient = client;
        this.dispatchEventToListeners("SourceMapWillAttach", { client });
        if (this.#attachingClient === client) {
          this.#attachingClient = null;
          const initiator = client.createPageResourceLoadInitiator();
          clientData.sourceMapPromise = loadSourceMap(sourceMapURL, initiator).then(
            (payload) => {
              const sourceMap = new SourceMap(sourceURL, sourceMapURL, payload);
              if (this.#clientData.get(client) === clientData) {
                clientData.sourceMap = sourceMap;
                this.#sourceMaps.set(sourceMap, client);
                this.dispatchEventToListeners("SourceMapAttached", { client, sourceMap });
              }
              return sourceMap;
            },
            () => {
              if (this.#clientData.get(client) === clientData) {
                this.dispatchEventToListeners("SourceMapFailedToAttach", { client });
              }
              return void 0;
            }
          );
        } else {
          if (this.#attachingClient) {
            console.error("Cancelling source map attach because another source map is attaching");
          }
          clientData = null;
          this.dispatchEventToListeners("SourceMapFailedToAttach", { client });
        }
      }
    }
    if (clientData) {
      this.#clientData.set(client, clientData);
    }
  }
  cancelAttachSourceMap(client) {
    if (client === this.#attachingClient) {
      this.#attachingClient = null;
    } else {
      if (this.#attachingClient) {
        console.error("cancel attach source map requested but a different source map was being attached");
      } else {
        console.error("cancel attach source map requested but no source map was being attached");
      }
    }
  }
  detachSourceMap(client) {
    const clientData = this.#clientData.get(client);
    if (!clientData) {
      return;
    }
    this.#clientData.delete(client);
    if (!this.#isEnabled) {
      return;
    }
    const { sourceMap } = clientData;
    if (sourceMap) {
      this.#sourceMaps.delete(sourceMap);
      this.dispatchEventToListeners("SourceMapDetached", { client, sourceMap });
    } else {
      this.dispatchEventToListeners("SourceMapFailedToAttach", { client });
    }
  }
};
async function loadSourceMap(url, initiator) {
  try {
    const { content } = await PageResourceLoader.instance().loadResource(url, initiator);
    return parseSourceMap(content);
  } catch (cause) {
    throw new Error(`Could not load content for ${url}: ${cause.message}`, { cause });
  }
}
var Events7 = /* @__PURE__ */ ((Events210) => {
  Events210["SourceMapWillAttach"] = "SourceMapWillAttach";
  Events210["SourceMapFailedToAttach"] = "SourceMapFailedToAttach";
  Events210["SourceMapAttached"] = "SourceMapAttached";
  Events210["SourceMapDetached"] = "SourceMapDetached";
  return Events210;
})(Events7 || {});

// gen/front_end/core/sdk/CSSModel.js
var ColorScheme = /* @__PURE__ */ ((ColorScheme2) => {
  ColorScheme2["LIGHT"] = "light";
  ColorScheme2["DARK"] = "dark";
  return ColorScheme2;
})(ColorScheme || {});
var CSSModel = class _CSSModel extends SDKModel {
  agent;
  #domModel;
  #fontFaces;
  #originalStyleSheetText;
  #resourceTreeModel;
  #sourceMapManager;
  #styleLoader;
  #stylePollingThrottler;
  #styleSheetIdsForURL;
  #styleSheetIdToHeader;
  #cachedMatchedCascadeNode;
  #cachedMatchedCascadePromise;
  #cssPropertyTracker;
  #isCSSPropertyTrackingEnabled;
  #isEnabled;
  #isRuleUsageTrackingEnabled;
  #isTrackingRequestPending;
  #colorScheme;
  constructor(target) {
    super(target);
    this.#isEnabled = false;
    this.#cachedMatchedCascadeNode = null;
    this.#cachedMatchedCascadePromise = null;
    this.#domModel = target.model(DOMModel);
    this.#sourceMapManager = new SourceMapManager(target);
    this.agent = target.cssAgent();
    this.#styleLoader = new ComputedStyleLoader(this);
    this.#resourceTreeModel = target.model(ResourceTreeModel);
    if (this.#resourceTreeModel) {
      this.#resourceTreeModel.addEventListener(
        Events4.PrimaryPageChanged,
        this.onPrimaryPageChanged,
        this
      );
    }
    target.registerCSSDispatcher(new CSSDispatcher(this));
    if (!target.suspended()) {
      void this.enable();
    }
    this.#styleSheetIdToHeader = /* @__PURE__ */ new Map();
    this.#styleSheetIdsForURL = /* @__PURE__ */ new Map();
    this.#originalStyleSheetText = /* @__PURE__ */ new Map();
    this.#isRuleUsageTrackingEnabled = false;
    this.#fontFaces = /* @__PURE__ */ new Map();
    this.#cssPropertyTracker = null;
    this.#isCSSPropertyTrackingEnabled = false;
    this.#isTrackingRequestPending = false;
    this.#stylePollingThrottler = new Common13.Throttler.Throttler(StylePollingInterval);
    this.#sourceMapManager.setEnabled(
      Common13.Settings.Settings.instance().moduleSetting("css-source-maps-enabled").get()
    );
    Common13.Settings.Settings.instance().moduleSetting("css-source-maps-enabled").addChangeListener((event) => this.#sourceMapManager.setEnabled(event.data));
  }
  async colorScheme() {
    if (!this.#colorScheme) {
      const colorSchemeResponse = await this.domModel()?.target().runtimeAgent().invoke_evaluate(
        { expression: 'window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches' }
      );
      if (colorSchemeResponse && !colorSchemeResponse.exceptionDetails && !colorSchemeResponse.getError()) {
        this.#colorScheme = colorSchemeResponse.result.value ? "dark" : "light";
      }
    }
    return this.#colorScheme;
  }
  headersForSourceURL(sourceURL) {
    const headers = [];
    for (const headerId of this.getStyleSheetIdsForURL(sourceURL)) {
      const header = this.styleSheetHeaderForId(headerId);
      if (header) {
        headers.push(header);
      }
    }
    return headers;
  }
  createRawLocationsByURL(sourceURL, lineNumber, columnNumber = 0) {
    const headers = this.headersForSourceURL(sourceURL);
    headers.sort(stylesheetComparator);
    const endIndex = Platform10.ArrayUtilities.upperBound(
      headers,
      void 0,
      (_, header) => lineNumber - header.startLine || columnNumber - header.startColumn
    );
    if (!endIndex) {
      return [];
    }
    const locations = [];
    const last = headers[endIndex - 1];
    for (let index = endIndex - 1; index >= 0 && headers[index].startLine === last.startLine && headers[index].startColumn === last.startColumn; --index) {
      if (headers[index].containsLocation(lineNumber, columnNumber)) {
        locations.push(new CSSLocation(headers[index], lineNumber, columnNumber));
      }
    }
    return locations;
    function stylesheetComparator(a, b) {
      return a.startLine - b.startLine || a.startColumn - b.startColumn || a.id.localeCompare(b.id);
    }
  }
  sourceMapManager() {
    return this.#sourceMapManager;
  }
  static readableLayerName(text) {
    return text || "<anonymous>";
  }
  static trimSourceURL(text) {
    let sourceURLIndex = text.lastIndexOf("/*# sourceURL=");
    if (sourceURLIndex === -1) {
      sourceURLIndex = text.lastIndexOf("/*@ sourceURL=");
      if (sourceURLIndex === -1) {
        return text;
      }
    }
    const sourceURLLineIndex = text.lastIndexOf("\n", sourceURLIndex);
    if (sourceURLLineIndex === -1) {
      return text;
    }
    const sourceURLLine = text.substr(sourceURLLineIndex + 1).split("\n", 1)[0];
    const sourceURLRegex2 = /[\x20\t]*\/\*[#@] sourceURL=[\x20\t]*([^\s]*)[\x20\t]*\*\/[\x20\t]*$/;
    if (sourceURLLine.search(sourceURLRegex2) === -1) {
      return text;
    }
    return text.substr(0, sourceURLLineIndex) + text.substr(sourceURLLineIndex + sourceURLLine.length + 1);
  }
  domModel() {
    return this.#domModel;
  }
  async trackComputedStyleUpdatesForNode(nodeId) {
    await this.agent.invoke_trackComputedStyleUpdatesForNode({ nodeId });
  }
  async setStyleText(styleSheetId, range, text, majorChange) {
    try {
      await this.ensureOriginalStyleSheetText(styleSheetId);
      const { styles } = await this.agent.invoke_setStyleTexts({ edits: [{ styleSheetId, range: range.serializeToObject(), text }] });
      if (!styles || styles.length !== 1) {
        return false;
      }
      this.#domModel.markUndoableState(!majorChange);
      const edit = new Edit(styleSheetId, range, text, styles[0]);
      this.fireStyleSheetChanged(styleSheetId, edit);
      return true;
    } catch (e) {
      console.error(e);
      return false;
    }
  }
  async setSelectorText(styleSheetId, range, text) {
    Host4.userMetrics.actionTaken(Host4.UserMetrics.Action.StyleRuleEdited);
    try {
      await this.ensureOriginalStyleSheetText(styleSheetId);
      const { selectorList } = await this.agent.invoke_setRuleSelector({ styleSheetId, range, selector: text });
      if (!selectorList) {
        return false;
      }
      this.#domModel.markUndoableState();
      const edit = new Edit(styleSheetId, range, text, selectorList);
      this.fireStyleSheetChanged(styleSheetId, edit);
      return true;
    } catch (e) {
      console.error(e);
      return false;
    }
  }
  async setPropertyRulePropertyName(styleSheetId, range, text) {
    Host4.userMetrics.actionTaken(Host4.UserMetrics.Action.StyleRuleEdited);
    try {
      await this.ensureOriginalStyleSheetText(styleSheetId);
      const { propertyName } = await this.agent.invoke_setPropertyRulePropertyName({ styleSheetId, range, propertyName: text });
      if (!propertyName) {
        return false;
      }
      this.#domModel.markUndoableState();
      const edit = new Edit(styleSheetId, range, text, propertyName);
      this.fireStyleSheetChanged(styleSheetId, edit);
      return true;
    } catch (e) {
      console.error(e);
      return false;
    }
  }
  async setKeyframeKey(styleSheetId, range, text) {
    Host4.userMetrics.actionTaken(Host4.UserMetrics.Action.StyleRuleEdited);
    try {
      await this.ensureOriginalStyleSheetText(styleSheetId);
      const { keyText } = await this.agent.invoke_setKeyframeKey({ styleSheetId, range, keyText: text });
      if (!keyText) {
        return false;
      }
      this.#domModel.markUndoableState();
      const edit = new Edit(styleSheetId, range, text, keyText);
      this.fireStyleSheetChanged(styleSheetId, edit);
      return true;
    } catch (e) {
      console.error(e);
      return false;
    }
  }
  startCoverage() {
    this.#isRuleUsageTrackingEnabled = true;
    return this.agent.invoke_startRuleUsageTracking();
  }
  async takeCoverageDelta() {
    const r = await this.agent.invoke_takeCoverageDelta();
    const timestamp = r && r.timestamp || 0;
    const coverage = r && r.coverage || [];
    return { timestamp, coverage };
  }
  setLocalFontsEnabled(enabled) {
    return this.agent.invoke_setLocalFontsEnabled({
      enabled
    });
  }
  async stopCoverage() {
    this.#isRuleUsageTrackingEnabled = false;
    await this.agent.invoke_stopRuleUsageTracking();
  }
  async getMediaQueries() {
    const { medias } = await this.agent.invoke_getMediaQueries();
    return medias ? CSSMedia.parseMediaArrayPayload(this, medias) : [];
  }
  async getRootLayer(nodeId) {
    const { rootLayer } = await this.agent.invoke_getLayersForNode({ nodeId });
    return rootLayer;
  }
  isEnabled() {
    return this.#isEnabled;
  }
  async enable() {
    await this.agent.invoke_enable();
    this.#isEnabled = true;
    if (this.#isRuleUsageTrackingEnabled) {
      await this.startCoverage();
    }
    this.dispatchEventToListeners(
      "ModelWasEnabled"
      /* ModelWasEnabled */
    );
  }
  async getMatchedStyles(nodeId) {
    const response = await this.agent.invoke_getMatchedStylesForNode({ nodeId });
    if (response.getError()) {
      return null;
    }
    const node = this.#domModel.nodeForId(nodeId);
    if (!node) {
      return null;
    }
    return await CSSMatchedStyles.create({
      cssModel: this,
      node,
      inlinePayload: response.inlineStyle || null,
      attributesPayload: response.attributesStyle || null,
      matchedPayload: response.matchedCSSRules || [],
      pseudoPayload: response.pseudoElements || [],
      inheritedPayload: response.inherited || [],
      inheritedPseudoPayload: response.inheritedPseudoElements || [],
      animationsPayload: response.cssKeyframesRules || [],
      parentLayoutNodeId: response.parentLayoutNodeId,
      positionTryRules: response.cssPositionTryRules || [],
      propertyRules: response.cssPropertyRules ?? [],
      cssPropertyRegistrations: response.cssPropertyRegistrations ?? [],
      fontPaletteValuesRule: response.cssFontPaletteValuesRule,
      activePositionFallbackIndex: response.activePositionFallbackIndex ?? -1
    });
  }
  async getClassNames(styleSheetId) {
    const { classNames } = await this.agent.invoke_collectClassNames({ styleSheetId });
    return classNames || [];
  }
  async getComputedStyle(nodeId) {
    if (!this.isEnabled()) {
      await this.enable();
    }
    return this.#styleLoader.computedStylePromise(nodeId);
  }
  async getBackgroundColors(nodeId) {
    const response = await this.agent.invoke_getBackgroundColors({ nodeId });
    if (response.getError()) {
      return null;
    }
    return {
      backgroundColors: response.backgroundColors || null,
      computedFontSize: response.computedFontSize || "",
      computedFontWeight: response.computedFontWeight || ""
    };
  }
  async getPlatformFonts(nodeId) {
    const { fonts } = await this.agent.invoke_getPlatformFontsForNode({ nodeId });
    return fonts;
  }
  allStyleSheets() {
    const values = [...this.#styleSheetIdToHeader.values()];
    function styleSheetComparator(a, b) {
      if (a.sourceURL < b.sourceURL) {
        return -1;
      }
      if (a.sourceURL > b.sourceURL) {
        return 1;
      }
      return a.startLine - b.startLine || a.startColumn - b.startColumn;
    }
    values.sort(styleSheetComparator);
    return values;
  }
  async getInlineStyles(nodeId) {
    const response = await this.agent.invoke_getInlineStylesForNode({ nodeId });
    if (response.getError() || !response.inlineStyle) {
      return null;
    }
    const inlineStyle = new CSSStyleDeclaration(this, null, response.inlineStyle, Type3.Inline);
    const attributesStyle = response.attributesStyle ? new CSSStyleDeclaration(this, null, response.attributesStyle, Type3.Attributes) : null;
    return new InlineStyleResult(inlineStyle, attributesStyle);
  }
  forcePseudoState(node, pseudoClass, enable) {
    const forcedPseudoClasses = node.marker(PseudoStateMarker) || [];
    const hasPseudoClass = forcedPseudoClasses.includes(pseudoClass);
    if (enable) {
      if (hasPseudoClass) {
        return false;
      }
      forcedPseudoClasses.push(pseudoClass);
      node.setMarker(PseudoStateMarker, forcedPseudoClasses);
    } else {
      if (!hasPseudoClass) {
        return false;
      }
      Platform10.ArrayUtilities.removeElement(forcedPseudoClasses, pseudoClass);
      if (forcedPseudoClasses.length) {
        node.setMarker(PseudoStateMarker, forcedPseudoClasses);
      } else {
        node.setMarker(PseudoStateMarker, null);
      }
    }
    if (node.id === void 0) {
      return false;
    }
    void this.agent.invoke_forcePseudoState({ nodeId: node.id, forcedPseudoClasses });
    this.dispatchEventToListeners("PseudoStateForced", { node, pseudoClass, enable });
    return true;
  }
  pseudoState(node) {
    return node.marker(PseudoStateMarker) || [];
  }
  async setMediaText(styleSheetId, range, newMediaText) {
    Host4.userMetrics.actionTaken(Host4.UserMetrics.Action.StyleRuleEdited);
    try {
      await this.ensureOriginalStyleSheetText(styleSheetId);
      const { media } = await this.agent.invoke_setMediaText({ styleSheetId, range, text: newMediaText });
      if (!media) {
        return false;
      }
      this.#domModel.markUndoableState();
      const edit = new Edit(styleSheetId, range, newMediaText, media);
      this.fireStyleSheetChanged(styleSheetId, edit);
      return true;
    } catch (e) {
      console.error(e);
      return false;
    }
  }
  async setContainerQueryText(styleSheetId, range, newContainerQueryText) {
    Host4.userMetrics.actionTaken(Host4.UserMetrics.Action.StyleRuleEdited);
    try {
      await this.ensureOriginalStyleSheetText(styleSheetId);
      const { containerQuery } = await this.agent.invoke_setContainerQueryText({ styleSheetId, range, text: newContainerQueryText });
      if (!containerQuery) {
        return false;
      }
      this.#domModel.markUndoableState();
      const edit = new Edit(styleSheetId, range, newContainerQueryText, containerQuery);
      this.fireStyleSheetChanged(styleSheetId, edit);
      return true;
    } catch (e) {
      console.error(e);
      return false;
    }
  }
  async setSupportsText(styleSheetId, range, newSupportsText) {
    Host4.userMetrics.actionTaken(Host4.UserMetrics.Action.StyleRuleEdited);
    try {
      await this.ensureOriginalStyleSheetText(styleSheetId);
      const { supports } = await this.agent.invoke_setSupportsText({ styleSheetId, range, text: newSupportsText });
      if (!supports) {
        return false;
      }
      this.#domModel.markUndoableState();
      const edit = new Edit(styleSheetId, range, newSupportsText, supports);
      this.fireStyleSheetChanged(styleSheetId, edit);
      return true;
    } catch (e) {
      console.error(e);
      return false;
    }
  }
  async setScopeText(styleSheetId, range, newScopeText) {
    Host4.userMetrics.actionTaken(Host4.UserMetrics.Action.StyleRuleEdited);
    try {
      await this.ensureOriginalStyleSheetText(styleSheetId);
      const { scope } = await this.agent.invoke_setScopeText({ styleSheetId, range, text: newScopeText });
      if (!scope) {
        return false;
      }
      this.#domModel.markUndoableState();
      const edit = new Edit(styleSheetId, range, newScopeText, scope);
      this.fireStyleSheetChanged(styleSheetId, edit);
      return true;
    } catch (e) {
      console.error(e);
      return false;
    }
  }
  async addRule(styleSheetId, ruleText, ruleLocation) {
    try {
      await this.ensureOriginalStyleSheetText(styleSheetId);
      const { rule } = await this.agent.invoke_addRule({ styleSheetId, ruleText, location: ruleLocation });
      if (!rule) {
        return null;
      }
      this.#domModel.markUndoableState();
      const edit = new Edit(styleSheetId, ruleLocation, ruleText, rule);
      this.fireStyleSheetChanged(styleSheetId, edit);
      return new CSSStyleRule(this, rule);
    } catch (e) {
      console.error(e);
      return null;
    }
  }
  async requestViaInspectorStylesheet(maybeFrameId) {
    const frameId = maybeFrameId || (this.#resourceTreeModel && this.#resourceTreeModel.mainFrame ? this.#resourceTreeModel.mainFrame.id : null);
    const headers = [...this.#styleSheetIdToHeader.values()];
    const styleSheetHeader = headers.find((header) => header.frameId === frameId && header.isViaInspector());
    if (styleSheetHeader) {
      return styleSheetHeader;
    }
    if (!frameId) {
      return null;
    }
    try {
      return await this.createInspectorStylesheet(frameId);
    } catch (e) {
      console.error(e);
      return null;
    }
  }
  async createInspectorStylesheet(frameId) {
    const result = await this.agent.invoke_createStyleSheet({ frameId });
    if (result.getError()) {
      throw new Error(result.getError());
    }
    return this.#styleSheetIdToHeader.get(result.styleSheetId) || null;
  }
  mediaQueryResultChanged() {
    this.#colorScheme = void 0;
    this.dispatchEventToListeners(
      "MediaQueryResultChanged"
      /* MediaQueryResultChanged */
    );
  }
  fontsUpdated(fontFace) {
    if (fontFace) {
      this.#fontFaces.set(fontFace.src, new CSSFontFace(fontFace));
    }
    this.dispatchEventToListeners(
      "FontsUpdated"
      /* FontsUpdated */
    );
  }
  fontFaces() {
    return [...this.#fontFaces.values()];
  }
  fontFaceForSource(src) {
    return this.#fontFaces.get(src);
  }
  styleSheetHeaderForId(id) {
    return this.#styleSheetIdToHeader.get(id) || null;
  }
  styleSheetHeaders() {
    return [...this.#styleSheetIdToHeader.values()];
  }
  fireStyleSheetChanged(styleSheetId, edit) {
    this.dispatchEventToListeners("StyleSheetChanged", { styleSheetId, edit });
  }
  ensureOriginalStyleSheetText(styleSheetId) {
    const header = this.styleSheetHeaderForId(styleSheetId);
    if (!header) {
      return Promise.resolve(null);
    }
    let promise = this.#originalStyleSheetText.get(header);
    if (!promise) {
      promise = this.getStyleSheetText(header.id);
      this.#originalStyleSheetText.set(header, promise);
      this.originalContentRequestedForTest(header);
    }
    return promise;
  }
  originalContentRequestedForTest(_header) {
  }
  originalStyleSheetText(header) {
    return this.ensureOriginalStyleSheetText(header.id);
  }
  getAllStyleSheetHeaders() {
    return this.#styleSheetIdToHeader.values();
  }
  computedStyleUpdated(nodeId) {
    this.dispatchEventToListeners("ComputedStyleUpdated", { nodeId });
  }
  styleSheetAdded(header) {
    console.assert(!this.#styleSheetIdToHeader.get(header.styleSheetId));
    if (header.loadingFailed) {
      header.hasSourceURL = false;
      header.isConstructed = true;
      header.isInline = false;
      header.isMutable = false;
      header.sourceURL = "";
      header.sourceMapURL = void 0;
    }
    const styleSheetHeader = new CSSStyleSheetHeader(this, header);
    this.#styleSheetIdToHeader.set(header.styleSheetId, styleSheetHeader);
    const url = styleSheetHeader.resourceURL();
    let frameIdToStyleSheetIds = this.#styleSheetIdsForURL.get(url);
    if (!frameIdToStyleSheetIds) {
      frameIdToStyleSheetIds = /* @__PURE__ */ new Map();
      this.#styleSheetIdsForURL.set(url, frameIdToStyleSheetIds);
    }
    if (frameIdToStyleSheetIds) {
      let styleSheetIds = frameIdToStyleSheetIds.get(styleSheetHeader.frameId);
      if (!styleSheetIds) {
        styleSheetIds = /* @__PURE__ */ new Set();
        frameIdToStyleSheetIds.set(styleSheetHeader.frameId, styleSheetIds);
      }
      styleSheetIds.add(styleSheetHeader.id);
    }
    this.#sourceMapManager.attachSourceMap(styleSheetHeader, styleSheetHeader.sourceURL, styleSheetHeader.sourceMapURL);
    this.dispatchEventToListeners("StyleSheetAdded", styleSheetHeader);
  }
  styleSheetRemoved(id) {
    const header = this.#styleSheetIdToHeader.get(id);
    console.assert(Boolean(header));
    if (!header) {
      return;
    }
    this.#styleSheetIdToHeader.delete(id);
    const url = header.resourceURL();
    const frameIdToStyleSheetIds = this.#styleSheetIdsForURL.get(url);
    console.assert(
      Boolean(frameIdToStyleSheetIds),
      "No frameId to styleSheetId map is available for given style sheet URL."
    );
    if (frameIdToStyleSheetIds) {
      const stylesheetIds = frameIdToStyleSheetIds.get(header.frameId);
      if (stylesheetIds) {
        stylesheetIds.delete(id);
        if (!stylesheetIds.size) {
          frameIdToStyleSheetIds.delete(header.frameId);
          if (!frameIdToStyleSheetIds.size) {
            this.#styleSheetIdsForURL.delete(url);
          }
        }
      }
    }
    this.#originalStyleSheetText.delete(header);
    this.#sourceMapManager.detachSourceMap(header);
    this.dispatchEventToListeners("StyleSheetRemoved", header);
  }
  getStyleSheetIdsForURL(url) {
    const frameIdToStyleSheetIds = this.#styleSheetIdsForURL.get(url);
    if (!frameIdToStyleSheetIds) {
      return [];
    }
    const result = [];
    for (const styleSheetIds of frameIdToStyleSheetIds.values()) {
      result.push(...styleSheetIds);
    }
    return result;
  }
  async setStyleSheetText(styleSheetId, newText, majorChange) {
    const header = this.#styleSheetIdToHeader.get(styleSheetId);
    if (!header) {
      return "Unknown stylesheet in CSS.setStyleSheetText";
    }
    newText = _CSSModel.trimSourceURL(newText);
    if (header.hasSourceURL) {
      newText += "\n/*# sourceURL=" + header.sourceURL + " */";
    }
    await this.ensureOriginalStyleSheetText(styleSheetId);
    const response = await this.agent.invoke_setStyleSheetText({ styleSheetId: header.id, text: newText });
    const sourceMapURL = response.sourceMapURL;
    this.#sourceMapManager.detachSourceMap(header);
    header.setSourceMapURL(sourceMapURL);
    this.#sourceMapManager.attachSourceMap(header, header.sourceURL, header.sourceMapURL);
    if (sourceMapURL === null) {
      return "Error in CSS.setStyleSheetText";
    }
    this.#domModel.markUndoableState(!majorChange);
    this.fireStyleSheetChanged(styleSheetId);
    return null;
  }
  async getStyleSheetText(styleSheetId) {
    const response = await this.agent.invoke_getStyleSheetText({ styleSheetId });
    if (response.getError()) {
      return null;
    }
    const { text } = response;
    return text && _CSSModel.trimSourceURL(text);
  }
  async onPrimaryPageChanged(event) {
    if (event.data.frame.backForwardCacheDetails.restoredFromCache) {
      await this.suspendModel();
      await this.resumeModel();
    } else if (event.data.type !== PrimaryPageChangeType.ACTIVATION) {
      this.resetStyleSheets();
      this.resetFontFaces();
    }
  }
  resetStyleSheets() {
    const headers = [...this.#styleSheetIdToHeader.values()];
    this.#styleSheetIdsForURL.clear();
    this.#styleSheetIdToHeader.clear();
    for (const header of headers) {
      this.#sourceMapManager.detachSourceMap(header);
      this.dispatchEventToListeners("StyleSheetRemoved", header);
    }
  }
  resetFontFaces() {
    this.#fontFaces.clear();
  }
  async suspendModel() {
    this.#isEnabled = false;
    await this.agent.invoke_disable();
    this.resetStyleSheets();
    this.resetFontFaces();
  }
  async resumeModel() {
    return this.enable();
  }
  setEffectivePropertyValueForNode(nodeId, propertyName, value) {
    void this.agent.invoke_setEffectivePropertyValueForNode({ nodeId, propertyName, value });
  }
  cachedMatchedCascadeForNode(node) {
    if (this.#cachedMatchedCascadeNode !== node) {
      this.discardCachedMatchedCascade();
    }
    this.#cachedMatchedCascadeNode = node;
    if (!this.#cachedMatchedCascadePromise) {
      if (node.id) {
        this.#cachedMatchedCascadePromise = this.getMatchedStyles(node.id);
      } else {
        return Promise.resolve(null);
      }
    }
    return this.#cachedMatchedCascadePromise;
  }
  discardCachedMatchedCascade() {
    this.#cachedMatchedCascadeNode = null;
    this.#cachedMatchedCascadePromise = null;
  }
  createCSSPropertyTracker(propertiesToTrack) {
    const cssPropertyTracker = new CSSPropertyTracker(this, propertiesToTrack);
    return cssPropertyTracker;
  }
  enableCSSPropertyTracker(cssPropertyTracker) {
    const propertiesToTrack = cssPropertyTracker.getTrackedProperties();
    if (propertiesToTrack.length === 0) {
      return;
    }
    void this.agent.invoke_trackComputedStyleUpdates({ propertiesToTrack });
    this.#isCSSPropertyTrackingEnabled = true;
    this.#cssPropertyTracker = cssPropertyTracker;
    void this.pollComputedStyleUpdates();
  }
  // Since we only support one tracker at a time, this call effectively disables
  // style tracking.
  disableCSSPropertyTracker() {
    this.#isCSSPropertyTrackingEnabled = false;
    this.#cssPropertyTracker = null;
    void this.agent.invoke_trackComputedStyleUpdates({ propertiesToTrack: [] });
  }
  async pollComputedStyleUpdates() {
    if (this.#isTrackingRequestPending) {
      return;
    }
    if (this.#isCSSPropertyTrackingEnabled) {
      this.#isTrackingRequestPending = true;
      const result = await this.agent.invoke_takeComputedStyleUpdates();
      this.#isTrackingRequestPending = false;
      if (result.getError() || !result.nodeIds || !this.#isCSSPropertyTrackingEnabled) {
        return;
      }
      if (this.#cssPropertyTracker) {
        this.#cssPropertyTracker.dispatchEventToListeners(
          "TrackedCSSPropertiesUpdated",
          result.nodeIds.map((nodeId) => this.#domModel.nodeForId(nodeId))
        );
      }
    }
    if (this.#isCSSPropertyTrackingEnabled) {
      void this.#stylePollingThrottler.schedule(this.pollComputedStyleUpdates.bind(this));
    }
  }
  dispose() {
    this.disableCSSPropertyTracker();
    super.dispose();
    this.dispatchEventToListeners("ModelDisposed", this);
  }
  getAgent() {
    return this.agent;
  }
};
var Events8 = /* @__PURE__ */ ((Events210) => {
  Events210["FontsUpdated"] = "FontsUpdated";
  Events210["MediaQueryResultChanged"] = "MediaQueryResultChanged";
  Events210["ModelWasEnabled"] = "ModelWasEnabled";
  Events210["ModelDisposed"] = "ModelDisposed";
  Events210["PseudoStateForced"] = "PseudoStateForced";
  Events210["StyleSheetAdded"] = "StyleSheetAdded";
  Events210["StyleSheetChanged"] = "StyleSheetChanged";
  Events210["StyleSheetRemoved"] = "StyleSheetRemoved";
  Events210["ComputedStyleUpdated"] = "ComputedStyleUpdated";
  return Events210;
})(Events8 || {});
var PseudoStateMarker = "pseudo-state-marker";
var Edit = class {
  styleSheetId;
  oldRange;
  newRange;
  newText;
  payload;
  constructor(styleSheetId, oldRange, newText, payload) {
    this.styleSheetId = styleSheetId;
    this.oldRange = oldRange;
    this.newRange = TextUtils15.TextRange.TextRange.fromEdit(oldRange, newText);
    this.newText = newText;
    this.payload = payload;
  }
};
var CSSLocation = class {
  #cssModelInternal;
  styleSheetId;
  url;
  lineNumber;
  columnNumber;
  constructor(header, lineNumber, columnNumber) {
    this.#cssModelInternal = header.cssModel();
    this.styleSheetId = header.id;
    this.url = header.resourceURL();
    this.lineNumber = lineNumber;
    this.columnNumber = columnNumber || 0;
  }
  cssModel() {
    return this.#cssModelInternal;
  }
  header() {
    return this.#cssModelInternal.styleSheetHeaderForId(this.styleSheetId);
  }
};
var CSSDispatcher = class {
  #cssModel;
  constructor(cssModel) {
    this.#cssModel = cssModel;
  }
  mediaQueryResultChanged() {
    this.#cssModel.mediaQueryResultChanged();
  }
  fontsUpdated({ font }) {
    this.#cssModel.fontsUpdated(font);
  }
  styleSheetChanged({ styleSheetId }) {
    this.#cssModel.fireStyleSheetChanged(styleSheetId);
  }
  styleSheetAdded({ header }) {
    this.#cssModel.styleSheetAdded(header);
  }
  styleSheetRemoved({ styleSheetId }) {
    this.#cssModel.styleSheetRemoved(styleSheetId);
  }
  computedStyleUpdated({ nodeId }) {
    this.#cssModel.computedStyleUpdated(nodeId);
  }
};
var ComputedStyleLoader = class {
  #cssModel;
  #nodeIdToPromise;
  constructor(cssModel) {
    this.#cssModel = cssModel;
    this.#nodeIdToPromise = /* @__PURE__ */ new Map();
  }
  computedStylePromise(nodeId) {
    let promise = this.#nodeIdToPromise.get(nodeId);
    if (promise) {
      return promise;
    }
    promise = this.#cssModel.getAgent().invoke_getComputedStyleForNode({ nodeId }).then(({ computedStyle }) => {
      this.#nodeIdToPromise.delete(nodeId);
      if (!computedStyle || !computedStyle.length) {
        return null;
      }
      const result = /* @__PURE__ */ new Map();
      for (const property of computedStyle) {
        result.set(property.name, property.value);
      }
      return result;
    });
    this.#nodeIdToPromise.set(nodeId, promise);
    return promise;
  }
};
var InlineStyleResult = class {
  inlineStyle;
  attributesStyle;
  constructor(inlineStyle, attributesStyle) {
    this.inlineStyle = inlineStyle;
    this.attributesStyle = attributesStyle;
  }
};
var CSSPropertyTracker = class extends Common13.ObjectWrapper.ObjectWrapper {
  #cssModel;
  #properties;
  constructor(cssModel, propertiesToTrack) {
    super();
    this.#cssModel = cssModel;
    this.#properties = propertiesToTrack;
  }
  start() {
    this.#cssModel.enableCSSPropertyTracker(this);
  }
  stop() {
    this.#cssModel.disableCSSPropertyTracker();
  }
  getTrackedProperties() {
    return this.#properties;
  }
};
var StylePollingInterval = 1e3;
var CSSPropertyTrackerEvents = /* @__PURE__ */ ((CSSPropertyTrackerEvents2) => {
  CSSPropertyTrackerEvents2["TRACKED_CSS_PROPERTIES_UPDATED"] = "TrackedCSSPropertiesUpdated";
  return CSSPropertyTrackerEvents2;
})(CSSPropertyTrackerEvents || {});
SDKModel.register(CSSModel, { capabilities: Capability.DOM, autostart: true });

// gen/front_end/core/sdk/OverlayModel.js
var OverlayModel_exports = {};
__export(OverlayModel_exports, {
  EmulatedOSType: () => EmulatedOSType,
  Events: () => Events13,
  OverlayModel: () => OverlayModel,
  SourceOrderHighlighter: () => SourceOrderHighlighter,
  WindowControls: () => WindowControls
});
import * as Common19 from "./../common/common.js";
import * as i18n13 from "./../i18n/i18n.js";
import * as Root5 from "./../root/root.js";

// gen/front_end/core/sdk/DebuggerModel.js
var DebuggerModel_exports = {};
__export(DebuggerModel_exports, {
  BreakLocation: () => BreakLocation,
  BreakpointType: () => BreakpointType,
  COND_BREAKPOINT_SOURCE_URL: () => COND_BREAKPOINT_SOURCE_URL,
  CallFrame: () => CallFrame,
  DebuggerModel: () => DebuggerModel,
  DebuggerPausedDetails: () => DebuggerPausedDetails,
  Events: () => Events11,
  LOGPOINT_SOURCE_URL: () => LOGPOINT_SOURCE_URL,
  Location: () => Location,
  PauseOnExceptionsState: () => PauseOnExceptionsState,
  Scope: () => Scope,
  StepMode: () => StepMode,
  WASM_SYMBOLS_PRIORITY: () => WASM_SYMBOLS_PRIORITY,
  sortAndMergeRanges: () => sortAndMergeRanges
});
import * as Common16 from "./../common/common.js";
import * as Host6 from "./../host/host.js";
import * as i18n11 from "./../i18n/i18n.js";
import * as Platform12 from "./../platform/platform.js";
import * as Root4 from "./../root/root.js";

// gen/front_end/core/sdk/RuntimeModel.js
var RuntimeModel_exports = {};
__export(RuntimeModel_exports, {
  Events: () => Events10,
  ExecutionContext: () => ExecutionContext,
  RuntimeModel: () => RuntimeModel
});
import * as Common14 from "./../common/common.js";
import * as Host5 from "./../host/host.js";

// gen/front_end/core/sdk/HeapProfilerModel.js
var HeapProfilerModel_exports = {};
__export(HeapProfilerModel_exports, {
  Events: () => Events9,
  HeapProfilerModel: () => HeapProfilerModel
});
var HeapProfilerModel = class extends SDKModel {
  #enabled;
  #heapProfilerAgent;
  #runtimeModelInternal;
  #samplingProfilerDepth;
  constructor(target) {
    super(target);
    target.registerHeapProfilerDispatcher(new HeapProfilerDispatcher(this));
    this.#enabled = false;
    this.#heapProfilerAgent = target.heapProfilerAgent();
    this.#runtimeModelInternal = target.model(RuntimeModel);
    this.#samplingProfilerDepth = 0;
  }
  debuggerModel() {
    return this.#runtimeModelInternal.debuggerModel();
  }
  runtimeModel() {
    return this.#runtimeModelInternal;
  }
  async enable() {
    if (this.#enabled) {
      return;
    }
    this.#enabled = true;
    await this.#heapProfilerAgent.invoke_enable();
  }
  async startSampling(samplingRateInBytes) {
    if (this.#samplingProfilerDepth++) {
      return false;
    }
    const defaultSamplingIntervalInBytes = 16384;
    const response = await this.#heapProfilerAgent.invoke_startSampling(
      { samplingInterval: samplingRateInBytes || defaultSamplingIntervalInBytes }
    );
    return Boolean(response.getError());
  }
  async stopSampling() {
    if (!this.#samplingProfilerDepth) {
      throw new Error("Sampling profiler is not running.");
    }
    if (--this.#samplingProfilerDepth) {
      return this.getSamplingProfile();
    }
    const response = await this.#heapProfilerAgent.invoke_stopSampling();
    if (response.getError()) {
      return null;
    }
    return response.profile;
  }
  async getSamplingProfile() {
    const response = await this.#heapProfilerAgent.invoke_getSamplingProfile();
    if (response.getError()) {
      return null;
    }
    return response.profile;
  }
  async collectGarbage() {
    const response = await this.#heapProfilerAgent.invoke_collectGarbage();
    return Boolean(response.getError());
  }
  async snapshotObjectIdForObjectId(objectId) {
    const response = await this.#heapProfilerAgent.invoke_getHeapObjectId({ objectId });
    if (response.getError()) {
      return null;
    }
    return response.heapSnapshotObjectId;
  }
  async objectForSnapshotObjectId(snapshotObjectId, objectGroupName) {
    const result = await this.#heapProfilerAgent.invoke_getObjectByHeapObjectId(
      { objectId: snapshotObjectId, objectGroup: objectGroupName }
    );
    if (result.getError()) {
      return null;
    }
    return this.#runtimeModelInternal.createRemoteObject(result.result);
  }
  async addInspectedHeapObject(snapshotObjectId) {
    const response = await this.#heapProfilerAgent.invoke_addInspectedHeapObject({ heapObjectId: snapshotObjectId });
    return Boolean(response.getError());
  }
  async takeHeapSnapshot(heapSnapshotOptions) {
    await this.#heapProfilerAgent.invoke_takeHeapSnapshot(heapSnapshotOptions);
  }
  async startTrackingHeapObjects(recordAllocationStacks) {
    const response = await this.#heapProfilerAgent.invoke_startTrackingHeapObjects({ trackAllocations: recordAllocationStacks });
    return Boolean(response.getError());
  }
  async stopTrackingHeapObjects(reportProgress) {
    const response = await this.#heapProfilerAgent.invoke_stopTrackingHeapObjects({ reportProgress });
    return Boolean(response.getError());
  }
  heapStatsUpdate(samples) {
    this.dispatchEventToListeners("HeapStatsUpdate", samples);
  }
  lastSeenObjectId(lastSeenObjectId, timestamp) {
    this.dispatchEventToListeners("LastSeenObjectId", { lastSeenObjectId, timestamp });
  }
  addHeapSnapshotChunk(chunk) {
    this.dispatchEventToListeners("AddHeapSnapshotChunk", chunk);
  }
  reportHeapSnapshotProgress(done, total, finished) {
    this.dispatchEventToListeners("ReportHeapSnapshotProgress", { done, total, finished });
  }
  resetProfiles() {
    this.dispatchEventToListeners("ResetProfiles", this);
  }
};
var Events9 = /* @__PURE__ */ ((Events210) => {
  Events210["HEAP_STATS_UPDATED"] = "HeapStatsUpdate";
  Events210["LAST_SEEN_OBJECT_ID"] = "LastSeenObjectId";
  Events210["ADD_HEAP_SNAPSHOT_CHUNK"] = "AddHeapSnapshotChunk";
  Events210["REPORT_HEAP_SNAPSHOT_PROGRESS"] = "ReportHeapSnapshotProgress";
  Events210["RESET_PROFILES"] = "ResetProfiles";
  return Events210;
})(Events9 || {});
var HeapProfilerDispatcher = class {
  #heapProfilerModel;
  constructor(model) {
    this.#heapProfilerModel = model;
  }
  heapStatsUpdate({ statsUpdate }) {
    this.#heapProfilerModel.heapStatsUpdate(statsUpdate);
  }
  lastSeenObjectId({ lastSeenObjectId, timestamp }) {
    this.#heapProfilerModel.lastSeenObjectId(lastSeenObjectId, timestamp);
  }
  addHeapSnapshotChunk({ chunk }) {
    this.#heapProfilerModel.addHeapSnapshotChunk(chunk);
  }
  reportHeapSnapshotProgress({ done, total, finished }) {
    this.#heapProfilerModel.reportHeapSnapshotProgress(done, total, finished);
  }
  resetProfiles() {
    this.#heapProfilerModel.resetProfiles();
  }
};
SDKModel.register(HeapProfilerModel, { capabilities: Capability.JS, autostart: false });

// gen/front_end/core/sdk/RuntimeModel.js
var RuntimeModel = class extends SDKModel {
  agent;
  #executionContextById;
  #executionContextComparatorInternal;
  constructor(target) {
    super(target);
    this.agent = target.runtimeAgent();
    this.target().registerRuntimeDispatcher(new RuntimeDispatcher(this));
    void this.agent.invoke_enable();
    this.#executionContextById = /* @__PURE__ */ new Map();
    this.#executionContextComparatorInternal = ExecutionContext.comparator;
    if (Common14.Settings.Settings.instance().moduleSetting("custom-formatters").get()) {
      void this.agent.invoke_setCustomObjectFormatterEnabled({ enabled: true });
    }
    Common14.Settings.Settings.instance().moduleSetting("custom-formatters").addChangeListener(this.customFormattersStateChanged.bind(this));
  }
  static isSideEffectFailure(response) {
    const exceptionDetails = "exceptionDetails" in response && response.exceptionDetails;
    return Boolean(
      exceptionDetails && exceptionDetails.exception && exceptionDetails.exception.description && exceptionDetails.exception.description.startsWith("EvalError: Possible side-effect in debug-evaluate")
    );
  }
  debuggerModel() {
    return this.target().model(DebuggerModel);
  }
  heapProfilerModel() {
    return this.target().model(HeapProfilerModel);
  }
  executionContexts() {
    return [...this.#executionContextById.values()].sort(this.executionContextComparator());
  }
  setExecutionContextComparator(comparator) {
    this.#executionContextComparatorInternal = comparator;
  }
  /** comparator
   */
  executionContextComparator() {
    return this.#executionContextComparatorInternal;
  }
  defaultExecutionContext() {
    for (const context of this.executionContexts()) {
      if (context.isDefault) {
        return context;
      }
    }
    return null;
  }
  executionContext(id) {
    return this.#executionContextById.get(id) || null;
  }
  executionContextCreated(context) {
    const data = context.auxData || { isDefault: true };
    const executionContext = new ExecutionContext(
      this,
      context.id,
      context.uniqueId,
      context.name,
      context.origin,
      data["isDefault"],
      data["frameId"]
    );
    this.#executionContextById.set(executionContext.id, executionContext);
    this.dispatchEventToListeners("ExecutionContextCreated", executionContext);
  }
  executionContextDestroyed(executionContextId) {
    const executionContext = this.#executionContextById.get(executionContextId);
    if (!executionContext) {
      return;
    }
    this.debuggerModel().executionContextDestroyed(executionContext);
    this.#executionContextById.delete(executionContextId);
    this.dispatchEventToListeners("ExecutionContextDestroyed", executionContext);
  }
  fireExecutionContextOrderChanged() {
    this.dispatchEventToListeners("ExecutionContextOrderChanged", this);
  }
  executionContextsCleared() {
    this.debuggerModel().globalObjectCleared();
    const contexts = this.executionContexts();
    this.#executionContextById.clear();
    for (let i = 0; i < contexts.length; ++i) {
      this.dispatchEventToListeners("ExecutionContextDestroyed", contexts[i]);
    }
  }
  createRemoteObject(payload) {
    console.assert(typeof payload === "object", "Remote object payload should only be an object");
    return new RemoteObjectImpl(
      this,
      payload.objectId,
      payload.type,
      payload.subtype,
      payload.value,
      payload.unserializableValue,
      payload.description,
      payload.preview,
      payload.customPreview,
      payload.className
    );
  }
  createScopeRemoteObject(payload, scopeRef) {
    return new ScopeRemoteObject(
      this,
      payload.objectId,
      scopeRef,
      payload.type,
      payload.subtype,
      payload.value,
      payload.unserializableValue,
      payload.description,
      payload.preview
    );
  }
  createRemoteObjectFromPrimitiveValue(value) {
    const type = typeof value;
    let unserializableValue = void 0;
    const unserializableDescription = RemoteObject.unserializableDescription(value);
    if (unserializableDescription !== null) {
      unserializableValue = unserializableDescription;
    }
    if (typeof unserializableValue !== "undefined") {
      value = void 0;
    }
    return new RemoteObjectImpl(this, void 0, type, void 0, value, unserializableValue);
  }
  createRemotePropertyFromPrimitiveValue(name, value) {
    return new RemoteObjectProperty(name, this.createRemoteObjectFromPrimitiveValue(value));
  }
  discardConsoleEntries() {
    void this.agent.invoke_discardConsoleEntries();
  }
  releaseObjectGroup(objectGroup) {
    void this.agent.invoke_releaseObjectGroup({ objectGroup });
  }
  releaseEvaluationResult(result) {
    if ("object" in result && result.object) {
      result.object.release();
    }
    if ("exceptionDetails" in result && result.exceptionDetails && result.exceptionDetails.exception) {
      const exception = result.exceptionDetails.exception;
      const exceptionObject = this.createRemoteObject({ type: exception.type, objectId: exception.objectId });
      exceptionObject.release();
    }
  }
  runIfWaitingForDebugger() {
    void this.agent.invoke_runIfWaitingForDebugger();
  }
  customFormattersStateChanged({ data: enabled }) {
    void this.agent.invoke_setCustomObjectFormatterEnabled({ enabled });
  }
  async compileScript(expression, sourceURL, persistScript, executionContextId) {
    const response = await this.agent.invoke_compileScript({
      expression,
      sourceURL,
      persistScript,
      executionContextId
    });
    if (response.getError()) {
      console.error(response.getError());
      return null;
    }
    return { scriptId: response.scriptId, exceptionDetails: response.exceptionDetails };
  }
  async runScript(scriptId, executionContextId, objectGroup, silent, includeCommandLineAPI, returnByValue, generatePreview, awaitPromise) {
    const response = await this.agent.invoke_runScript({
      scriptId,
      executionContextId,
      objectGroup,
      silent,
      includeCommandLineAPI,
      returnByValue,
      generatePreview,
      awaitPromise
    });
    const error = response.getError();
    if (error) {
      console.error(error);
      return { error };
    }
    return { object: this.createRemoteObject(response.result), exceptionDetails: response.exceptionDetails };
  }
  async queryObjects(prototype) {
    if (!prototype.objectId) {
      return { error: "Prototype should be an Object." };
    }
    const response = await this.agent.invoke_queryObjects({ prototypeObjectId: prototype.objectId, objectGroup: "console" });
    const error = response.getError();
    if (error) {
      console.error(error);
      return { error };
    }
    return { objects: this.createRemoteObject(response.objects) };
  }
  async isolateId() {
    const response = await this.agent.invoke_getIsolateId();
    if (response.getError() || !response.id) {
      return this.target().id();
    }
    return response.id;
  }
  async heapUsage() {
    const result = await this.agent.invoke_getHeapUsage();
    return result.getError() ? null : result;
  }
  inspectRequested(payload, hints, executionContextId) {
    const object = this.createRemoteObject(payload);
    if (hints !== null && typeof hints === "object") {
      if ("copyToClipboard" in hints && Boolean(hints.copyToClipboard)) {
        this.copyRequested(object);
        return;
      }
      if ("queryObjects" in hints && hints.queryObjects) {
        void this.queryObjectsRequested(object, executionContextId);
        return;
      }
    }
    if (object.isNode()) {
      void Common14.Revealer.reveal(object).then(object.release.bind(object));
      return;
    }
    if (object.type === "function") {
      void RemoteFunction.objectAsFunction(object).targetFunctionDetails().then(didGetDetails);
      return;
    }
    function didGetDetails(response) {
      object.release();
      if (!response || !response.location) {
        return;
      }
      void Common14.Revealer.reveal(response.location);
    }
    object.release();
  }
  async addBinding(event) {
    return await this.agent.invoke_addBinding(event);
  }
  async removeBinding(request) {
    return await this.agent.invoke_removeBinding(request);
  }
  bindingCalled(event) {
    this.dispatchEventToListeners("BindingCalled", event);
  }
  copyRequested(object) {
    if (!object.objectId) {
      Host5.InspectorFrontendHost.InspectorFrontendHostInstance.copyText(
        object.unserializableValue() || object.value
      );
      return;
    }
    const indent = Common14.Settings.Settings.instance().moduleSetting("text-editor-indent").get();
    void object.callFunctionJSON(toStringForClipboard, [{
      value: {
        subtype: object.subtype,
        indent
      }
    }]).then(Host5.InspectorFrontendHost.InspectorFrontendHostInstance.copyText.bind(
      Host5.InspectorFrontendHost.InspectorFrontendHostInstance
    ));
    function toStringForClipboard(data) {
      const subtype = data.subtype;
      const indent2 = data.indent;
      if (subtype === "node") {
        return this instanceof Element ? this.outerHTML : void 0;
      }
      if (subtype && typeof this === "undefined") {
        return String(subtype);
      }
      try {
        return JSON.stringify(this, null, indent2);
      } catch (error) {
        return String(this);
      }
    }
  }
  async queryObjectsRequested(object, executionContextId) {
    const result = await this.queryObjects(object);
    object.release();
    if ("error" in result) {
      Common14.Console.Console.instance().error(result.error);
      return;
    }
    this.dispatchEventToListeners("QueryObjectRequested", { objects: result.objects, executionContextId });
  }
  static simpleTextFromException(exceptionDetails) {
    let text = exceptionDetails.text;
    if (exceptionDetails.exception && exceptionDetails.exception.description) {
      let description = exceptionDetails.exception.description;
      if (description.indexOf("\n") !== -1) {
        description = description.substring(0, description.indexOf("\n"));
      }
      text += " " + description;
    }
    return text;
  }
  exceptionThrown(timestamp, exceptionDetails) {
    const exceptionWithTimestamp = { timestamp, details: exceptionDetails };
    this.dispatchEventToListeners("ExceptionThrown", exceptionWithTimestamp);
  }
  exceptionRevoked(exceptionId) {
    this.dispatchEventToListeners("ExceptionRevoked", exceptionId);
  }
  consoleAPICalled(type, args, executionContextId, timestamp, stackTrace, context) {
    const consoleAPICall = {
      type,
      args,
      executionContextId,
      timestamp,
      stackTrace,
      context
    };
    this.dispatchEventToListeners("ConsoleAPICalled", consoleAPICall);
  }
  executionContextIdForScriptId(scriptId) {
    const script = this.debuggerModel().scriptForId(scriptId);
    return script ? script.executionContextId : 0;
  }
  executionContextForStackTrace(stackTrace) {
    let currentStackTrace = stackTrace;
    while (currentStackTrace && !currentStackTrace.callFrames.length) {
      currentStackTrace = currentStackTrace.parent || null;
    }
    if (!currentStackTrace || !currentStackTrace.callFrames.length) {
      return 0;
    }
    return this.executionContextIdForScriptId(currentStackTrace.callFrames[0].scriptId);
  }
  terminateExecution() {
    return this.agent.invoke_terminateExecution();
  }
  async getExceptionDetails(errorObjectId) {
    const response = await this.agent.invoke_getExceptionDetails({ errorObjectId });
    if (response.getError()) {
      return void 0;
    }
    return response.exceptionDetails;
  }
};
var Events10 = /* @__PURE__ */ ((Events210) => {
  Events210["BindingCalled"] = "BindingCalled";
  Events210["ExecutionContextCreated"] = "ExecutionContextCreated";
  Events210["ExecutionContextDestroyed"] = "ExecutionContextDestroyed";
  Events210["ExecutionContextChanged"] = "ExecutionContextChanged";
  Events210["ExecutionContextOrderChanged"] = "ExecutionContextOrderChanged";
  Events210["ExceptionThrown"] = "ExceptionThrown";
  Events210["ExceptionRevoked"] = "ExceptionRevoked";
  Events210["ConsoleAPICalled"] = "ConsoleAPICalled";
  Events210["QueryObjectRequested"] = "QueryObjectRequested";
  return Events210;
})(Events10 || {});
var RuntimeDispatcher = class {
  #runtimeModel;
  constructor(runtimeModel) {
    this.#runtimeModel = runtimeModel;
  }
  executionContextCreated({ context }) {
    this.#runtimeModel.executionContextCreated(context);
  }
  executionContextDestroyed({ executionContextId }) {
    this.#runtimeModel.executionContextDestroyed(executionContextId);
  }
  executionContextsCleared() {
    this.#runtimeModel.executionContextsCleared();
  }
  exceptionThrown({ timestamp, exceptionDetails }) {
    this.#runtimeModel.exceptionThrown(timestamp, exceptionDetails);
  }
  exceptionRevoked({ exceptionId }) {
    this.#runtimeModel.exceptionRevoked(exceptionId);
  }
  consoleAPICalled({ type, args, executionContextId, timestamp, stackTrace, context }) {
    this.#runtimeModel.consoleAPICalled(type, args, executionContextId, timestamp, stackTrace, context);
  }
  inspectRequested({ object, hints, executionContextId }) {
    this.#runtimeModel.inspectRequested(object, hints, executionContextId);
  }
  bindingCalled(event) {
    this.#runtimeModel.bindingCalled(event);
  }
};
var ExecutionContext = class {
  id;
  uniqueId;
  name;
  #labelInternal;
  origin;
  isDefault;
  runtimeModel;
  debuggerModel;
  frameId;
  constructor(runtimeModel, id, uniqueId, name, origin, isDefault, frameId) {
    this.id = id;
    this.uniqueId = uniqueId;
    this.name = name;
    this.#labelInternal = null;
    this.origin = origin;
    this.isDefault = isDefault;
    this.runtimeModel = runtimeModel;
    this.debuggerModel = runtimeModel.debuggerModel();
    this.frameId = frameId;
    this.setLabelInternal("");
  }
  target() {
    return this.runtimeModel.target();
  }
  static comparator(a, b) {
    function targetWeight(target) {
      if (target.parentTarget()?.type() !== Type2.FRAME) {
        return 5;
      }
      if (target.type() === Type2.FRAME) {
        return 4;
      }
      if (target.type() === Type2.ServiceWorker) {
        return 3;
      }
      if (target.type() === Type2.Worker || target.type() === Type2.SHARED_WORKER) {
        return 2;
      }
      return 1;
    }
    function targetPath(target) {
      let currentTarget = target;
      const parents = [];
      while (currentTarget) {
        parents.push(currentTarget);
        currentTarget = currentTarget.parentTarget();
      }
      return parents.reverse();
    }
    const tagetsA = targetPath(a.target());
    const targetsB = targetPath(b.target());
    let targetA;
    let targetB;
    for (let i = 0; ; i++) {
      if (!tagetsA[i] || !targetsB[i] || tagetsA[i] !== targetsB[i]) {
        targetA = tagetsA[i];
        targetB = targetsB[i];
        break;
      }
    }
    if (!targetA && targetB) {
      return -1;
    }
    if (!targetB && targetA) {
      return 1;
    }
    if (targetA && targetB) {
      const weightDiff = targetWeight(targetA) - targetWeight(targetB);
      if (weightDiff) {
        return -weightDiff;
      }
      return targetA.id().localeCompare(targetB.id());
    }
    if (a.isDefault) {
      return -1;
    }
    if (b.isDefault) {
      return 1;
    }
    return a.name.localeCompare(b.name);
  }
  async evaluate(options, userGesture, awaitPromise) {
    if (this.debuggerModel.selectedCallFrame()) {
      return this.debuggerModel.evaluateOnSelectedCallFrame(options);
    }
    return this.evaluateGlobal(options, userGesture, awaitPromise);
  }
  globalObject(objectGroup, generatePreview) {
    const evaluationOptions = {
      expression: "this",
      objectGroup,
      includeCommandLineAPI: false,
      silent: true,
      returnByValue: false,
      generatePreview
    };
    return this.evaluateGlobal(evaluationOptions, false, false);
  }
  async callFunctionOn(options) {
    const response = await this.runtimeModel.agent.invoke_callFunctionOn({
      functionDeclaration: options.functionDeclaration,
      returnByValue: options.returnByValue,
      userGesture: options.userGesture,
      awaitPromise: options.awaitPromise,
      throwOnSideEffect: options.throwOnSideEffect,
      arguments: options.arguments,
      // Old back-ends don't know about uniqueContextId (and also don't generate
      // one), so fall back to contextId in that case (https://crbug.com/1192621).
      ...this.uniqueId ? { uniqueContextId: this.uniqueId } : { contextId: this.id }
    });
    const error = response.getError();
    if (error) {
      return { error };
    }
    return { object: this.runtimeModel.createRemoteObject(response.result), exceptionDetails: response.exceptionDetails };
  }
  async evaluateGlobal(options, userGesture, awaitPromise) {
    if (!options.expression) {
      options.expression = "this";
    }
    const response = await this.runtimeModel.agent.invoke_evaluate({
      expression: options.expression,
      objectGroup: options.objectGroup,
      includeCommandLineAPI: options.includeCommandLineAPI,
      silent: options.silent,
      returnByValue: options.returnByValue,
      generatePreview: options.generatePreview,
      userGesture,
      awaitPromise,
      throwOnSideEffect: options.throwOnSideEffect,
      timeout: options.timeout,
      disableBreaks: options.disableBreaks,
      replMode: options.replMode,
      allowUnsafeEvalBlockedByCSP: options.allowUnsafeEvalBlockedByCSP,
      // Old back-ends don't know about uniqueContextId (and also don't generate
      // one), so fall back to contextId in that case (https://crbug.com/1192621).
      ...this.uniqueId ? { uniqueContextId: this.uniqueId } : { contextId: this.id }
    });
    const error = response.getError();
    if (error) {
      console.error(error);
      return { error };
    }
    return { object: this.runtimeModel.createRemoteObject(response.result), exceptionDetails: response.exceptionDetails };
  }
  async globalLexicalScopeNames() {
    const response = await this.runtimeModel.agent.invoke_globalLexicalScopeNames({ executionContextId: this.id });
    return response.getError() ? [] : response.names;
  }
  label() {
    return this.#labelInternal;
  }
  setLabel(label) {
    this.setLabelInternal(label);
    this.runtimeModel.dispatchEventToListeners("ExecutionContextChanged", this);
  }
  setLabelInternal(label) {
    if (label) {
      this.#labelInternal = label;
      return;
    }
    if (this.name) {
      this.#labelInternal = this.name;
      return;
    }
    const parsedUrl = Common14.ParsedURL.ParsedURL.fromString(this.origin);
    this.#labelInternal = parsedUrl ? parsedUrl.lastPathComponentWithFragment() : "";
  }
};
SDKModel.register(RuntimeModel, { capabilities: Capability.JS, autostart: true });

// gen/front_end/core/sdk/Script.js
var Script_exports = {};
__export(Script_exports, {
  Script: () => Script,
  disassembleWasm: () => disassembleWasm,
  sourceURLRegex: () => sourceURLRegex
});
import * as TextUtils16 from "./../../models/text_utils/text_utils.js";
import * as Common15 from "./../common/common.js";
import * as i18n9 from "./../i18n/i18n.js";
var UIStrings5 = {
  /**
   *@description Error message for when a script can't be loaded which had been previously
   */
  scriptRemovedOrDeleted: "Script removed or deleted.",
  /**
   *@description Error message when failing to load a script source text
   */
  unableToFetchScriptSource: "Unable to fetch script source."
};
var str_5 = i18n9.i18n.registerUIStrings("core/sdk/Script.ts", UIStrings5);
var i18nString5 = i18n9.i18n.getLocalizedString.bind(void 0, str_5);
var scriptCacheInstance = null;
var Script = class _Script {
  debuggerModel;
  scriptId;
  sourceURL;
  lineOffset;
  columnOffset;
  endLine;
  endColumn;
  executionContextId;
  hash;
  #isContentScriptInternal;
  #isLiveEditInternal;
  sourceMapURL;
  debugSymbols;
  hasSourceURL;
  contentLength;
  originStackTrace;
  #codeOffsetInternal;
  #language;
  #contentPromise;
  #embedderNameInternal;
  isModule;
  constructor(debuggerModel, scriptId, sourceURL, startLine, startColumn, endLine, endColumn, executionContextId, hash, isContentScript, isLiveEdit, sourceMapURL, hasSourceURL, length, isModule, originStackTrace, codeOffset, scriptLanguage, debugSymbols, embedderName) {
    this.debuggerModel = debuggerModel;
    this.scriptId = scriptId;
    this.sourceURL = sourceURL;
    this.lineOffset = startLine;
    this.columnOffset = startColumn;
    this.endLine = endLine;
    this.endColumn = endColumn;
    this.isModule = isModule;
    this.executionContextId = executionContextId;
    this.hash = hash;
    this.#isContentScriptInternal = isContentScript;
    this.#isLiveEditInternal = isLiveEdit;
    this.sourceMapURL = sourceMapURL;
    this.debugSymbols = debugSymbols;
    this.hasSourceURL = hasSourceURL;
    this.contentLength = length;
    this.originStackTrace = originStackTrace;
    this.#codeOffsetInternal = codeOffset;
    this.#language = scriptLanguage;
    this.#contentPromise = null;
    this.#embedderNameInternal = embedderName;
  }
  embedderName() {
    return this.#embedderNameInternal;
  }
  target() {
    return this.debuggerModel.target();
  }
  static trimSourceURLComment(source) {
    let sourceURLIndex = source.lastIndexOf("//# sourceURL=");
    if (sourceURLIndex === -1) {
      sourceURLIndex = source.lastIndexOf("//@ sourceURL=");
      if (sourceURLIndex === -1) {
        return source;
      }
    }
    const sourceURLLineIndex = source.lastIndexOf("\n", sourceURLIndex);
    if (sourceURLLineIndex === -1) {
      return source;
    }
    const sourceURLLine = source.substr(sourceURLLineIndex + 1);
    if (!sourceURLLine.match(sourceURLRegex)) {
      return source;
    }
    return source.substr(0, sourceURLLineIndex);
  }
  isContentScript() {
    return this.#isContentScriptInternal;
  }
  codeOffset() {
    return this.#codeOffsetInternal;
  }
  isJavaScript() {
    return this.#language === Debugger.ScriptLanguage.JavaScript;
  }
  isWasm() {
    return this.#language === Debugger.ScriptLanguage.WebAssembly;
  }
  scriptLanguage() {
    return this.#language;
  }
  executionContext() {
    return this.debuggerModel.runtimeModel().executionContext(this.executionContextId);
  }
  isLiveEdit() {
    return this.#isLiveEditInternal;
  }
  contentURL() {
    return this.sourceURL;
  }
  contentType() {
    return Common15.ResourceType.resourceTypes.Script;
  }
  async loadTextContent() {
    const result = await this.debuggerModel.target().debuggerAgent().invoke_getScriptSource({ scriptId: this.scriptId });
    if (result.getError()) {
      throw new Error(result.getError());
    }
    const { scriptSource, bytecode } = result;
    if (bytecode) {
      return new TextUtils16.ContentData.ContentData(
        bytecode,
        /* isBase64 */
        true,
        "application/wasm"
      );
    }
    let content = scriptSource || "";
    if (this.hasSourceURL && Common15.ParsedURL.schemeIs(this.sourceURL, "snippet:")) {
      content = _Script.trimSourceURLComment(content);
    }
    return new TextUtils16.ContentData.ContentData(
      content,
      /* isBase64 */
      false,
      "text/javascript"
    );
  }
  async loadWasmContent() {
    if (!this.isWasm()) {
      throw new Error("Not a wasm script");
    }
    const result = await this.debuggerModel.target().debuggerAgent().invoke_disassembleWasmModule({ scriptId: this.scriptId });
    if (result.getError()) {
      const contentData = await this.loadTextContent();
      return await disassembleWasm(contentData.base64);
    }
    const { streamId, functionBodyOffsets, chunk: { lines, bytecodeOffsets } } = result;
    const lineChunks = [];
    const bytecodeOffsetChunks = [];
    let totalLength = lines.reduce((sum, line) => sum + line.length + 1, 0);
    const truncationMessage = "<truncated>";
    const cmSizeLimit = 1e9 - truncationMessage.length;
    if (streamId) {
      while (true) {
        const result2 = await this.debuggerModel.target().debuggerAgent().invoke_nextWasmDisassemblyChunk({ streamId });
        if (result2.getError()) {
          throw new Error(result2.getError());
        }
        const { chunk: { lines: linesChunk, bytecodeOffsets: bytecodeOffsetsChunk } } = result2;
        totalLength += linesChunk.reduce((sum, line) => sum + line.length + 1, 0);
        if (linesChunk.length === 0) {
          break;
        }
        if (totalLength >= cmSizeLimit) {
          lineChunks.push([truncationMessage]);
          bytecodeOffsetChunks.push([0]);
          break;
        }
        lineChunks.push(linesChunk);
        bytecodeOffsetChunks.push(bytecodeOffsetsChunk);
      }
    }
    const functionBodyRanges = [];
    for (let i = 0; i < functionBodyOffsets.length; i += 2) {
      functionBodyRanges.push({ start: functionBodyOffsets[i], end: functionBodyOffsets[i + 1] });
    }
    return new TextUtils16.WasmDisassembly.WasmDisassembly(
      lines.concat(...lineChunks),
      bytecodeOffsets.concat(...bytecodeOffsetChunks),
      functionBodyRanges
    );
  }
  requestContentData() {
    if (!this.#contentPromise) {
      const fileSizeToCache = 65535;
      if (this.hash && !this.#isLiveEditInternal && this.contentLength > fileSizeToCache) {
        if (!scriptCacheInstance) {
          scriptCacheInstance = {
            cache: /* @__PURE__ */ new Map(),
            registry: new FinalizationRegistry((hashCode) => scriptCacheInstance?.cache.delete(hashCode))
          };
        }
        const fullHash = [
          this.#language,
          this.contentLength,
          this.lineOffset,
          this.columnOffset,
          this.endLine,
          this.endColumn,
          this.#codeOffsetInternal,
          this.hash
        ].join(":");
        const cachedContentPromise = scriptCacheInstance.cache.get(fullHash)?.deref();
        if (cachedContentPromise) {
          this.#contentPromise = cachedContentPromise;
        } else {
          this.#contentPromise = this.requestContentInternal();
          scriptCacheInstance.cache.set(fullHash, new WeakRef(this.#contentPromise));
          scriptCacheInstance.registry.register(this.#contentPromise, fullHash);
        }
      } else {
        this.#contentPromise = this.requestContentInternal();
      }
    }
    return this.#contentPromise;
  }
  async requestContent() {
    const contentData = await this.requestContentData();
    return TextUtils16.ContentData.ContentData.asDeferredContent(contentData);
  }
  async requestContentInternal() {
    if (!this.scriptId) {
      return { error: i18nString5(UIStrings5.scriptRemovedOrDeleted) };
    }
    try {
      return this.isWasm() ? await this.loadWasmContent() : await this.loadTextContent();
    } catch (err) {
      return { error: i18nString5(UIStrings5.unableToFetchScriptSource) };
    }
  }
  async getWasmBytecode() {
    const base64 = await this.debuggerModel.target().debuggerAgent().invoke_getWasmBytecode({ scriptId: this.scriptId });
    const response = await fetch(`data:application/wasm;base64,${base64.bytecode}`);
    return response.arrayBuffer();
  }
  originalContentProvider() {
    return new TextUtils16.StaticContentProvider.StaticContentProvider(
      this.contentURL(),
      this.contentType(),
      () => this.requestContentData()
    );
  }
  async searchInContent(query, caseSensitive, isRegex) {
    if (!this.scriptId) {
      return [];
    }
    const matches = await this.debuggerModel.target().debuggerAgent().invoke_searchInContent(
      { scriptId: this.scriptId, query, caseSensitive, isRegex }
    );
    return TextUtils16.TextUtils.performSearchInSearchMatches(matches.result || [], query, caseSensitive, isRegex);
  }
  appendSourceURLCommentIfNeeded(source) {
    if (!this.hasSourceURL) {
      return source;
    }
    return source + "\n //# sourceURL=" + this.sourceURL;
  }
  async editSource(newSource) {
    newSource = _Script.trimSourceURLComment(newSource);
    newSource = this.appendSourceURLCommentIfNeeded(newSource);
    const oldSource = TextUtils16.ContentData.ContentData.textOr(await this.requestContentData(), null);
    if (oldSource === newSource) {
      return { changed: false, status: Debugger.SetScriptSourceResponseStatus.Ok };
    }
    const response = await this.debuggerModel.target().debuggerAgent().invoke_setScriptSource(
      { scriptId: this.scriptId, scriptSource: newSource, allowTopFrameEditing: true }
    );
    if (response.getError()) {
      throw new Error(`Script#editSource failed for script with id ${this.scriptId}: ${response.getError()}`);
    }
    if (!response.getError() && response.status === Debugger.SetScriptSourceResponseStatus.Ok) {
      this.#contentPromise = Promise.resolve(new TextUtils16.ContentData.ContentData(
        newSource,
        /* isBase64 */
        false,
        "text/javascript"
      ));
    }
    this.debuggerModel.dispatchEventToListeners(Events11.ScriptSourceWasEdited, { script: this, status: response.status });
    return { changed: true, status: response.status, exceptionDetails: response.exceptionDetails };
  }
  rawLocation(lineNumber, columnNumber) {
    if (this.containsLocation(lineNumber, columnNumber)) {
      return new Location(this.debuggerModel, this.scriptId, lineNumber, columnNumber);
    }
    return null;
  }
  isInlineScript() {
    const startsAtZero = !this.lineOffset && !this.columnOffset;
    return !this.isWasm() && Boolean(this.sourceURL) && !startsAtZero;
  }
  isAnonymousScript() {
    return !this.sourceURL;
  }
  async setBlackboxedRanges(positions) {
    const response = await this.debuggerModel.target().debuggerAgent().invoke_setBlackboxedRanges(
      { scriptId: this.scriptId, positions }
    );
    return !response.getError();
  }
  containsLocation(lineNumber, columnNumber) {
    const afterStart = lineNumber === this.lineOffset && columnNumber >= this.columnOffset || lineNumber > this.lineOffset;
    const beforeEnd = lineNumber < this.endLine || lineNumber === this.endLine && columnNumber <= this.endColumn;
    return afterStart && beforeEnd;
  }
  get frameId() {
    if (typeof this[frameIdSymbol] !== "string") {
      this[frameIdSymbol] = frameIdForScript(this);
    }
    return this[frameIdSymbol];
  }
  /**
   * @returns true, iff this script originates from a breakpoint/logpoint condition
   */
  get isBreakpointCondition() {
    return [COND_BREAKPOINT_SOURCE_URL, LOGPOINT_SOURCE_URL].includes(this.sourceURL);
  }
  /**
   * @returns the currently attached source map for this Script or `undefined` if there is none or it
   * hasn't loaded yet.
   */
  sourceMap() {
    return this.debuggerModel.sourceMapManager().sourceMapForClient(this);
  }
  createPageResourceLoadInitiator() {
    return { target: this.target(), frameId: this.frameId, initiatorUrl: this.embedderName() };
  }
  rawLocationToRelativeLocation(rawLocation) {
    let { lineNumber, columnNumber } = rawLocation;
    if (!this.hasSourceURL && this.isInlineScript()) {
      lineNumber -= this.lineOffset;
      if (lineNumber === 0 && columnNumber !== void 0) {
        columnNumber -= this.columnOffset;
      }
    }
    return { lineNumber, columnNumber };
  }
  relativeLocationToRawLocation(relativeLocation) {
    let { lineNumber, columnNumber } = relativeLocation;
    if (!this.hasSourceURL && this.isInlineScript()) {
      if (lineNumber === 0 && columnNumber !== void 0) {
        columnNumber += this.columnOffset;
      }
      lineNumber += this.lineOffset;
    }
    return { lineNumber, columnNumber };
  }
};
var frameIdSymbol = Symbol("frameid");
function frameIdForScript(script) {
  const executionContext = script.executionContext();
  if (executionContext) {
    return executionContext.frameId || null;
  }
  const resourceTreeModel = script.debuggerModel.target().model(ResourceTreeModel);
  if (!resourceTreeModel || !resourceTreeModel.mainFrame) {
    return null;
  }
  return resourceTreeModel.mainFrame.id;
}
var sourceURLRegex = /^[\x20\t]*\/\/[@#] sourceURL=\s*(\S*?)\s*$/;
async function disassembleWasm(content) {
  const worker = Common15.Worker.WorkerWrapper.fromURL(
    new URL("../../entrypoints/wasmparser_worker/wasmparser_worker-entrypoint.js", import.meta.url)
  );
  const promise = new Promise((resolve, reject) => {
    worker.onmessage = ({ data }) => {
      if ("method" in data) {
        switch (data.method) {
          case "disassemble":
            if ("error" in data) {
              reject(data.error);
            } else if ("result" in data) {
              const { lines, offsets, functionBodyOffsets } = data.result;
              resolve(new TextUtils16.WasmDisassembly.WasmDisassembly(lines, offsets, functionBodyOffsets));
            }
            break;
        }
      }
    };
    worker.onerror = reject;
  });
  worker.postMessage({ method: "disassemble", params: { content } });
  try {
    return await promise;
  } finally {
    worker.terminate();
  }
}

// gen/front_end/core/sdk/DebuggerModel.js
var UIStrings6 = {
  /**
   *@description Title of a section in the debugger showing local JavaScript variables.
   */
  local: "Local",
  /**
   *@description Text that refers to closure as a programming term
   */
  closure: "Closure",
  /**
   *@description Noun that represents a section or block of code in the Debugger Model. Shown in the Sources tab, while paused on a breakpoint.
   */
  block: "Block",
  /**
   *@description Label for a group of JavaScript files
   */
  script: "Script",
  /**
   *@description Title of a section in the debugger showing JavaScript variables from the a 'with'
   *block. Block here means section of code, 'with' refers to a JavaScript programming concept and
   *is a fixed term.
   */
  withBlock: "`With` block",
  /**
   *@description Title of a section in the debugger showing JavaScript variables from the a 'catch'
   *block. Block here means section of code, 'catch' refers to a JavaScript programming concept and
   *is a fixed term.
   */
  catchBlock: "`Catch` block",
  /**
   *@description Title of a section in the debugger showing JavaScript variables from the global scope.
   */
  global: "Global",
  /**
   *@description Text for a JavaScript module, the programming concept
   */
  module: "Module",
  /**
   *@description Text describing the expression scope in WebAssembly
   */
  expression: "Expression",
  /**
   *@description Text in Scope Chain Sidebar Pane of the Sources panel
   */
  exception: "Exception",
  /**
   *@description Text in Scope Chain Sidebar Pane of the Sources panel
   */
  returnValue: "Return value"
};
var str_6 = i18n11.i18n.registerUIStrings("core/sdk/DebuggerModel.ts", UIStrings6);
var i18nString6 = i18n11.i18n.getLocalizedString.bind(void 0, str_6);
function sortAndMergeRanges(locationRanges) {
  function compare(p1, p2) {
    return p1.lineNumber - p2.lineNumber || p1.columnNumber - p2.columnNumber;
  }
  function overlap(r1, r2) {
    if (r1.scriptId !== r2.scriptId) {
      return false;
    }
    const n = compare(r1.start, r2.start);
    if (n < 0) {
      return compare(r1.end, r2.start) >= 0;
    }
    if (n > 0) {
      return compare(r1.start, r2.end) <= 0;
    }
    return true;
  }
  if (locationRanges.length === 0) {
    return [];
  }
  locationRanges.sort((r1, r2) => {
    if (r1.scriptId < r2.scriptId) {
      return -1;
    }
    if (r1.scriptId > r2.scriptId) {
      return 1;
    }
    return compare(r1.start, r2.start) || compare(r1.end, r2.end);
  });
  let prev = locationRanges[0];
  const merged = [];
  for (let i = 1; i < locationRanges.length; ++i) {
    const curr = locationRanges[i];
    if (overlap(prev, curr)) {
      if (compare(prev.end, curr.end) <= 0) {
        prev = { ...prev, end: curr.end };
      }
    } else {
      merged.push(prev);
      prev = curr;
    }
  }
  merged.push(prev);
  return merged;
}
var StepMode = /* @__PURE__ */ ((StepMode2) => {
  StepMode2["STEP_INTO"] = "StepInto";
  StepMode2["STEP_OUT"] = "StepOut";
  StepMode2["STEP_OVER"] = "StepOver";
  return StepMode2;
})(StepMode || {});
var WASM_SYMBOLS_PRIORITY = [
  Debugger.DebugSymbolsType.ExternalDWARF,
  Debugger.DebugSymbolsType.EmbeddedDWARF,
  Debugger.DebugSymbolsType.SourceMap
];
var DebuggerModel = class _DebuggerModel extends SDKModel {
  agent;
  runtimeModelInternal;
  #sourceMapManagerInternal;
  #debuggerPausedDetailsInternal;
  #scriptsInternal;
  #scriptsBySourceURL;
  #discardableScripts;
  continueToLocationCallback;
  #selectedCallFrameInternal;
  #debuggerEnabledInternal;
  #debuggerId;
  #skipAllPausesTimeout;
  #beforePausedCallback;
  #computeAutoStepRangesCallback;
  #expandCallFramesCallback;
  evaluateOnCallFrameCallback;
  #synchronizeBreakpointsCallback;
  // We need to be able to register listeners for individual breakpoints. As such, we dispatch
  // on breakpoint ids, which are not statically known. The event #payload will always be a `Location`.
  #breakpointResolvedEventTarget = new Common16.ObjectWrapper.ObjectWrapper();
  // When stepping over with autostepping enabled, the context denotes the function to which autostepping is restricted
  // to by way of its functionLocation (as per Debugger.CallFrame).
  #autoSteppingContext;
  #isPausingInternal;
  constructor(target) {
    super(target);
    target.registerDebuggerDispatcher(new DebuggerDispatcher(this));
    this.agent = target.debuggerAgent();
    this.runtimeModelInternal = target.model(RuntimeModel);
    this.#sourceMapManagerInternal = new SourceMapManager(target);
    this.#debuggerPausedDetailsInternal = null;
    this.#scriptsInternal = /* @__PURE__ */ new Map();
    this.#scriptsBySourceURL = /* @__PURE__ */ new Map();
    this.#discardableScripts = [];
    this.continueToLocationCallback = null;
    this.#selectedCallFrameInternal = null;
    this.#debuggerEnabledInternal = false;
    this.#debuggerId = null;
    this.#skipAllPausesTimeout = 0;
    this.#beforePausedCallback = null;
    this.#computeAutoStepRangesCallback = null;
    this.#expandCallFramesCallback = null;
    this.evaluateOnCallFrameCallback = null;
    this.#synchronizeBreakpointsCallback = null;
    this.#autoSteppingContext = null;
    this.#isPausingInternal = false;
    Common16.Settings.Settings.instance().moduleSetting("pause-on-exception-enabled").addChangeListener(this.pauseOnExceptionStateChanged, this);
    Common16.Settings.Settings.instance().moduleSetting("pause-on-caught-exception").addChangeListener(this.pauseOnExceptionStateChanged, this);
    Common16.Settings.Settings.instance().moduleSetting("pause-on-uncaught-exception").addChangeListener(this.pauseOnExceptionStateChanged, this);
    Common16.Settings.Settings.instance().moduleSetting("disable-async-stack-traces").addChangeListener(this.asyncStackTracesStateChanged, this);
    Common16.Settings.Settings.instance().moduleSetting("breakpoints-active").addChangeListener(this.breakpointsActiveChanged, this);
    if (!target.suspended()) {
      void this.enableDebugger();
    }
    this.#sourceMapManagerInternal.setEnabled(
      Common16.Settings.Settings.instance().moduleSetting("js-source-maps-enabled").get()
    );
    Common16.Settings.Settings.instance().moduleSetting("js-source-maps-enabled").addChangeListener((event) => this.#sourceMapManagerInternal.setEnabled(event.data));
    const resourceTreeModel = target.model(ResourceTreeModel);
    if (resourceTreeModel) {
      resourceTreeModel.addEventListener(Events4.FrameNavigated, this.onFrameNavigated, this);
    }
  }
  static selectSymbolSource(debugSymbols) {
    if (!debugSymbols || debugSymbols.length === 0) {
      return null;
    }
    if ("type" in debugSymbols) {
      if (debugSymbols.type === "None") {
        return null;
      }
      return debugSymbols;
    }
    let debugSymbolsSource = null;
    const symbolTypes = new Map(debugSymbols.map((symbol) => [symbol.type, symbol]));
    for (const symbol of WASM_SYMBOLS_PRIORITY) {
      if (symbolTypes.has(symbol)) {
        debugSymbolsSource = symbolTypes.get(symbol) || null;
        break;
      }
    }
    console.assert(
      debugSymbolsSource !== null,
      "Unknown symbol types. Front-end and back-end should be kept in sync regarding Protocol.Debugger.DebugSymbolTypes"
    );
    if (debugSymbolsSource && debugSymbols.length > 1) {
      Common16.Console.Console.instance().warn(
        `Multiple debug symbols for script were found. Using ${debugSymbolsSource.type}`
      );
    }
    return debugSymbolsSource;
  }
  sourceMapManager() {
    return this.#sourceMapManagerInternal;
  }
  runtimeModel() {
    return this.runtimeModelInternal;
  }
  debuggerEnabled() {
    return Boolean(this.#debuggerEnabledInternal);
  }
  debuggerId() {
    return this.#debuggerId;
  }
  async enableDebugger() {
    if (this.#debuggerEnabledInternal) {
      return;
    }
    this.#debuggerEnabledInternal = true;
    const isRemoteFrontend = Root4.Runtime.Runtime.queryParam("remoteFrontend") || Root4.Runtime.Runtime.queryParam("ws");
    const maxScriptsCacheSize = isRemoteFrontend ? 1e7 : 1e8;
    const enablePromise = this.agent.invoke_enable({ maxScriptsCacheSize });
    let instrumentationPromise;
    if (Root4.Runtime.experiments.isEnabled(Root4.Runtime.ExperimentName.INSTRUMENTATION_BREAKPOINTS)) {
      instrumentationPromise = this.agent.invoke_setInstrumentationBreakpoint({
        instrumentation: Debugger.SetInstrumentationBreakpointRequestInstrumentation.BeforeScriptExecution
      });
    }
    this.pauseOnExceptionStateChanged();
    void this.asyncStackTracesStateChanged();
    if (!Common16.Settings.Settings.instance().moduleSetting("breakpoints-active").get()) {
      this.breakpointsActiveChanged();
    }
    this.dispatchEventToListeners("DebuggerWasEnabled", this);
    const [enableResult] = await Promise.all([enablePromise, instrumentationPromise]);
    this.registerDebugger(enableResult);
  }
  async syncDebuggerId() {
    const isRemoteFrontend = Root4.Runtime.Runtime.queryParam("remoteFrontend") || Root4.Runtime.Runtime.queryParam("ws");
    const maxScriptsCacheSize = isRemoteFrontend ? 1e7 : 1e8;
    const enablePromise = this.agent.invoke_enable({ maxScriptsCacheSize });
    void enablePromise.then(this.registerDebugger.bind(this));
    return enablePromise;
  }
  onFrameNavigated() {
    if (_DebuggerModel.shouldResyncDebuggerId) {
      return;
    }
    _DebuggerModel.shouldResyncDebuggerId = true;
  }
  registerDebugger(response) {
    if (response.getError()) {
      this.#debuggerEnabledInternal = false;
      return;
    }
    const { debuggerId } = response;
    debuggerIdToModel.set(debuggerId, this);
    this.#debuggerId = debuggerId;
    this.dispatchEventToListeners("DebuggerIsReadyToPause", this);
  }
  isReadyToPause() {
    return Boolean(this.#debuggerId);
  }
  static async modelForDebuggerId(debuggerId) {
    if (_DebuggerModel.shouldResyncDebuggerId) {
      await _DebuggerModel.resyncDebuggerIdForModels();
      _DebuggerModel.shouldResyncDebuggerId = false;
    }
    return debuggerIdToModel.get(debuggerId) || null;
  }
  static async resyncDebuggerIdForModels() {
    const dbgModels = debuggerIdToModel.values();
    for (const dbgModel of dbgModels) {
      if (dbgModel.debuggerEnabled()) {
        await dbgModel.syncDebuggerId();
      }
    }
  }
  async disableDebugger() {
    if (!this.#debuggerEnabledInternal) {
      return;
    }
    this.#debuggerEnabledInternal = false;
    await this.asyncStackTracesStateChanged();
    await this.agent.invoke_disable();
    this.#isPausingInternal = false;
    this.globalObjectCleared();
    this.dispatchEventToListeners("DebuggerWasDisabled", this);
    if (typeof this.#debuggerId === "string") {
      debuggerIdToModel.delete(this.#debuggerId);
    }
    this.#debuggerId = null;
  }
  skipAllPauses(skip) {
    if (this.#skipAllPausesTimeout) {
      clearTimeout(this.#skipAllPausesTimeout);
      this.#skipAllPausesTimeout = 0;
    }
    void this.agent.invoke_setSkipAllPauses({ skip });
  }
  skipAllPausesUntilReloadOrTimeout(timeout) {
    if (this.#skipAllPausesTimeout) {
      clearTimeout(this.#skipAllPausesTimeout);
    }
    void this.agent.invoke_setSkipAllPauses({ skip: true });
    this.#skipAllPausesTimeout = window.setTimeout(this.skipAllPauses.bind(this, false), timeout);
  }
  pauseOnExceptionStateChanged() {
    const pauseOnCaughtEnabled = Common16.Settings.Settings.instance().moduleSetting("pause-on-caught-exception").get();
    let state;
    const pauseOnUncaughtEnabled = Common16.Settings.Settings.instance().moduleSetting("pause-on-uncaught-exception").get();
    if (pauseOnCaughtEnabled && pauseOnUncaughtEnabled) {
      state = Debugger.SetPauseOnExceptionsRequestState.All;
    } else if (pauseOnCaughtEnabled) {
      state = Debugger.SetPauseOnExceptionsRequestState.Caught;
    } else if (pauseOnUncaughtEnabled) {
      state = Debugger.SetPauseOnExceptionsRequestState.Uncaught;
    } else {
      state = Debugger.SetPauseOnExceptionsRequestState.None;
    }
    void this.agent.invoke_setPauseOnExceptions({ state });
  }
  asyncStackTracesStateChanged() {
    const maxAsyncStackChainDepth = 32;
    const enabled = !Common16.Settings.Settings.instance().moduleSetting("disable-async-stack-traces").get() && this.#debuggerEnabledInternal;
    const maxDepth = enabled ? maxAsyncStackChainDepth : 0;
    return this.agent.invoke_setAsyncCallStackDepth({ maxDepth });
  }
  breakpointsActiveChanged() {
    void this.agent.invoke_setBreakpointsActive(
      { active: Common16.Settings.Settings.instance().moduleSetting("breakpoints-active").get() }
    );
  }
  setComputeAutoStepRangesCallback(callback) {
    this.#computeAutoStepRangesCallback = callback;
  }
  async computeAutoStepSkipList(mode) {
    let ranges = [];
    if (this.#computeAutoStepRangesCallback && this.#debuggerPausedDetailsInternal && this.#debuggerPausedDetailsInternal.callFrames.length > 0) {
      const [callFrame] = this.#debuggerPausedDetailsInternal.callFrames;
      ranges = await this.#computeAutoStepRangesCallback.call(null, mode, callFrame);
    }
    const skipList = ranges.map(({ start, end }) => ({
      scriptId: start.scriptId,
      start: { lineNumber: start.lineNumber, columnNumber: start.columnNumber },
      end: { lineNumber: end.lineNumber, columnNumber: end.columnNumber }
    }));
    return sortAndMergeRanges(skipList);
  }
  async stepInto() {
    const skipList = await this.computeAutoStepSkipList(
      "StepInto"
      /* STEP_INTO */
    );
    void this.agent.invoke_stepInto({ breakOnAsyncCall: false, skipList });
  }
  async stepOver() {
    this.#autoSteppingContext = this.#debuggerPausedDetailsInternal?.callFrames[0]?.functionLocation() ?? null;
    const skipList = await this.computeAutoStepSkipList(
      "StepOver"
      /* STEP_OVER */
    );
    void this.agent.invoke_stepOver({ skipList });
  }
  async stepOut() {
    const skipList = await this.computeAutoStepSkipList(
      "StepOut"
      /* STEP_OUT */
    );
    if (skipList.length !== 0) {
      void this.agent.invoke_stepOver({ skipList });
    } else {
      void this.agent.invoke_stepOut();
    }
  }
  scheduleStepIntoAsync() {
    void this.computeAutoStepSkipList(
      "StepInto"
      /* STEP_INTO */
    ).then((skipList) => {
      void this.agent.invoke_stepInto({ breakOnAsyncCall: true, skipList });
    });
  }
  resume() {
    void this.agent.invoke_resume({ terminateOnResume: false });
    this.#isPausingInternal = false;
  }
  pause() {
    this.#isPausingInternal = true;
    this.skipAllPauses(false);
    void this.agent.invoke_pause();
  }
  async setBreakpointByURL(url, lineNumber, columnNumber, condition) {
    let urlRegex;
    if (this.target().type() === Type2.NODE && Common16.ParsedURL.schemeIs(url, "file:")) {
      const platformPath = Common16.ParsedURL.ParsedURL.urlToRawPathString(url, Host6.Platform.isWin());
      urlRegex = `${Platform12.StringUtilities.escapeForRegExp(platformPath)}|${Platform12.StringUtilities.escapeForRegExp(url)}`;
      if (Host6.Platform.isWin() && platformPath.match(/^.:\\/)) {
        urlRegex = `[${platformPath[0].toUpperCase()}${platformPath[0].toLowerCase()}]` + urlRegex.substr(1);
      }
    }
    let minColumnNumber = 0;
    const scripts = this.#scriptsBySourceURL.get(url) || [];
    for (let i = 0, l = scripts.length; i < l; ++i) {
      const script = scripts[i];
      if (lineNumber === script.lineOffset) {
        minColumnNumber = minColumnNumber ? Math.min(minColumnNumber, script.columnOffset) : script.columnOffset;
      }
    }
    columnNumber = Math.max(columnNumber || 0, minColumnNumber);
    const response = await this.agent.invoke_setBreakpointByUrl({
      lineNumber,
      url: urlRegex ? void 0 : url,
      urlRegex,
      columnNumber,
      condition
    });
    if (response.getError()) {
      return { locations: [], breakpointId: null };
    }
    let locations = [];
    if (response.locations) {
      locations = response.locations.map((payload) => Location.fromPayload(this, payload));
    }
    return { locations, breakpointId: response.breakpointId };
  }
  async setBreakpointInAnonymousScript(scriptHash, lineNumber, columnNumber, condition) {
    const response = await this.agent.invoke_setBreakpointByUrl({ lineNumber, scriptHash, columnNumber, condition });
    if (response.getError()) {
      return { locations: [], breakpointId: null };
    }
    let locations = [];
    if (response.locations) {
      locations = response.locations.map((payload) => Location.fromPayload(this, payload));
    }
    return { locations, breakpointId: response.breakpointId };
  }
  async removeBreakpoint(breakpointId) {
    await this.agent.invoke_removeBreakpoint({ breakpointId });
  }
  async getPossibleBreakpoints(startLocation, endLocation, restrictToFunction) {
    const response = await this.agent.invoke_getPossibleBreakpoints({
      start: startLocation.payload(),
      end: endLocation ? endLocation.payload() : void 0,
      restrictToFunction
    });
    if (response.getError() || !response.locations) {
      return [];
    }
    return response.locations.map((location) => BreakLocation.fromPayload(this, location));
  }
  async fetchAsyncStackTrace(stackId) {
    const response = await this.agent.invoke_getStackTrace({ stackTraceId: stackId });
    return response.getError() ? null : response.stackTrace;
  }
  breakpointResolved(breakpointId, location) {
    this.#breakpointResolvedEventTarget.dispatchEventToListeners(breakpointId, Location.fromPayload(this, location));
  }
  globalObjectCleared() {
    this.resetDebuggerPausedDetails();
    this.reset();
    this.dispatchEventToListeners("GlobalObjectCleared", this);
  }
  reset() {
    for (const script of this.#scriptsInternal.values()) {
      this.#sourceMapManagerInternal.detachSourceMap(script);
    }
    this.#scriptsInternal.clear();
    this.#scriptsBySourceURL.clear();
    this.#discardableScripts = [];
    this.#autoSteppingContext = null;
  }
  scripts() {
    return Array.from(this.#scriptsInternal.values());
  }
  scriptForId(scriptId) {
    return this.#scriptsInternal.get(scriptId) || null;
  }
  /**
   * Returns all `Script` objects with the same provided `sourceURL`. The
   * resulting array is sorted by time with the newest `Script` in the front.
   */
  scriptsForSourceURL(sourceURL) {
    return this.#scriptsBySourceURL.get(sourceURL) || [];
  }
  scriptsForExecutionContext(executionContext) {
    const result = [];
    for (const script of this.#scriptsInternal.values()) {
      if (script.executionContextId === executionContext.id) {
        result.push(script);
      }
    }
    return result;
  }
  get callFrames() {
    return this.#debuggerPausedDetailsInternal ? this.#debuggerPausedDetailsInternal.callFrames : null;
  }
  debuggerPausedDetails() {
    return this.#debuggerPausedDetailsInternal;
  }
  async setDebuggerPausedDetails(debuggerPausedDetails) {
    this.#isPausingInternal = false;
    this.#debuggerPausedDetailsInternal = debuggerPausedDetails;
    if (this.#beforePausedCallback) {
      if (!await this.#beforePausedCallback.call(null, debuggerPausedDetails, this.#autoSteppingContext)) {
        return false;
      }
    }
    this.#autoSteppingContext = null;
    this.dispatchEventToListeners("DebuggerPaused", this);
    this.setSelectedCallFrame(debuggerPausedDetails.callFrames[0]);
    return true;
  }
  resetDebuggerPausedDetails() {
    this.#isPausingInternal = false;
    this.#debuggerPausedDetailsInternal = null;
    this.setSelectedCallFrame(null);
  }
  setBeforePausedCallback(callback) {
    this.#beforePausedCallback = callback;
  }
  setExpandCallFramesCallback(callback) {
    this.#expandCallFramesCallback = callback;
  }
  setEvaluateOnCallFrameCallback(callback) {
    this.evaluateOnCallFrameCallback = callback;
  }
  setSynchronizeBreakpointsCallback(callback) {
    this.#synchronizeBreakpointsCallback = callback;
  }
  async pausedScript(callFrames, reason, auxData, breakpointIds, asyncStackTrace, asyncStackTraceId) {
    if (reason === Debugger.PausedEventReason.Instrumentation) {
      const script = this.scriptForId(auxData.scriptId);
      if (this.#synchronizeBreakpointsCallback && script) {
        await this.#synchronizeBreakpointsCallback(script);
      }
      this.resume();
      return;
    }
    const pausedDetails = new DebuggerPausedDetails(this, callFrames, reason, auxData, breakpointIds, asyncStackTrace, asyncStackTraceId);
    await this.#expandCallFrames(pausedDetails);
    if (this.continueToLocationCallback) {
      const callback = this.continueToLocationCallback;
      this.continueToLocationCallback = null;
      if (callback(pausedDetails)) {
        return;
      }
    }
    if (!await this.setDebuggerPausedDetails(pausedDetails)) {
      if (this.#autoSteppingContext) {
        void this.stepOver();
      } else {
        void this.stepInto();
      }
    } else {
      Common16.EventTarget.fireEvent("DevTools.DebuggerPaused");
    }
  }
  /** Delegates to the DebuggerLanguagePlugin and potential attached source maps to expand inlined call frames */
  async #expandCallFrames(pausedDetails) {
    if (this.#expandCallFramesCallback) {
      pausedDetails.callFrames = await this.#expandCallFramesCallback.call(null, pausedDetails.callFrames);
    }
    if (!Root4.Runtime.experiments.isEnabled(Root4.Runtime.ExperimentName.USE_SOURCE_MAP_SCOPES)) {
      return;
    }
    const finalFrames = [];
    for (const frame of pausedDetails.callFrames) {
      const sourceMap = await this.sourceMapManager().sourceMapForClientPromise(frame.script);
      if (sourceMap?.hasScopeInfo()) {
        finalFrames.push(...sourceMap.expandCallFrame(frame));
      } else {
        finalFrames.push(frame);
      }
    }
    pausedDetails.callFrames = finalFrames;
  }
  resumedScript() {
    this.resetDebuggerPausedDetails();
    this.dispatchEventToListeners("DebuggerResumed", this);
  }
  parsedScriptSource(scriptId, sourceURL, startLine, startColumn, endLine, endColumn, executionContextId, hash, executionContextAuxData, isLiveEdit, sourceMapURL, hasSourceURLComment, hasSyntaxError, length, isModule, originStackTrace, codeOffset, scriptLanguage, debugSymbols, embedderName) {
    const knownScript = this.#scriptsInternal.get(scriptId);
    if (knownScript) {
      return knownScript;
    }
    let isContentScript = false;
    if (executionContextAuxData && "isDefault" in executionContextAuxData) {
      isContentScript = !executionContextAuxData["isDefault"];
    }
    const selectedDebugSymbol = _DebuggerModel.selectSymbolSource(debugSymbols);
    const script = new Script(
      this,
      scriptId,
      sourceURL,
      startLine,
      startColumn,
      endLine,
      endColumn,
      executionContextId,
      hash,
      isContentScript,
      isLiveEdit,
      sourceMapURL,
      hasSourceURLComment,
      length,
      isModule,
      originStackTrace,
      codeOffset,
      scriptLanguage,
      selectedDebugSymbol,
      embedderName
    );
    this.registerScript(script);
    this.dispatchEventToListeners("ParsedScriptSource", script);
    if (script.sourceMapURL && !hasSyntaxError) {
      this.#sourceMapManagerInternal.attachSourceMap(script, script.sourceURL, script.sourceMapURL);
    }
    const isDiscardable = hasSyntaxError && script.isAnonymousScript();
    if (isDiscardable) {
      this.#discardableScripts.push(script);
      this.collectDiscardedScripts();
    }
    return script;
  }
  setSourceMapURL(script, newSourceMapURL) {
    this.#sourceMapManagerInternal.detachSourceMap(script);
    script.sourceMapURL = newSourceMapURL;
    this.#sourceMapManagerInternal.attachSourceMap(script, script.sourceURL, script.sourceMapURL);
  }
  async setDebugInfoURL(script, _externalURL) {
    if (this.#expandCallFramesCallback && this.#debuggerPausedDetailsInternal) {
      this.#debuggerPausedDetailsInternal.callFrames = await this.#expandCallFramesCallback.call(null, this.#debuggerPausedDetailsInternal.callFrames);
    }
    this.dispatchEventToListeners("DebugInfoAttached", script);
  }
  executionContextDestroyed(executionContext) {
    for (const script of this.#scriptsInternal.values()) {
      if (script.executionContextId === executionContext.id) {
        this.#sourceMapManagerInternal.detachSourceMap(script);
      }
    }
  }
  registerScript(script) {
    this.#scriptsInternal.set(script.scriptId, script);
    if (script.isAnonymousScript()) {
      return;
    }
    let scripts = this.#scriptsBySourceURL.get(script.sourceURL);
    if (!scripts) {
      scripts = [];
      this.#scriptsBySourceURL.set(script.sourceURL, scripts);
    }
    scripts.unshift(script);
  }
  unregisterScript(script) {
    console.assert(script.isAnonymousScript());
    this.#scriptsInternal.delete(script.scriptId);
  }
  collectDiscardedScripts() {
    if (this.#discardableScripts.length < 1e3) {
      return;
    }
    const scriptsToDiscard = this.#discardableScripts.splice(0, 100);
    for (const script of scriptsToDiscard) {
      this.unregisterScript(script);
      this.dispatchEventToListeners("DiscardedAnonymousScriptSource", script);
    }
  }
  createRawLocation(script, lineNumber, columnNumber, inlineFrameIndex) {
    return this.createRawLocationByScriptId(script.scriptId, lineNumber, columnNumber, inlineFrameIndex);
  }
  createRawLocationByURL(sourceURL, lineNumber, columnNumber, inlineFrameIndex) {
    for (const script of this.#scriptsBySourceURL.get(sourceURL) || []) {
      if (script.lineOffset > lineNumber || script.lineOffset === lineNumber && columnNumber !== void 0 && script.columnOffset > columnNumber) {
        continue;
      }
      if (script.endLine < lineNumber || script.endLine === lineNumber && columnNumber !== void 0 && script.endColumn <= columnNumber) {
        continue;
      }
      return new Location(this, script.scriptId, lineNumber, columnNumber, inlineFrameIndex);
    }
    return null;
  }
  createRawLocationByScriptId(scriptId, lineNumber, columnNumber, inlineFrameIndex) {
    return new Location(this, scriptId, lineNumber, columnNumber, inlineFrameIndex);
  }
  createRawLocationsByStackTrace(stackTrace) {
    const rawLocations = [];
    for (let current = stackTrace; current; current = current.parent) {
      for (const { scriptId, lineNumber, columnNumber } of current.callFrames) {
        rawLocations.push(this.createRawLocationByScriptId(scriptId, lineNumber, columnNumber));
      }
    }
    return rawLocations;
  }
  isPaused() {
    return Boolean(this.debuggerPausedDetails());
  }
  isPausing() {
    return this.#isPausingInternal;
  }
  setSelectedCallFrame(callFrame) {
    if (this.#selectedCallFrameInternal === callFrame) {
      return;
    }
    this.#selectedCallFrameInternal = callFrame;
    this.dispatchEventToListeners("CallFrameSelected", this);
  }
  selectedCallFrame() {
    return this.#selectedCallFrameInternal;
  }
  async evaluateOnSelectedCallFrame(options) {
    const callFrame = this.selectedCallFrame();
    if (!callFrame) {
      throw new Error("No call frame selected");
    }
    return callFrame.evaluate(options);
  }
  functionDetailsPromise(remoteObject) {
    return remoteObject.getAllProperties(
      false,
      false
      /* generatePreview */
    ).then(buildDetails.bind(this));
    function buildDetails(response) {
      if (!response) {
        return null;
      }
      let location = null;
      if (response.internalProperties) {
        for (const prop of response.internalProperties) {
          if (prop.name === "[[FunctionLocation]]") {
            location = prop.value;
          }
        }
      }
      let functionName = null;
      if (response.properties) {
        for (const prop of response.properties) {
          if (prop.name === "name" && prop.value && prop.value.type === "string") {
            functionName = prop.value;
          }
        }
      }
      let debuggerLocation = null;
      if (location) {
        debuggerLocation = this.createRawLocationByScriptId(
          location.value.scriptId,
          location.value.lineNumber,
          location.value.columnNumber
        );
      }
      return { location: debuggerLocation, functionName: functionName ? functionName.value : "" };
    }
  }
  async setVariableValue(scopeNumber, variableName, newValue, callFrameId) {
    const response = await this.agent.invoke_setVariableValue({ scopeNumber, variableName, newValue, callFrameId });
    const error = response.getError();
    return error;
  }
  addBreakpointListener(breakpointId, listener, thisObject) {
    this.#breakpointResolvedEventTarget.addEventListener(breakpointId, listener, thisObject);
  }
  removeBreakpointListener(breakpointId, listener, thisObject) {
    this.#breakpointResolvedEventTarget.removeEventListener(breakpointId, listener, thisObject);
  }
  async setBlackboxPatterns(patterns, skipAnonymous) {
    const response = await this.agent.invoke_setBlackboxPatterns({ patterns, skipAnonymous });
    const error = response.getError();
    return !error;
  }
  async setBlackboxExecutionContexts(uniqueIds) {
    const response = await this.agent.invoke_setBlackboxExecutionContexts({ uniqueIds });
    const error = response.getError();
    return !error;
  }
  dispose() {
    if (this.#debuggerId) {
      debuggerIdToModel.delete(this.#debuggerId);
    }
    Common16.Settings.Settings.instance().moduleSetting("pause-on-exception-enabled").removeChangeListener(this.pauseOnExceptionStateChanged, this);
    Common16.Settings.Settings.instance().moduleSetting("pause-on-caught-exception").removeChangeListener(this.pauseOnExceptionStateChanged, this);
    Common16.Settings.Settings.instance().moduleSetting("disable-async-stack-traces").removeChangeListener(this.asyncStackTracesStateChanged, this);
  }
  async suspendModel() {
    await this.disableDebugger();
  }
  async resumeModel() {
    await this.enableDebugger();
  }
  static shouldResyncDebuggerId = false;
  getContinueToLocationCallback() {
    return this.continueToLocationCallback;
  }
  getEvaluateOnCallFrameCallback() {
    return this.evaluateOnCallFrameCallback;
  }
};
var debuggerIdToModel = /* @__PURE__ */ new Map();
var PauseOnExceptionsState = /* @__PURE__ */ ((PauseOnExceptionsState2) => {
  PauseOnExceptionsState2["DontPauseOnExceptions"] = "none";
  PauseOnExceptionsState2["PauseOnAllExceptions"] = "all";
  PauseOnExceptionsState2["PauseOnCaughtExceptions"] = "caught";
  PauseOnExceptionsState2["PauseOnUncaughtExceptions"] = "uncaught";
  return PauseOnExceptionsState2;
})(PauseOnExceptionsState || {});
var Events11 = /* @__PURE__ */ ((Events210) => {
  Events210["DebuggerWasEnabled"] = "DebuggerWasEnabled";
  Events210["DebuggerWasDisabled"] = "DebuggerWasDisabled";
  Events210["DebuggerPaused"] = "DebuggerPaused";
  Events210["DebuggerResumed"] = "DebuggerResumed";
  Events210["DebugInfoAttached"] = "DebugInfoAttached";
  Events210["ParsedScriptSource"] = "ParsedScriptSource";
  Events210["DiscardedAnonymousScriptSource"] = "DiscardedAnonymousScriptSource";
  Events210["GlobalObjectCleared"] = "GlobalObjectCleared";
  Events210["CallFrameSelected"] = "CallFrameSelected";
  Events210["DebuggerIsReadyToPause"] = "DebuggerIsReadyToPause";
  Events210["ScriptSourceWasEdited"] = "ScriptSourceWasEdited";
  return Events210;
})(Events11 || {});
var DebuggerDispatcher = class {
  #debuggerModel;
  constructor(debuggerModel) {
    this.#debuggerModel = debuggerModel;
  }
  paused({ callFrames, reason, data, hitBreakpoints, asyncStackTrace, asyncStackTraceId }) {
    if (!this.#debuggerModel.debuggerEnabled()) {
      return;
    }
    void this.#debuggerModel.pausedScript(
      callFrames,
      reason,
      data,
      hitBreakpoints || [],
      asyncStackTrace,
      asyncStackTraceId
    );
  }
  resumed() {
    if (!this.#debuggerModel.debuggerEnabled()) {
      return;
    }
    this.#debuggerModel.resumedScript();
  }
  scriptParsed({
    scriptId,
    url,
    startLine,
    startColumn,
    endLine,
    endColumn,
    executionContextId,
    hash,
    executionContextAuxData,
    isLiveEdit,
    sourceMapURL,
    hasSourceURL,
    length,
    isModule,
    stackTrace,
    codeOffset,
    scriptLanguage,
    debugSymbols,
    embedderName
  }) {
    if (!this.#debuggerModel.debuggerEnabled()) {
      return;
    }
    this.#debuggerModel.parsedScriptSource(
      scriptId,
      url,
      startLine,
      startColumn,
      endLine,
      endColumn,
      executionContextId,
      hash,
      executionContextAuxData,
      Boolean(isLiveEdit),
      sourceMapURL,
      Boolean(hasSourceURL),
      false,
      length || 0,
      isModule || null,
      stackTrace || null,
      codeOffset || null,
      scriptLanguage || null,
      debugSymbols || null,
      embedderName || null
    );
  }
  scriptFailedToParse({
    scriptId,
    url,
    startLine,
    startColumn,
    endLine,
    endColumn,
    executionContextId,
    hash,
    executionContextAuxData,
    sourceMapURL,
    hasSourceURL,
    length,
    isModule,
    stackTrace,
    codeOffset,
    scriptLanguage,
    embedderName
  }) {
    if (!this.#debuggerModel.debuggerEnabled()) {
      return;
    }
    this.#debuggerModel.parsedScriptSource(
      scriptId,
      url,
      startLine,
      startColumn,
      endLine,
      endColumn,
      executionContextId,
      hash,
      executionContextAuxData,
      false,
      sourceMapURL,
      Boolean(hasSourceURL),
      true,
      length || 0,
      isModule || null,
      stackTrace || null,
      codeOffset || null,
      scriptLanguage || null,
      null,
      embedderName || null
    );
  }
  breakpointResolved({ breakpointId, location }) {
    if (!this.#debuggerModel.debuggerEnabled()) {
      return;
    }
    this.#debuggerModel.breakpointResolved(breakpointId, location);
  }
};
var Location = class _Location {
  debuggerModel;
  scriptId;
  lineNumber;
  columnNumber;
  inlineFrameIndex;
  constructor(debuggerModel, scriptId, lineNumber, columnNumber, inlineFrameIndex) {
    this.debuggerModel = debuggerModel;
    this.scriptId = scriptId;
    this.lineNumber = lineNumber;
    this.columnNumber = columnNumber || 0;
    this.inlineFrameIndex = inlineFrameIndex || 0;
  }
  static fromPayload(debuggerModel, payload, inlineFrameIndex) {
    return new _Location(debuggerModel, payload.scriptId, payload.lineNumber, payload.columnNumber, inlineFrameIndex);
  }
  payload() {
    return { scriptId: this.scriptId, lineNumber: this.lineNumber, columnNumber: this.columnNumber };
  }
  script() {
    return this.debuggerModel.scriptForId(this.scriptId);
  }
  continueToLocation(pausedCallback) {
    if (pausedCallback) {
      this.debuggerModel.continueToLocationCallback = this.paused.bind(this, pausedCallback);
    }
    void this.debuggerModel.agent.invoke_continueToLocation({
      location: this.payload(),
      targetCallFrames: Debugger.ContinueToLocationRequestTargetCallFrames.Current
    });
  }
  paused(pausedCallback, debuggerPausedDetails) {
    const location = debuggerPausedDetails.callFrames[0].location();
    if (location.scriptId === this.scriptId && location.lineNumber === this.lineNumber && location.columnNumber === this.columnNumber) {
      pausedCallback();
      return true;
    }
    return false;
  }
  id() {
    return this.debuggerModel.target().id() + ":" + this.scriptId + ":" + this.lineNumber + ":" + this.columnNumber;
  }
};
var BreakLocation = class _BreakLocation extends Location {
  type;
  constructor(debuggerModel, scriptId, lineNumber, columnNumber, type) {
    super(debuggerModel, scriptId, lineNumber, columnNumber);
    if (type) {
      this.type = type;
    }
  }
  static fromPayload(debuggerModel, payload) {
    return new _BreakLocation(debuggerModel, payload.scriptId, payload.lineNumber, payload.columnNumber, payload.type);
  }
};
var CallFrame = class _CallFrame {
  debuggerModel;
  script;
  payload;
  #locationInternal;
  #scopeChainInternal;
  #localScopeInternal;
  inlineFrameIndex;
  functionName;
  #functionLocationInternal;
  #returnValueInternal;
  missingDebugInfoDetails;
  exception;
  canBeRestarted;
  constructor(debuggerModel, script, payload, inlineFrameIndex, functionName, exception = null) {
    this.debuggerModel = debuggerModel;
    this.script = script;
    this.payload = payload;
    this.#locationInternal = Location.fromPayload(debuggerModel, payload.location, inlineFrameIndex);
    this.#scopeChainInternal = [];
    this.#localScopeInternal = null;
    this.inlineFrameIndex = inlineFrameIndex || 0;
    this.functionName = functionName ?? payload.functionName;
    this.missingDebugInfoDetails = null;
    this.canBeRestarted = Boolean(payload.canBeRestarted);
    this.exception = exception;
    for (let i = 0; i < payload.scopeChain.length; ++i) {
      const scope = new Scope(this, i);
      this.#scopeChainInternal.push(scope);
      if (scope.type() === Debugger.ScopeType.Local) {
        this.#localScopeInternal = scope;
      }
    }
    if (payload.functionLocation) {
      this.#functionLocationInternal = Location.fromPayload(debuggerModel, payload.functionLocation);
    }
    this.#returnValueInternal = payload.returnValue ? this.debuggerModel.runtimeModel().createRemoteObject(payload.returnValue) : null;
  }
  static fromPayloadArray(debuggerModel, callFrames, exception) {
    const result = [];
    for (let i = 0; i < callFrames.length; ++i) {
      const callFrame = callFrames[i];
      const script = debuggerModel.scriptForId(callFrame.location.scriptId);
      if (script) {
        const ex = i === 0 ? exception : null;
        result.push(new _CallFrame(debuggerModel, script, callFrame, void 0, void 0, ex));
      }
    }
    return result;
  }
  createVirtualCallFrame(inlineFrameIndex, name) {
    return new _CallFrame(this.debuggerModel, this.script, this.payload, inlineFrameIndex, name, this.exception);
  }
  get id() {
    return this.payload.callFrameId;
  }
  scopeChain() {
    return this.#scopeChainInternal;
  }
  localScope() {
    return this.#localScopeInternal;
  }
  thisObject() {
    return this.payload.this ? this.debuggerModel.runtimeModel().createRemoteObject(this.payload.this) : null;
  }
  returnValue() {
    return this.#returnValueInternal;
  }
  async setReturnValue(expression) {
    if (!this.#returnValueInternal) {
      return null;
    }
    const evaluateResponse = await this.debuggerModel.agent.invoke_evaluateOnCallFrame(
      { callFrameId: this.id, expression, silent: true, objectGroup: "backtrace" }
    );
    if (evaluateResponse.getError() || evaluateResponse.exceptionDetails) {
      return null;
    }
    const response = await this.debuggerModel.agent.invoke_setReturnValue({ newValue: evaluateResponse.result });
    if (response.getError()) {
      return null;
    }
    this.#returnValueInternal = this.debuggerModel.runtimeModel().createRemoteObject(evaluateResponse.result);
    return this.#returnValueInternal;
  }
  location() {
    return this.#locationInternal;
  }
  functionLocation() {
    return this.#functionLocationInternal || null;
  }
  async evaluate(options) {
    const debuggerModel = this.debuggerModel;
    const runtimeModel = debuggerModel.runtimeModel();
    const evaluateOnCallFrameCallback = debuggerModel.getEvaluateOnCallFrameCallback();
    if (evaluateOnCallFrameCallback) {
      const result = await evaluateOnCallFrameCallback(this, options);
      if (result) {
        return result;
      }
    }
    const response = await this.debuggerModel.agent.invoke_evaluateOnCallFrame({
      callFrameId: this.id,
      expression: options.expression,
      objectGroup: options.objectGroup,
      includeCommandLineAPI: options.includeCommandLineAPI,
      silent: options.silent,
      returnByValue: options.returnByValue,
      generatePreview: options.generatePreview,
      throwOnSideEffect: options.throwOnSideEffect,
      timeout: options.timeout
    });
    const error = response.getError();
    if (error) {
      return { error };
    }
    return { object: runtimeModel.createRemoteObject(response.result), exceptionDetails: response.exceptionDetails };
  }
  async restart() {
    console.assert(this.canBeRestarted, "This frame can not be restarted.");
    await this.debuggerModel.agent.invoke_restartFrame(
      { callFrameId: this.id, mode: Debugger.RestartFrameRequestMode.StepInto }
    );
  }
  getPayload() {
    return this.payload;
  }
};
var Scope = class {
  #callFrameInternal;
  #payload;
  #typeInternal;
  #nameInternal;
  #ordinal;
  #locationRange;
  #objectInternal;
  constructor(callFrame, ordinal) {
    this.#callFrameInternal = callFrame;
    this.#payload = callFrame.getPayload().scopeChain[ordinal];
    this.#typeInternal = this.#payload.type;
    this.#nameInternal = this.#payload.name;
    this.#ordinal = ordinal;
    this.#objectInternal = null;
    const start = this.#payload.startLocation ? Location.fromPayload(callFrame.debuggerModel, this.#payload.startLocation) : null;
    const end = this.#payload.endLocation ? Location.fromPayload(callFrame.debuggerModel, this.#payload.endLocation) : null;
    if (start && end && start.scriptId === end.scriptId) {
      this.#locationRange = { start, end };
    } else {
      this.#locationRange = null;
    }
  }
  callFrame() {
    return this.#callFrameInternal;
  }
  type() {
    return this.#typeInternal;
  }
  typeName() {
    switch (this.#typeInternal) {
      case Debugger.ScopeType.Local:
        return i18nString6(UIStrings6.local);
      case Debugger.ScopeType.Closure:
        return i18nString6(UIStrings6.closure);
      case Debugger.ScopeType.Catch:
        return i18nString6(UIStrings6.catchBlock);
      case Debugger.ScopeType.Eval:
        return i18n11.i18n.lockedString("Eval");
      case Debugger.ScopeType.Block:
        return i18nString6(UIStrings6.block);
      case Debugger.ScopeType.Script:
        return i18nString6(UIStrings6.script);
      case Debugger.ScopeType.With:
        return i18nString6(UIStrings6.withBlock);
      case Debugger.ScopeType.Global:
        return i18nString6(UIStrings6.global);
      case Debugger.ScopeType.Module:
        return i18nString6(UIStrings6.module);
      case Debugger.ScopeType.WasmExpressionStack:
        return i18nString6(UIStrings6.expression);
    }
    return "";
  }
  name() {
    return this.#nameInternal;
  }
  range() {
    return this.#locationRange;
  }
  object() {
    if (this.#objectInternal) {
      return this.#objectInternal;
    }
    const runtimeModel = this.#callFrameInternal.debuggerModel.runtimeModel();
    const declarativeScope = this.#typeInternal !== Debugger.ScopeType.With && this.#typeInternal !== Debugger.ScopeType.Global;
    if (declarativeScope) {
      this.#objectInternal = runtimeModel.createScopeRemoteObject(
        this.#payload.object,
        new ScopeRef(this.#ordinal, this.#callFrameInternal.id)
      );
    } else {
      this.#objectInternal = runtimeModel.createRemoteObject(this.#payload.object);
    }
    return this.#objectInternal;
  }
  description() {
    const declarativeScope = this.#typeInternal !== Debugger.ScopeType.With && this.#typeInternal !== Debugger.ScopeType.Global;
    return declarativeScope ? "" : this.#payload.object.description || "";
  }
  icon() {
    return void 0;
  }
  extraProperties() {
    if (this.#ordinal !== 0 || this.#typeInternal !== Debugger.ScopeType.Local || this.#callFrameInternal.script.isWasm()) {
      return [];
    }
    const extraProperties = [];
    const exception = this.#callFrameInternal.exception;
    if (exception) {
      extraProperties.push(new RemoteObjectProperty(
        i18nString6(UIStrings6.exception),
        exception,
        void 0,
        void 0,
        void 0,
        void 0,
        void 0,
        /* synthetic */
        true
      ));
    }
    const returnValue = this.#callFrameInternal.returnValue();
    if (returnValue) {
      extraProperties.push(new RemoteObjectProperty(
        i18nString6(UIStrings6.returnValue),
        returnValue,
        void 0,
        void 0,
        void 0,
        void 0,
        void 0,
        /* synthetic */
        true,
        this.#callFrameInternal.setReturnValue.bind(this.#callFrameInternal)
      ));
    }
    return extraProperties;
  }
};
var DebuggerPausedDetails = class {
  debuggerModel;
  callFrames;
  reason;
  auxData;
  breakpointIds;
  asyncStackTrace;
  asyncStackTraceId;
  constructor(debuggerModel, callFrames, reason, auxData, breakpointIds, asyncStackTrace, asyncStackTraceId) {
    this.debuggerModel = debuggerModel;
    this.reason = reason;
    this.auxData = auxData;
    this.breakpointIds = breakpointIds;
    if (asyncStackTrace) {
      this.asyncStackTrace = this.cleanRedundantFrames(asyncStackTrace);
    }
    this.asyncStackTraceId = asyncStackTraceId;
    this.callFrames = CallFrame.fromPayloadArray(debuggerModel, callFrames, this.exception());
  }
  exception() {
    if (this.reason !== Debugger.PausedEventReason.Exception && this.reason !== Debugger.PausedEventReason.PromiseRejection) {
      return null;
    }
    return this.debuggerModel.runtimeModel().createRemoteObject(this.auxData);
  }
  cleanRedundantFrames(asyncStackTrace) {
    let stack = asyncStackTrace;
    let previous = null;
    while (stack) {
      if (previous && !stack.callFrames.length) {
        previous.parent = stack.parent;
      } else {
        previous = stack;
      }
      stack = stack.parent;
    }
    return asyncStackTrace;
  }
};
SDKModel.register(DebuggerModel, { capabilities: Capability.JS, autostart: true });
var BreakpointType = /* @__PURE__ */ ((BreakpointType2) => {
  BreakpointType2["LOGPOINT"] = "LOGPOINT";
  BreakpointType2["CONDITIONAL_BREAKPOINT"] = "CONDITIONAL_BREAKPOINT";
  BreakpointType2["REGULAR_BREAKPOINT"] = "REGULAR_BREAKPOINT";
  return BreakpointType2;
})(BreakpointType || {});
var LOGPOINT_SOURCE_URL = "debugger://logpoint";
var COND_BREAKPOINT_SOURCE_URL = "debugger://breakpoint";

// gen/front_end/core/sdk/OverlayPersistentHighlighter.js
var OverlayPersistentHighlighter_exports = {};
__export(OverlayPersistentHighlighter_exports, {
  HighlightType: () => HighlightType,
  OverlayPersistentHighlighter: () => OverlayPersistentHighlighter
});
import * as Common18 from "./../common/common.js";
import * as Platform13 from "./../platform/platform.js";

// gen/front_end/core/sdk/OverlayColorGenerator.js
var OverlayColorGenerator_exports = {};
__export(OverlayColorGenerator_exports, {
  OverlayColorGenerator: () => OverlayColorGenerator
});
import * as Common17 from "./../common/common.js";
var OverlayColorGenerator = class {
  #colors;
  #index;
  constructor() {
    const format = Common17.Color.Format.RGBA;
    this.#colors = [
      // F59794
      new Common17.Color.Legacy([0.9607843137254902, 0.592156862745098, 0.5803921568627451, 1], format),
      // F0BF4C
      new Common17.Color.Legacy([0.9411764705882353, 0.7490196078431373, 0.2980392156862745, 1], format),
      // D4ED31
      new Common17.Color.Legacy([0.8313725490196079, 0.9294117647058824, 0.19215686274509805, 1], format),
      // 9EEB47
      new Common17.Color.Legacy([0.6196078431372549, 0.9215686274509803, 0.2784313725490196, 1], format),
      // 5BD1D7
      new Common17.Color.Legacy([0.3568627450980392, 0.8196078431372549, 0.8431372549019608, 1], format),
      // BCCEFB
      new Common17.Color.Legacy([0.7372549019607844, 0.807843137254902, 0.984313725490196, 1], format),
      // C6BEEE
      new Common17.Color.Legacy([0.7764705882352941, 0.7450980392156863, 0.9333333333333333, 1], format),
      // D094EA
      new Common17.Color.Legacy([0.8156862745098039, 0.5803921568627451, 0.9176470588235294, 1], format),
      // EB94CF
      new Common17.Color.Legacy([0.9215686274509803, 0.5803921568627451, 0.8117647058823529, 1], format)
    ];
    this.#index = 0;
  }
  /**
   * Generate the next color in the spectrum
   */
  next() {
    const color = this.#colors[this.#index];
    this.#index++;
    if (this.#index >= this.#colors.length) {
      this.#index = 0;
    }
    return color;
  }
};

// gen/front_end/core/sdk/OverlayPersistentHighlighter.js
var HighlightType = /* @__PURE__ */ ((HighlightType2) => {
  HighlightType2["FLEX"] = "FLEX";
  HighlightType2["GRID"] = "GRID";
  HighlightType2["SCROLL_SNAP"] = "SCROLL_SNAP";
  HighlightType2["CONTAINER_QUERY"] = "CONTAINER_QUERY";
  HighlightType2["ISOLATED_ELEMENT"] = "ISOLATED_ELEMENT";
  return HighlightType2;
})(HighlightType || {});
var OverlayPersistentHighlighter = class {
  #model;
  #colors;
  #persistentHighlightSetting;
  #gridHighlights;
  #scrollSnapHighlights;
  #flexHighlights;
  #containerQueryHighlights;
  #isolatedElementHighlights;
  #gridColorGenerator;
  #flexColorGenerator;
  /**
   * @see `front_end/core/sdk/sdk-meta.ts`
   */
  #showGridLineLabelsSetting;
  #extendGridLinesSetting;
  #showGridAreasSetting;
  #showGridTrackSizesSetting;
  #callbacks;
  constructor(model, callbacks) {
    this.#model = model;
    this.#callbacks = callbacks;
    this.#persistentHighlightSetting = Common18.Settings.Settings.instance().createLocalSetting("persistent-highlight-setting", []);
    this.#gridHighlights = /* @__PURE__ */ new Map();
    this.#scrollSnapHighlights = /* @__PURE__ */ new Map();
    this.#flexHighlights = /* @__PURE__ */ new Map();
    this.#containerQueryHighlights = /* @__PURE__ */ new Map();
    this.#isolatedElementHighlights = /* @__PURE__ */ new Map();
    this.#colors = /* @__PURE__ */ new Map();
    this.#gridColorGenerator = new OverlayColorGenerator();
    this.#flexColorGenerator = new OverlayColorGenerator();
    this.#showGridLineLabelsSetting = Common18.Settings.Settings.instance().moduleSetting("show-grid-line-labels");
    this.#showGridLineLabelsSetting.addChangeListener(this.onSettingChange, this);
    this.#extendGridLinesSetting = Common18.Settings.Settings.instance().moduleSetting("extend-grid-lines");
    this.#extendGridLinesSetting.addChangeListener(this.onSettingChange, this);
    this.#showGridAreasSetting = Common18.Settings.Settings.instance().moduleSetting("show-grid-areas");
    this.#showGridAreasSetting.addChangeListener(this.onSettingChange, this);
    this.#showGridTrackSizesSetting = Common18.Settings.Settings.instance().moduleSetting("show-grid-track-sizes");
    this.#showGridTrackSizesSetting.addChangeListener(this.onSettingChange, this);
  }
  onSettingChange() {
    this.resetOverlay();
  }
  buildGridHighlightConfig(nodeId) {
    const mainColor = this.colorOfGrid(nodeId).asLegacyColor();
    const background = mainColor.setAlpha(0.1).asLegacyColor();
    const gapBackground = mainColor.setAlpha(0.3).asLegacyColor();
    const gapHatch = mainColor.setAlpha(0.8).asLegacyColor();
    const showGridExtensionLines = this.#extendGridLinesSetting.get();
    const showPositiveLineNumbers = this.#showGridLineLabelsSetting.get() === "lineNumbers";
    const showNegativeLineNumbers = showPositiveLineNumbers;
    const showLineNames = this.#showGridLineLabelsSetting.get() === "lineNames";
    return {
      rowGapColor: gapBackground.toProtocolRGBA(),
      rowHatchColor: gapHatch.toProtocolRGBA(),
      columnGapColor: gapBackground.toProtocolRGBA(),
      columnHatchColor: gapHatch.toProtocolRGBA(),
      gridBorderColor: mainColor.toProtocolRGBA(),
      gridBorderDash: false,
      rowLineColor: mainColor.toProtocolRGBA(),
      columnLineColor: mainColor.toProtocolRGBA(),
      rowLineDash: true,
      columnLineDash: true,
      showGridExtensionLines,
      showPositiveLineNumbers,
      showNegativeLineNumbers,
      showLineNames,
      showAreaNames: this.#showGridAreasSetting.get(),
      showTrackSizes: this.#showGridTrackSizesSetting.get(),
      areaBorderColor: mainColor.toProtocolRGBA(),
      gridBackgroundColor: background.toProtocolRGBA()
    };
  }
  buildFlexContainerHighlightConfig(nodeId) {
    const mainColor = this.colorOfFlex(nodeId).asLegacyColor();
    return {
      containerBorder: { color: mainColor.toProtocolRGBA(), pattern: Overlay.LineStylePattern.Dashed },
      itemSeparator: { color: mainColor.toProtocolRGBA(), pattern: Overlay.LineStylePattern.Dotted },
      lineSeparator: { color: mainColor.toProtocolRGBA(), pattern: Overlay.LineStylePattern.Dashed },
      mainDistributedSpace: { hatchColor: mainColor.toProtocolRGBA() },
      crossDistributedSpace: { hatchColor: mainColor.toProtocolRGBA() }
    };
  }
  buildScrollSnapContainerHighlightConfig(_nodeId) {
    return {
      snapAreaBorder: {
        color: Common18.Color.PageHighlight.GridBorder.toProtocolRGBA(),
        pattern: Overlay.LineStylePattern.Dashed
      },
      snapportBorder: { color: Common18.Color.PageHighlight.GridBorder.toProtocolRGBA() },
      scrollMarginColor: Common18.Color.PageHighlight.Margin.toProtocolRGBA(),
      scrollPaddingColor: Common18.Color.PageHighlight.Padding.toProtocolRGBA()
    };
  }
  highlightGridInOverlay(nodeId) {
    this.#gridHighlights.set(nodeId, this.buildGridHighlightConfig(nodeId));
    this.updateHighlightsInOverlay();
    this.savePersistentHighlightSetting();
    this.#callbacks.onGridOverlayStateChanged({ nodeId, enabled: true });
  }
  isGridHighlighted(nodeId) {
    return this.#gridHighlights.has(nodeId);
  }
  colorOfGrid(nodeId) {
    let color = this.#colors.get(nodeId);
    if (!color) {
      color = this.#gridColorGenerator.next();
      this.#colors.set(nodeId, color);
    }
    return color;
  }
  setColorOfGrid(nodeId, color) {
    this.#colors.set(nodeId, color);
  }
  hideGridInOverlay(nodeId) {
    if (this.#gridHighlights.has(nodeId)) {
      this.#gridHighlights.delete(nodeId);
      this.updateHighlightsInOverlay();
      this.savePersistentHighlightSetting();
      this.#callbacks.onGridOverlayStateChanged({ nodeId, enabled: false });
    }
  }
  highlightScrollSnapInOverlay(nodeId) {
    this.#scrollSnapHighlights.set(nodeId, this.buildScrollSnapContainerHighlightConfig(nodeId));
    this.updateHighlightsInOverlay();
    this.#callbacks.onScrollSnapOverlayStateChanged({ nodeId, enabled: true });
    this.savePersistentHighlightSetting();
  }
  isScrollSnapHighlighted(nodeId) {
    return this.#scrollSnapHighlights.has(nodeId);
  }
  hideScrollSnapInOverlay(nodeId) {
    if (this.#scrollSnapHighlights.has(nodeId)) {
      this.#scrollSnapHighlights.delete(nodeId);
      this.updateHighlightsInOverlay();
      this.#callbacks.onScrollSnapOverlayStateChanged({ nodeId, enabled: false });
      this.savePersistentHighlightSetting();
    }
  }
  highlightFlexInOverlay(nodeId) {
    this.#flexHighlights.set(nodeId, this.buildFlexContainerHighlightConfig(nodeId));
    this.updateHighlightsInOverlay();
    this.savePersistentHighlightSetting();
    this.#callbacks.onFlexOverlayStateChanged({ nodeId, enabled: true });
  }
  isFlexHighlighted(nodeId) {
    return this.#flexHighlights.has(nodeId);
  }
  colorOfFlex(nodeId) {
    let color = this.#colors.get(nodeId);
    if (!color) {
      color = this.#flexColorGenerator.next();
      this.#colors.set(nodeId, color);
    }
    return color;
  }
  setColorOfFlex(nodeId, color) {
    this.#colors.set(nodeId, color);
  }
  hideFlexInOverlay(nodeId) {
    if (this.#flexHighlights.has(nodeId)) {
      this.#flexHighlights.delete(nodeId);
      this.updateHighlightsInOverlay();
      this.savePersistentHighlightSetting();
      this.#callbacks.onFlexOverlayStateChanged({ nodeId, enabled: false });
    }
  }
  highlightContainerQueryInOverlay(nodeId) {
    this.#containerQueryHighlights.set(nodeId, this.buildContainerQueryContainerHighlightConfig());
    this.updateHighlightsInOverlay();
    this.savePersistentHighlightSetting();
    this.#callbacks.onContainerQueryOverlayStateChanged({ nodeId, enabled: true });
  }
  hideContainerQueryInOverlay(nodeId) {
    if (this.#containerQueryHighlights.has(nodeId)) {
      this.#containerQueryHighlights.delete(nodeId);
      this.updateHighlightsInOverlay();
      this.savePersistentHighlightSetting();
      this.#callbacks.onContainerQueryOverlayStateChanged({ nodeId, enabled: false });
    }
  }
  isContainerQueryHighlighted(nodeId) {
    return this.#containerQueryHighlights.has(nodeId);
  }
  buildContainerQueryContainerHighlightConfig() {
    return {
      containerBorder: {
        color: Common18.Color.PageHighlight.LayoutLine.toProtocolRGBA(),
        pattern: Overlay.LineStylePattern.Dashed
      },
      descendantBorder: {
        color: Common18.Color.PageHighlight.LayoutLine.toProtocolRGBA(),
        pattern: Overlay.LineStylePattern.Dashed
      }
    };
  }
  highlightIsolatedElementInOverlay(nodeId) {
    this.#isolatedElementHighlights.set(nodeId, this.buildIsolationModeHighlightConfig());
    this.updateHighlightsInOverlay();
    this.savePersistentHighlightSetting();
  }
  hideIsolatedElementInOverlay(nodeId) {
    if (this.#isolatedElementHighlights.has(nodeId)) {
      this.#isolatedElementHighlights.delete(nodeId);
      this.updateHighlightsInOverlay();
      this.savePersistentHighlightSetting();
    }
  }
  isIsolatedElementHighlighted(nodeId) {
    return this.#isolatedElementHighlights.has(nodeId);
  }
  buildIsolationModeHighlightConfig() {
    return {
      resizerColor: Common18.Color.IsolationModeHighlight.Resizer.toProtocolRGBA(),
      resizerHandleColor: Common18.Color.IsolationModeHighlight.ResizerHandle.toProtocolRGBA(),
      maskColor: Common18.Color.IsolationModeHighlight.Mask.toProtocolRGBA()
    };
  }
  hideAllInOverlayWithoutSave() {
    this.#flexHighlights.clear();
    this.#gridHighlights.clear();
    this.#scrollSnapHighlights.clear();
    this.#containerQueryHighlights.clear();
    this.#isolatedElementHighlights.clear();
    this.updateHighlightsInOverlay();
  }
  refreshHighlights() {
    const gridsNeedUpdate = this.updateHighlightsForDeletedNodes(this.#gridHighlights);
    const flexboxesNeedUpdate = this.updateHighlightsForDeletedNodes(this.#flexHighlights);
    const scrollSnapsNeedUpdate = this.updateHighlightsForDeletedNodes(this.#scrollSnapHighlights);
    const containerQueriesNeedUpdate = this.updateHighlightsForDeletedNodes(this.#containerQueryHighlights);
    const isolatedElementsNeedUpdate = this.updateHighlightsForDeletedNodes(this.#isolatedElementHighlights);
    if (flexboxesNeedUpdate || gridsNeedUpdate || scrollSnapsNeedUpdate || containerQueriesNeedUpdate || isolatedElementsNeedUpdate) {
      this.updateHighlightsInOverlay();
      this.savePersistentHighlightSetting();
    }
  }
  updateHighlightsForDeletedNodes(highlights) {
    let needsUpdate = false;
    for (const nodeId of highlights.keys()) {
      if (this.#model.getDOMModel().nodeForId(nodeId) === null) {
        highlights.delete(nodeId);
        needsUpdate = true;
      }
    }
    return needsUpdate;
  }
  resetOverlay() {
    for (const nodeId of this.#gridHighlights.keys()) {
      this.#gridHighlights.set(nodeId, this.buildGridHighlightConfig(nodeId));
    }
    for (const nodeId of this.#flexHighlights.keys()) {
      this.#flexHighlights.set(nodeId, this.buildFlexContainerHighlightConfig(nodeId));
    }
    for (const nodeId of this.#scrollSnapHighlights.keys()) {
      this.#scrollSnapHighlights.set(nodeId, this.buildScrollSnapContainerHighlightConfig(nodeId));
    }
    for (const nodeId of this.#containerQueryHighlights.keys()) {
      this.#containerQueryHighlights.set(nodeId, this.buildContainerQueryContainerHighlightConfig());
    }
    for (const nodeId of this.#isolatedElementHighlights.keys()) {
      this.#isolatedElementHighlights.set(nodeId, this.buildIsolationModeHighlightConfig());
    }
    this.updateHighlightsInOverlay();
  }
  updateHighlightsInOverlay() {
    const hasNodesToHighlight = this.#gridHighlights.size > 0 || this.#flexHighlights.size > 0 || this.#containerQueryHighlights.size > 0 || this.#isolatedElementHighlights.size > 0;
    this.#model.setShowViewportSizeOnResize(!hasNodesToHighlight);
    this.updateGridHighlightsInOverlay();
    this.updateFlexHighlightsInOverlay();
    this.updateScrollSnapHighlightsInOverlay();
    this.updateContainerQueryHighlightsInOverlay();
    this.updateIsolatedElementHighlightsInOverlay();
  }
  updateGridHighlightsInOverlay() {
    const overlayModel = this.#model;
    const gridNodeHighlightConfigs = [];
    for (const [nodeId, gridHighlightConfig] of this.#gridHighlights.entries()) {
      gridNodeHighlightConfigs.push({ nodeId, gridHighlightConfig });
    }
    overlayModel.target().overlayAgent().invoke_setShowGridOverlays({ gridNodeHighlightConfigs });
  }
  updateFlexHighlightsInOverlay() {
    const overlayModel = this.#model;
    const flexNodeHighlightConfigs = [];
    for (const [nodeId, flexContainerHighlightConfig] of this.#flexHighlights.entries()) {
      flexNodeHighlightConfigs.push({ nodeId, flexContainerHighlightConfig });
    }
    overlayModel.target().overlayAgent().invoke_setShowFlexOverlays({ flexNodeHighlightConfigs });
  }
  updateScrollSnapHighlightsInOverlay() {
    const overlayModel = this.#model;
    const scrollSnapHighlightConfigs = [];
    for (const [nodeId, scrollSnapContainerHighlightConfig] of this.#scrollSnapHighlights.entries()) {
      scrollSnapHighlightConfigs.push({ nodeId, scrollSnapContainerHighlightConfig });
    }
    overlayModel.target().overlayAgent().invoke_setShowScrollSnapOverlays({ scrollSnapHighlightConfigs });
  }
  updateContainerQueryHighlightsInOverlay() {
    const overlayModel = this.#model;
    const containerQueryHighlightConfigs = [];
    for (const [nodeId, containerQueryContainerHighlightConfig] of this.#containerQueryHighlights.entries()) {
      containerQueryHighlightConfigs.push({ nodeId, containerQueryContainerHighlightConfig });
    }
    overlayModel.target().overlayAgent().invoke_setShowContainerQueryOverlays({ containerQueryHighlightConfigs });
  }
  updateIsolatedElementHighlightsInOverlay() {
    const overlayModel = this.#model;
    const isolatedElementHighlightConfigs = [];
    for (const [nodeId, isolationModeHighlightConfig] of this.#isolatedElementHighlights.entries()) {
      isolatedElementHighlightConfigs.push({ nodeId, isolationModeHighlightConfig });
    }
    overlayModel.target().overlayAgent().invoke_setShowIsolatedElements({ isolatedElementHighlightConfigs });
  }
  async restoreHighlightsForDocument() {
    this.#flexHighlights = /* @__PURE__ */ new Map();
    this.#gridHighlights = /* @__PURE__ */ new Map();
    this.#scrollSnapHighlights = /* @__PURE__ */ new Map();
    this.#containerQueryHighlights = /* @__PURE__ */ new Map();
    this.#isolatedElementHighlights = /* @__PURE__ */ new Map();
    const document2 = await this.#model.getDOMModel().requestDocument();
    const currentURL = document2 ? document2.documentURL : Platform13.DevToolsPath.EmptyUrlString;
    await Promise.all(this.#persistentHighlightSetting.get().map(async (persistentHighlight) => {
      if (persistentHighlight.url === currentURL) {
        return this.#model.getDOMModel().pushNodeByPathToFrontend(persistentHighlight.path).then((nodeId) => {
          const node = this.#model.getDOMModel().nodeForId(nodeId);
          if (!node) {
            return;
          }
          switch (persistentHighlight.type) {
            case "GRID":
              this.#gridHighlights.set(node.id, this.buildGridHighlightConfig(node.id));
              this.#callbacks.onGridOverlayStateChanged({ nodeId: node.id, enabled: true });
              break;
            case "FLEX":
              this.#flexHighlights.set(node.id, this.buildFlexContainerHighlightConfig(node.id));
              this.#callbacks.onFlexOverlayStateChanged({ nodeId: node.id, enabled: true });
              break;
            case "CONTAINER_QUERY":
              this.#containerQueryHighlights.set(node.id, this.buildContainerQueryContainerHighlightConfig());
              this.#callbacks.onContainerQueryOverlayStateChanged({ nodeId: node.id, enabled: true });
              break;
            case "SCROLL_SNAP":
              this.#scrollSnapHighlights.set(node.id, this.buildScrollSnapContainerHighlightConfig(node.id));
              this.#callbacks.onScrollSnapOverlayStateChanged({ nodeId: node.id, enabled: true });
              break;
            case "ISOLATED_ELEMENT":
              this.#isolatedElementHighlights.set(node.id, this.buildIsolationModeHighlightConfig());
              break;
          }
        });
      }
    }));
    this.updateHighlightsInOverlay();
  }
  currentUrl() {
    const domDocument = this.#model.getDOMModel().existingDocument();
    return domDocument ? domDocument.documentURL : Platform13.DevToolsPath.EmptyUrlString;
  }
  getPersistentHighlightSettingForOneType(highlights, type) {
    const persistentHighlights = [];
    for (const nodeId of highlights.keys()) {
      const node = this.#model.getDOMModel().nodeForId(nodeId);
      if (node) {
        persistentHighlights.push({ url: this.currentUrl(), path: node.path(), type });
      }
    }
    return persistentHighlights;
  }
  savePersistentHighlightSetting() {
    const currentURL = this.currentUrl();
    const highlightsInOtherDocuments = this.#persistentHighlightSetting.get().filter((persistentSetting) => persistentSetting.url !== currentURL);
    const persistentHighlights = [
      ...highlightsInOtherDocuments,
      ...this.getPersistentHighlightSettingForOneType(
        this.#gridHighlights,
        "GRID"
        /* GRID */
      ),
      ...this.getPersistentHighlightSettingForOneType(
        this.#flexHighlights,
        "FLEX"
        /* FLEX */
      ),
      ...this.getPersistentHighlightSettingForOneType(
        this.#containerQueryHighlights,
        "CONTAINER_QUERY"
        /* CONTAINER_QUERY */
      ),
      ...this.getPersistentHighlightSettingForOneType(
        this.#scrollSnapHighlights,
        "SCROLL_SNAP"
        /* SCROLL_SNAP */
      ),
      ...this.getPersistentHighlightSettingForOneType(
        this.#isolatedElementHighlights,
        "ISOLATED_ELEMENT"
        /* ISOLATED_ELEMENT */
      )
    ];
    this.#persistentHighlightSetting.set(persistentHighlights);
  }
};

// gen/front_end/core/sdk/OverlayModel.js
var UIStrings7 = {
  /**
   *@description Text in Overlay Model
   */
  pausedInDebugger: "Paused in debugger"
};
var str_7 = i18n13.i18n.registerUIStrings("core/sdk/OverlayModel.ts", UIStrings7);
var i18nString7 = i18n13.i18n.getLocalizedString.bind(void 0, str_7);
var EmulatedOSType = /* @__PURE__ */ ((EmulatedOSType2) => {
  EmulatedOSType2["WINDOWS"] = "Windows";
  EmulatedOSType2["MAC"] = "Mac";
  EmulatedOSType2["LINUX"] = "Linux";
  return EmulatedOSType2;
})(EmulatedOSType || {});
var platformOverlayDimensions = {
  mac: { x: 85, y: 0, width: 185, height: 40 },
  linux: { x: 0, y: 0, width: 196, height: 34 },
  windows: { x: 0, y: 0, width: 238, height: 33 }
};
var OverlayModel = class _OverlayModel extends SDKModel {
  #domModel;
  overlayAgent;
  #debuggerModel;
  #inspectModeEnabledInternal;
  #hideHighlightTimeout;
  #defaultHighlighter;
  #highlighter;
  #showPaintRectsSetting;
  #showLayoutShiftRegionsSetting;
  #showAdHighlightsSetting;
  #showDebugBordersSetting;
  #showFPSCounterSetting;
  #showScrollBottleneckRectsSetting;
  #registeredListeners;
  #showViewportSizeOnResize;
  #persistentHighlighter;
  #sourceOrderHighlighter;
  #sourceOrderModeActiveInternal;
  #windowControls;
  constructor(target) {
    super(target);
    this.#domModel = target.model(DOMModel);
    target.registerOverlayDispatcher(this);
    this.overlayAgent = target.overlayAgent();
    this.#debuggerModel = target.model(DebuggerModel);
    if (this.#debuggerModel) {
      Common19.Settings.Settings.instance().moduleSetting("disable-paused-state-overlay").addChangeListener(this.updatePausedInDebuggerMessage, this);
      this.#debuggerModel.addEventListener(
        Events11.DebuggerPaused,
        this.updatePausedInDebuggerMessage,
        this
      );
      this.#debuggerModel.addEventListener(
        Events11.DebuggerResumed,
        this.updatePausedInDebuggerMessage,
        this
      );
      this.#debuggerModel.addEventListener(
        Events11.GlobalObjectCleared,
        this.updatePausedInDebuggerMessage,
        this
      );
    }
    this.#inspectModeEnabledInternal = false;
    this.#hideHighlightTimeout = null;
    this.#defaultHighlighter = new DefaultHighlighter(this);
    this.#highlighter = this.#defaultHighlighter;
    this.#showPaintRectsSetting = Common19.Settings.Settings.instance().moduleSetting("show-paint-rects");
    this.#showLayoutShiftRegionsSetting = Common19.Settings.Settings.instance().moduleSetting("show-layout-shift-regions");
    this.#showAdHighlightsSetting = Common19.Settings.Settings.instance().moduleSetting("show-ad-highlights");
    this.#showDebugBordersSetting = Common19.Settings.Settings.instance().moduleSetting("show-debug-borders");
    this.#showFPSCounterSetting = Common19.Settings.Settings.instance().moduleSetting("show-fps-counter");
    this.#showScrollBottleneckRectsSetting = Common19.Settings.Settings.instance().moduleSetting("show-scroll-bottleneck-rects");
    this.#registeredListeners = [];
    this.#showViewportSizeOnResize = true;
    if (!target.suspended()) {
      void this.overlayAgent.invoke_enable();
      void this.wireAgentToSettings();
    }
    this.#persistentHighlighter = new OverlayPersistentHighlighter(this, {
      onGridOverlayStateChanged: ({ nodeId, enabled }) => this.dispatchEventToListeners("PersistentGridOverlayStateChanged", { nodeId, enabled }),
      onFlexOverlayStateChanged: ({ nodeId, enabled }) => this.dispatchEventToListeners("PersistentFlexContainerOverlayStateChanged", { nodeId, enabled }),
      onContainerQueryOverlayStateChanged: ({ nodeId, enabled }) => this.dispatchEventToListeners("PersistentContainerQueryOverlayStateChanged", { nodeId, enabled }),
      onScrollSnapOverlayStateChanged: ({ nodeId, enabled }) => this.dispatchEventToListeners("PersistentScrollSnapOverlayStateChanged", { nodeId, enabled })
    });
    this.#domModel.addEventListener(Events12.NodeRemoved, () => {
      if (!this.#persistentHighlighter) {
        return;
      }
      this.#persistentHighlighter.refreshHighlights();
    });
    this.#domModel.addEventListener(Events12.DocumentUpdated, () => {
      if (!this.#persistentHighlighter) {
        return;
      }
      this.#persistentHighlighter.hideAllInOverlayWithoutSave();
      if (!target.suspended()) {
        void this.#persistentHighlighter.restoreHighlightsForDocument();
      }
    });
    this.#sourceOrderHighlighter = new SourceOrderHighlighter(this);
    this.#sourceOrderModeActiveInternal = false;
    this.#windowControls = new WindowControls(this.#domModel.cssModel());
  }
  static highlightObjectAsDOMNode(object) {
    const domModel = object.runtimeModel().target().model(DOMModel);
    if (domModel) {
      domModel.overlayModel().highlightInOverlay({ object, selectorList: void 0 });
    }
  }
  static hideDOMNodeHighlight() {
    for (const overlayModel of TargetManager.instance().models(_OverlayModel)) {
      overlayModel.delayedHideHighlight(0);
    }
  }
  static async muteHighlight() {
    return Promise.all(TargetManager.instance().models(_OverlayModel).map((model) => model.suspendModel()));
  }
  static async unmuteHighlight() {
    return Promise.all(TargetManager.instance().models(_OverlayModel).map((model) => model.resumeModel()));
  }
  static highlightRect(rect) {
    for (const overlayModel of TargetManager.instance().models(_OverlayModel)) {
      void overlayModel.highlightRect(rect);
    }
  }
  static clearHighlight() {
    for (const overlayModel of TargetManager.instance().models(_OverlayModel)) {
      void overlayModel.clearHighlight();
    }
  }
  getDOMModel() {
    return this.#domModel;
  }
  highlightRect({ x, y, width, height, color, outlineColor }) {
    const highlightColor = color || { r: 255, g: 0, b: 255, a: 0.3 };
    const highlightOutlineColor = outlineColor || { r: 255, g: 0, b: 255, a: 0.5 };
    return this.overlayAgent.invoke_highlightRect(
      { x, y, width, height, color: highlightColor, outlineColor: highlightOutlineColor }
    );
  }
  clearHighlight() {
    return this.overlayAgent.invoke_hideHighlight();
  }
  async wireAgentToSettings() {
    this.#registeredListeners = [
      this.#showPaintRectsSetting.addChangeListener(
        () => this.overlayAgent.invoke_setShowPaintRects({ result: this.#showPaintRectsSetting.get() })
      ),
      this.#showLayoutShiftRegionsSetting.addChangeListener(
        () => this.overlayAgent.invoke_setShowLayoutShiftRegions({ result: this.#showLayoutShiftRegionsSetting.get() })
      ),
      this.#showAdHighlightsSetting.addChangeListener(
        () => this.overlayAgent.invoke_setShowAdHighlights({ show: this.#showAdHighlightsSetting.get() })
      ),
      this.#showDebugBordersSetting.addChangeListener(
        () => this.overlayAgent.invoke_setShowDebugBorders({ show: this.#showDebugBordersSetting.get() })
      ),
      this.#showFPSCounterSetting.addChangeListener(
        () => this.overlayAgent.invoke_setShowFPSCounter({ show: this.#showFPSCounterSetting.get() })
      ),
      this.#showScrollBottleneckRectsSetting.addChangeListener(
        () => this.overlayAgent.invoke_setShowScrollBottleneckRects(
          { show: this.#showScrollBottleneckRectsSetting.get() }
        )
      )
    ];
    if (this.#showPaintRectsSetting.get()) {
      void this.overlayAgent.invoke_setShowPaintRects({ result: true });
    }
    if (this.#showLayoutShiftRegionsSetting.get()) {
      void this.overlayAgent.invoke_setShowLayoutShiftRegions({ result: true });
    }
    if (this.#showAdHighlightsSetting.get()) {
      void this.overlayAgent.invoke_setShowAdHighlights({ show: true });
    }
    if (this.#showDebugBordersSetting.get()) {
      void this.overlayAgent.invoke_setShowDebugBorders({ show: true });
    }
    if (this.#showFPSCounterSetting.get()) {
      void this.overlayAgent.invoke_setShowFPSCounter({ show: true });
    }
    if (this.#showScrollBottleneckRectsSetting.get()) {
      void this.overlayAgent.invoke_setShowScrollBottleneckRects({ show: true });
    }
    if (this.#debuggerModel && this.#debuggerModel.isPaused()) {
      this.updatePausedInDebuggerMessage();
    }
    await this.overlayAgent.invoke_setShowViewportSizeOnResize({ show: this.#showViewportSizeOnResize });
    this.#persistentHighlighter?.resetOverlay();
  }
  async suspendModel() {
    Common19.EventTarget.removeEventListeners(this.#registeredListeners);
    await this.overlayAgent.invoke_disable();
  }
  async resumeModel() {
    await Promise.all([this.overlayAgent.invoke_enable(), this.wireAgentToSettings()]);
  }
  setShowViewportSizeOnResize(show) {
    if (this.#showViewportSizeOnResize === show) {
      return;
    }
    this.#showViewportSizeOnResize = show;
    if (this.target().suspended()) {
      return;
    }
    void this.overlayAgent.invoke_setShowViewportSizeOnResize({ show });
  }
  updatePausedInDebuggerMessage() {
    if (this.target().suspended()) {
      return;
    }
    const message = this.#debuggerModel && this.#debuggerModel.isPaused() && !Common19.Settings.Settings.instance().moduleSetting("disable-paused-state-overlay").get() ? i18nString7(UIStrings7.pausedInDebugger) : void 0;
    void this.overlayAgent.invoke_setPausedInDebuggerMessage({ message });
  }
  setHighlighter(highlighter) {
    this.#highlighter = highlighter || this.#defaultHighlighter;
  }
  async setInspectMode(mode, showDetailedTooltip = true) {
    await this.#domModel.requestDocument();
    this.#inspectModeEnabledInternal = mode !== Overlay.InspectMode.None;
    this.dispatchEventToListeners("InspectModeWillBeToggled", this);
    void this.#highlighter.setInspectMode(mode, this.buildHighlightConfig("all", showDetailedTooltip));
  }
  inspectModeEnabled() {
    return this.#inspectModeEnabledInternal;
  }
  highlightInOverlay(data, mode, showInfo) {
    if (this.#sourceOrderModeActiveInternal) {
      return;
    }
    if (this.#hideHighlightTimeout) {
      clearTimeout(this.#hideHighlightTimeout);
      this.#hideHighlightTimeout = null;
    }
    const highlightConfig = this.buildHighlightConfig(mode);
    if (typeof showInfo !== "undefined") {
      highlightConfig.showInfo = showInfo;
    }
    this.#highlighter.highlightInOverlay(data, highlightConfig);
  }
  highlightInOverlayForTwoSeconds(data) {
    this.highlightInOverlay(data);
    this.delayedHideHighlight(2e3);
  }
  highlightGridInPersistentOverlay(nodeId) {
    if (!this.#persistentHighlighter) {
      return;
    }
    this.#persistentHighlighter.highlightGridInOverlay(nodeId);
  }
  isHighlightedGridInPersistentOverlay(nodeId) {
    if (!this.#persistentHighlighter) {
      return false;
    }
    return this.#persistentHighlighter.isGridHighlighted(nodeId);
  }
  hideGridInPersistentOverlay(nodeId) {
    if (!this.#persistentHighlighter) {
      return;
    }
    this.#persistentHighlighter.hideGridInOverlay(nodeId);
  }
  highlightScrollSnapInPersistentOverlay(nodeId) {
    if (!this.#persistentHighlighter) {
      return;
    }
    this.#persistentHighlighter.highlightScrollSnapInOverlay(nodeId);
  }
  isHighlightedScrollSnapInPersistentOverlay(nodeId) {
    if (!this.#persistentHighlighter) {
      return false;
    }
    return this.#persistentHighlighter.isScrollSnapHighlighted(nodeId);
  }
  hideScrollSnapInPersistentOverlay(nodeId) {
    if (!this.#persistentHighlighter) {
      return;
    }
    this.#persistentHighlighter.hideScrollSnapInOverlay(nodeId);
  }
  highlightFlexContainerInPersistentOverlay(nodeId) {
    if (!this.#persistentHighlighter) {
      return;
    }
    this.#persistentHighlighter.highlightFlexInOverlay(nodeId);
  }
  isHighlightedFlexContainerInPersistentOverlay(nodeId) {
    if (!this.#persistentHighlighter) {
      return false;
    }
    return this.#persistentHighlighter.isFlexHighlighted(nodeId);
  }
  hideFlexContainerInPersistentOverlay(nodeId) {
    if (!this.#persistentHighlighter) {
      return;
    }
    this.#persistentHighlighter.hideFlexInOverlay(nodeId);
  }
  highlightContainerQueryInPersistentOverlay(nodeId) {
    if (!this.#persistentHighlighter) {
      return;
    }
    this.#persistentHighlighter.highlightContainerQueryInOverlay(nodeId);
  }
  isHighlightedContainerQueryInPersistentOverlay(nodeId) {
    if (!this.#persistentHighlighter) {
      return false;
    }
    return this.#persistentHighlighter.isContainerQueryHighlighted(nodeId);
  }
  hideContainerQueryInPersistentOverlay(nodeId) {
    if (!this.#persistentHighlighter) {
      return;
    }
    this.#persistentHighlighter.hideContainerQueryInOverlay(nodeId);
  }
  highlightSourceOrderInOverlay(node) {
    const sourceOrderConfig = {
      parentOutlineColor: Common19.Color.SourceOrderHighlight.ParentOutline.toProtocolRGBA(),
      childOutlineColor: Common19.Color.SourceOrderHighlight.ChildOutline.toProtocolRGBA()
    };
    this.#sourceOrderHighlighter.highlightSourceOrderInOverlay(node, sourceOrderConfig);
  }
  colorOfGridInPersistentOverlay(nodeId) {
    if (!this.#persistentHighlighter) {
      return null;
    }
    return this.#persistentHighlighter.colorOfGrid(nodeId).asString(Common19.Color.Format.HEX);
  }
  setColorOfGridInPersistentOverlay(nodeId, colorStr) {
    if (!this.#persistentHighlighter) {
      return;
    }
    const color = Common19.Color.parse(colorStr);
    if (!color) {
      return;
    }
    this.#persistentHighlighter.setColorOfGrid(nodeId, color);
    this.#persistentHighlighter.resetOverlay();
  }
  colorOfFlexInPersistentOverlay(nodeId) {
    if (!this.#persistentHighlighter) {
      return null;
    }
    return this.#persistentHighlighter.colorOfFlex(nodeId).asString(Common19.Color.Format.HEX);
  }
  setColorOfFlexInPersistentOverlay(nodeId, colorStr) {
    if (!this.#persistentHighlighter) {
      return;
    }
    const color = Common19.Color.parse(colorStr);
    if (!color) {
      return;
    }
    this.#persistentHighlighter.setColorOfFlex(nodeId, color);
    this.#persistentHighlighter.resetOverlay();
  }
  hideSourceOrderInOverlay() {
    this.#sourceOrderHighlighter.hideSourceOrderHighlight();
  }
  setSourceOrderActive(isActive) {
    this.#sourceOrderModeActiveInternal = isActive;
  }
  sourceOrderModeActive() {
    return this.#sourceOrderModeActiveInternal;
  }
  highlightIsolatedElementInPersistentOverlay(nodeId) {
    if (!this.#persistentHighlighter) {
      return;
    }
    this.#persistentHighlighter.highlightIsolatedElementInOverlay(nodeId);
  }
  hideIsolatedElementInPersistentOverlay(nodeId) {
    if (!this.#persistentHighlighter) {
      return;
    }
    this.#persistentHighlighter.hideIsolatedElementInOverlay(nodeId);
  }
  isHighlightedIsolatedElementInPersistentOverlay(nodeId) {
    if (!this.#persistentHighlighter) {
      return false;
    }
    return this.#persistentHighlighter.isIsolatedElementHighlighted(nodeId);
  }
  delayedHideHighlight(delay) {
    if (this.#hideHighlightTimeout === null) {
      this.#hideHighlightTimeout = window.setTimeout(() => this.highlightInOverlay({ clear: true }), delay);
    }
  }
  highlightFrame(frameId) {
    if (this.#hideHighlightTimeout) {
      clearTimeout(this.#hideHighlightTimeout);
      this.#hideHighlightTimeout = null;
    }
    this.#highlighter.highlightFrame(frameId);
  }
  showHingeForDualScreen(hinge) {
    if (hinge) {
      const { x, y, width, height, contentColor, outlineColor } = hinge;
      void this.overlayAgent.invoke_setShowHinge({
        hingeConfig: { rect: { x, y, width, height }, contentColor, outlineColor }
      });
    } else {
      void this.overlayAgent.invoke_setShowHinge({});
    }
  }
  setWindowControlsPlatform(selectedPlatform) {
    this.#windowControls.selectedPlatform = selectedPlatform;
  }
  setWindowControlsThemeColor(themeColor) {
    this.#windowControls.themeColor = themeColor;
  }
  getWindowControlsConfig() {
    return this.#windowControls.config;
  }
  async toggleWindowControlsToolbar(show) {
    const wcoConfigObj = show ? { windowControlsOverlayConfig: this.#windowControls.config } : {};
    const setWindowControlsOverlayOperation = this.overlayAgent.invoke_setShowWindowControlsOverlay(wcoConfigObj);
    const toggleStylesheetOperation = this.#windowControls.toggleEmulatedOverlay(show);
    await Promise.all([setWindowControlsOverlayOperation, toggleStylesheetOperation]);
    this.setShowViewportSizeOnResize(!show);
  }
  buildHighlightConfig(mode = "all", showDetailedToolip = false) {
    const showRulers = Common19.Settings.Settings.instance().moduleSetting("show-metrics-rulers").get();
    const highlightConfig = {
      showInfo: mode === "all" || mode === "container-outline",
      showRulers,
      showStyles: showDetailedToolip,
      showAccessibilityInfo: showDetailedToolip,
      showExtensionLines: showRulers,
      gridHighlightConfig: {},
      flexContainerHighlightConfig: {},
      flexItemHighlightConfig: {},
      contrastAlgorithm: Root5.Runtime.experiments.isEnabled("apca") ? Overlay.ContrastAlgorithm.Apca : Overlay.ContrastAlgorithm.Aa
    };
    if (mode === "all" || mode === "content") {
      highlightConfig.contentColor = Common19.Color.PageHighlight.Content.toProtocolRGBA();
    }
    if (mode === "all" || mode === "padding") {
      highlightConfig.paddingColor = Common19.Color.PageHighlight.Padding.toProtocolRGBA();
    }
    if (mode === "all" || mode === "border") {
      highlightConfig.borderColor = Common19.Color.PageHighlight.Border.toProtocolRGBA();
    }
    if (mode === "all" || mode === "margin") {
      highlightConfig.marginColor = Common19.Color.PageHighlight.Margin.toProtocolRGBA();
    }
    if (mode === "all") {
      highlightConfig.eventTargetColor = Common19.Color.PageHighlight.EventTarget.toProtocolRGBA();
      highlightConfig.shapeColor = Common19.Color.PageHighlight.Shape.toProtocolRGBA();
      highlightConfig.shapeMarginColor = Common19.Color.PageHighlight.ShapeMargin.toProtocolRGBA();
      highlightConfig.gridHighlightConfig = {
        rowGapColor: Common19.Color.PageHighlight.GapBackground.toProtocolRGBA(),
        rowHatchColor: Common19.Color.PageHighlight.GapHatch.toProtocolRGBA(),
        columnGapColor: Common19.Color.PageHighlight.GapBackground.toProtocolRGBA(),
        columnHatchColor: Common19.Color.PageHighlight.GapHatch.toProtocolRGBA(),
        rowLineColor: Common19.Color.PageHighlight.LayoutLine.toProtocolRGBA(),
        columnLineColor: Common19.Color.PageHighlight.LayoutLine.toProtocolRGBA(),
        rowLineDash: true,
        columnLineDash: true
      };
      highlightConfig.flexContainerHighlightConfig = {
        containerBorder: {
          color: Common19.Color.PageHighlight.LayoutLine.toProtocolRGBA(),
          pattern: Overlay.LineStylePattern.Dashed
        },
        itemSeparator: {
          color: Common19.Color.PageHighlight.LayoutLine.toProtocolRGBA(),
          pattern: Overlay.LineStylePattern.Dotted
        },
        lineSeparator: {
          color: Common19.Color.PageHighlight.LayoutLine.toProtocolRGBA(),
          pattern: Overlay.LineStylePattern.Dashed
        },
        mainDistributedSpace: {
          hatchColor: Common19.Color.PageHighlight.GapHatch.toProtocolRGBA(),
          fillColor: Common19.Color.PageHighlight.GapBackground.toProtocolRGBA()
        },
        crossDistributedSpace: {
          hatchColor: Common19.Color.PageHighlight.GapHatch.toProtocolRGBA(),
          fillColor: Common19.Color.PageHighlight.GapBackground.toProtocolRGBA()
        },
        rowGapSpace: {
          hatchColor: Common19.Color.PageHighlight.GapHatch.toProtocolRGBA(),
          fillColor: Common19.Color.PageHighlight.GapBackground.toProtocolRGBA()
        },
        columnGapSpace: {
          hatchColor: Common19.Color.PageHighlight.GapHatch.toProtocolRGBA(),
          fillColor: Common19.Color.PageHighlight.GapBackground.toProtocolRGBA()
        }
      };
      highlightConfig.flexItemHighlightConfig = {
        baseSizeBox: {
          hatchColor: Common19.Color.PageHighlight.GapHatch.toProtocolRGBA()
        },
        baseSizeBorder: {
          color: Common19.Color.PageHighlight.LayoutLine.toProtocolRGBA(),
          pattern: Overlay.LineStylePattern.Dotted
        },
        flexibilityArrow: {
          color: Common19.Color.PageHighlight.LayoutLine.toProtocolRGBA()
        }
      };
    }
    if (mode.endsWith("gap")) {
      highlightConfig.gridHighlightConfig = {
        gridBorderColor: Common19.Color.PageHighlight.GridBorder.toProtocolRGBA(),
        gridBorderDash: true
      };
      if (mode === "gap" || mode === "row-gap") {
        highlightConfig.gridHighlightConfig.rowGapColor = Common19.Color.PageHighlight.GapBackground.toProtocolRGBA();
        highlightConfig.gridHighlightConfig.rowHatchColor = Common19.Color.PageHighlight.GapHatch.toProtocolRGBA();
      }
      if (mode === "gap" || mode === "column-gap") {
        highlightConfig.gridHighlightConfig.columnGapColor = Common19.Color.PageHighlight.GapBackground.toProtocolRGBA();
        highlightConfig.gridHighlightConfig.columnHatchColor = Common19.Color.PageHighlight.GapHatch.toProtocolRGBA();
      }
    }
    if (mode.endsWith("gap")) {
      highlightConfig.flexContainerHighlightConfig = {
        containerBorder: {
          color: Common19.Color.PageHighlight.LayoutLine.toProtocolRGBA(),
          pattern: Overlay.LineStylePattern.Dashed
        }
      };
      if (mode === "gap" || mode === "row-gap") {
        highlightConfig.flexContainerHighlightConfig.rowGapSpace = {
          hatchColor: Common19.Color.PageHighlight.GapHatch.toProtocolRGBA(),
          fillColor: Common19.Color.PageHighlight.GapBackground.toProtocolRGBA()
        };
      }
      if (mode === "gap" || mode === "column-gap") {
        highlightConfig.flexContainerHighlightConfig.columnGapSpace = {
          hatchColor: Common19.Color.PageHighlight.GapHatch.toProtocolRGBA(),
          fillColor: Common19.Color.PageHighlight.GapBackground.toProtocolRGBA()
        };
      }
    }
    if (mode === "grid-areas") {
      highlightConfig.gridHighlightConfig = {
        rowLineColor: Common19.Color.PageHighlight.LayoutLine.toProtocolRGBA(),
        columnLineColor: Common19.Color.PageHighlight.LayoutLine.toProtocolRGBA(),
        rowLineDash: true,
        columnLineDash: true,
        showAreaNames: true,
        areaBorderColor: Common19.Color.PageHighlight.GridAreaBorder.toProtocolRGBA()
      };
    }
    if (mode === "grid-template-columns") {
      highlightConfig.contentColor = Common19.Color.PageHighlight.Content.toProtocolRGBA();
      highlightConfig.gridHighlightConfig = {
        columnLineColor: Common19.Color.PageHighlight.LayoutLine.toProtocolRGBA(),
        columnLineDash: true
      };
    }
    if (mode === "grid-template-rows") {
      highlightConfig.contentColor = Common19.Color.PageHighlight.Content.toProtocolRGBA();
      highlightConfig.gridHighlightConfig = {
        rowLineColor: Common19.Color.PageHighlight.LayoutLine.toProtocolRGBA(),
        rowLineDash: true
      };
    }
    if (mode === "justify-content") {
      highlightConfig.flexContainerHighlightConfig = {
        containerBorder: {
          color: Common19.Color.PageHighlight.LayoutLine.toProtocolRGBA(),
          pattern: Overlay.LineStylePattern.Dashed
        },
        mainDistributedSpace: {
          hatchColor: Common19.Color.PageHighlight.GapHatch.toProtocolRGBA(),
          fillColor: Common19.Color.PageHighlight.GapBackground.toProtocolRGBA()
        }
      };
    }
    if (mode === "align-content") {
      highlightConfig.flexContainerHighlightConfig = {
        containerBorder: {
          color: Common19.Color.PageHighlight.LayoutLine.toProtocolRGBA(),
          pattern: Overlay.LineStylePattern.Dashed
        },
        crossDistributedSpace: {
          hatchColor: Common19.Color.PageHighlight.GapHatch.toProtocolRGBA(),
          fillColor: Common19.Color.PageHighlight.GapBackground.toProtocolRGBA()
        }
      };
    }
    if (mode === "align-items") {
      highlightConfig.flexContainerHighlightConfig = {
        containerBorder: {
          color: Common19.Color.PageHighlight.LayoutLine.toProtocolRGBA(),
          pattern: Overlay.LineStylePattern.Dashed
        },
        lineSeparator: {
          color: Common19.Color.PageHighlight.LayoutLine.toProtocolRGBA(),
          pattern: Overlay.LineStylePattern.Dashed
        },
        crossAlignment: { color: Common19.Color.PageHighlight.LayoutLine.toProtocolRGBA() }
      };
    }
    if (mode === "flexibility") {
      highlightConfig.flexItemHighlightConfig = {
        baseSizeBox: {
          hatchColor: Common19.Color.PageHighlight.GapHatch.toProtocolRGBA()
        },
        baseSizeBorder: {
          color: Common19.Color.PageHighlight.LayoutLine.toProtocolRGBA(),
          pattern: Overlay.LineStylePattern.Dotted
        },
        flexibilityArrow: {
          color: Common19.Color.PageHighlight.LayoutLine.toProtocolRGBA()
        }
      };
    }
    if (mode === "container-outline") {
      highlightConfig.containerQueryContainerHighlightConfig = {
        containerBorder: {
          color: Common19.Color.PageHighlight.LayoutLine.toProtocolRGBA(),
          pattern: Overlay.LineStylePattern.Dashed
        }
      };
    }
    return highlightConfig;
  }
  nodeHighlightRequested({ nodeId }) {
    const node = this.#domModel.nodeForId(nodeId);
    if (node) {
      this.dispatchEventToListeners("HighlightNodeRequested", node);
    }
  }
  static setInspectNodeHandler(handler) {
    _OverlayModel.inspectNodeHandler = handler;
  }
  inspectNodeRequested({ backendNodeId }) {
    const deferredNode = new DeferredDOMNode(this.target(), backendNodeId);
    if (_OverlayModel.inspectNodeHandler) {
      void deferredNode.resolvePromise().then((node) => {
        if (node && _OverlayModel.inspectNodeHandler) {
          _OverlayModel.inspectNodeHandler(node);
        }
      });
    } else {
      void Common19.Revealer.reveal(deferredNode);
    }
    this.dispatchEventToListeners(
      "InspectModeExited"
      /* EXITED_INSPECT_MODE */
    );
  }
  screenshotRequested({ viewport }) {
    this.dispatchEventToListeners("ScreenshotRequested", viewport);
    this.dispatchEventToListeners(
      "InspectModeExited"
      /* EXITED_INSPECT_MODE */
    );
  }
  inspectModeCanceled() {
    this.dispatchEventToListeners(
      "InspectModeExited"
      /* EXITED_INSPECT_MODE */
    );
  }
  static inspectNodeHandler = null;
  getOverlayAgent() {
    return this.overlayAgent;
  }
  async hasStyleSheetText(url) {
    return this.#windowControls.initializeStyleSheetText(url);
  }
};
var WindowControls = class _WindowControls {
  #cssModel;
  #originalStylesheetText;
  #stylesheetId;
  #currentUrl;
  #config = {
    showCSS: false,
    selectedPlatform: "Windows",
    themeColor: "#ffffff"
  };
  constructor(cssModel) {
    this.#cssModel = cssModel;
  }
  get selectedPlatform() {
    return this.#config.selectedPlatform;
  }
  set selectedPlatform(osType) {
    this.#config.selectedPlatform = osType;
  }
  get themeColor() {
    return this.#config.themeColor;
  }
  set themeColor(color) {
    this.#config.themeColor = color;
  }
  get config() {
    return this.#config;
  }
  async initializeStyleSheetText(url) {
    if (this.#originalStylesheetText && url === this.#currentUrl) {
      return true;
    }
    const cssSourceUrl = this.#fetchCssSourceUrl(url);
    if (!cssSourceUrl) {
      return false;
    }
    this.#stylesheetId = this.#fetchCurrentStyleSheet(cssSourceUrl);
    if (!this.#stylesheetId) {
      return false;
    }
    const stylesheetText = await this.#cssModel.getStyleSheetText(this.#stylesheetId);
    if (!stylesheetText) {
      return false;
    }
    this.#originalStylesheetText = stylesheetText;
    this.#currentUrl = url;
    return true;
  }
  async toggleEmulatedOverlay(showOverlay) {
    if (!this.#stylesheetId || !this.#originalStylesheetText) {
      return;
    }
    if (showOverlay) {
      const styleSheetText = _WindowControls.#getStyleSheetForPlatform(
        this.#config.selectedPlatform.toLowerCase(),
        this.#originalStylesheetText
      );
      if (styleSheetText) {
        await this.#cssModel.setStyleSheetText(this.#stylesheetId, styleSheetText, false);
      }
    } else {
      await this.#cssModel.setStyleSheetText(this.#stylesheetId, this.#originalStylesheetText, false);
    }
  }
  static #getStyleSheetForPlatform(platform, originalStyleSheet) {
    const overlayDimensions = platformOverlayDimensions[platform];
    return _WindowControls.#transformStyleSheet(
      overlayDimensions.x,
      overlayDimensions.y,
      overlayDimensions.width,
      overlayDimensions.height,
      originalStyleSheet
    );
  }
  #fetchCssSourceUrl(url) {
    const parentURL = Common19.ParsedURL.ParsedURL.extractOrigin(url);
    const cssHeaders = this.#cssModel.styleSheetHeaders();
    const header = cssHeaders.find((header2) => header2.sourceURL && header2.sourceURL.includes(parentURL));
    return header?.sourceURL;
  }
  #fetchCurrentStyleSheet(cssSourceUrl) {
    const stylesheetIds = this.#cssModel.getStyleSheetIdsForURL(cssSourceUrl);
    return stylesheetIds.length > 0 ? stylesheetIds[0] : void 0;
  }
  // The primary objective of this function is to adjust certain CSS environment variables within the existing stylesheet
  // and provide it as the style sheet for the emulated overlay.
  static #transformStyleSheet(x, y, width, height, originalStyleSheet) {
    if (!originalStyleSheet) {
      return void 0;
    }
    const stylesheetText = originalStyleSheet;
    const updatedStylesheet = stylesheetText.replace(/: env\(titlebar-area-x(?:,[^)]*)?\);/g, `: env(titlebar-area-x, ${x}px);`).replace(/: env\(titlebar-area-y(?:,[^)]*)?\);/g, `: env(titlebar-area-y, ${y}px);`).replace(
      /: env\(titlebar-area-width(?:,[^)]*)?\);/g,
      `: env(titlebar-area-width, calc(100% - ${width}px));`
    ).replace(/: env\(titlebar-area-height(?:,[^)]*)?\);/g, `: env(titlebar-area-height, ${height}px);`);
    return updatedStylesheet;
  }
  transformStyleSheetforTesting(x, y, width, height, originalStyleSheet) {
    return _WindowControls.#transformStyleSheet(x, y, width, height, originalStyleSheet);
  }
};
var Events13 = /* @__PURE__ */ ((Events210) => {
  Events210["INSPECT_MODE_WILL_BE_TOGGLED"] = "InspectModeWillBeToggled";
  Events210["EXITED_INSPECT_MODE"] = "InspectModeExited";
  Events210["HIGHLIGHT_NODE_REQUESTED"] = "HighlightNodeRequested";
  Events210["SCREENSHOT_REQUESTED"] = "ScreenshotRequested";
  Events210["PERSISTENT_GRID_OVERLAY_STATE_CHANGED"] = "PersistentGridOverlayStateChanged";
  Events210["PERSISTENT_FLEX_CONTAINER_OVERLAY_STATE_CHANGED"] = "PersistentFlexContainerOverlayStateChanged";
  Events210["PERSISTENT_SCROLL_SNAP_OVERLAY_STATE_CHANGED"] = "PersistentScrollSnapOverlayStateChanged";
  Events210["PERSISTENT_CONTAINER_QUERY_OVERLAY_STATE_CHANGED"] = "PersistentContainerQueryOverlayStateChanged";
  return Events210;
})(Events13 || {});
var DefaultHighlighter = class {
  #model;
  constructor(model) {
    this.#model = model;
  }
  highlightInOverlay(data, highlightConfig) {
    const { node, deferredNode, object, selectorList } = { node: void 0, deferredNode: void 0, object: void 0, selectorList: void 0, ...data };
    const nodeId = node ? node.id : void 0;
    const backendNodeId = deferredNode ? deferredNode.backendNodeId() : void 0;
    const objectId = object ? object.objectId : void 0;
    if (nodeId || backendNodeId || objectId) {
      void this.#model.target().overlayAgent().invoke_highlightNode(
        { highlightConfig, nodeId, backendNodeId, objectId, selector: selectorList }
      );
    } else {
      void this.#model.target().overlayAgent().invoke_hideHighlight();
    }
  }
  async setInspectMode(mode, highlightConfig) {
    await this.#model.target().overlayAgent().invoke_setInspectMode({ mode, highlightConfig });
  }
  highlightFrame(frameId) {
    void this.#model.target().overlayAgent().invoke_highlightFrame({
      frameId,
      contentColor: Common19.Color.PageHighlight.Content.toProtocolRGBA(),
      contentOutlineColor: Common19.Color.PageHighlight.ContentOutline.toProtocolRGBA()
    });
  }
};
var SourceOrderHighlighter = class {
  #model;
  constructor(model) {
    this.#model = model;
  }
  highlightSourceOrderInOverlay(node, sourceOrderConfig) {
    this.#model.setSourceOrderActive(true);
    this.#model.setShowViewportSizeOnResize(false);
    void this.#model.getOverlayAgent().invoke_highlightSourceOrder({ sourceOrderConfig, nodeId: node.id });
  }
  hideSourceOrderHighlight() {
    this.#model.setSourceOrderActive(false);
    this.#model.setShowViewportSizeOnResize(true);
    void this.#model.clearHighlight();
  }
};
SDKModel.register(OverlayModel, { capabilities: Capability.DOM, autostart: true });

// gen/front_end/core/sdk/DOMModel.js
var DOMNode = class _DOMNode {
  #domModelInternal;
  #agent;
  ownerDocument;
  #isInShadowTreeInternal;
  id;
  index;
  #backendNodeIdInternal;
  #nodeTypeInternal;
  #nodeNameInternal;
  #localNameInternal;
  nodeValueInternal;
  #pseudoTypeInternal;
  #pseudoIdentifier;
  #shadowRootTypeInternal;
  #frameOwnerFrameIdInternal;
  #xmlVersion;
  #isSVGNodeInternal;
  #isScrollableInternal;
  #creationStackTraceInternal;
  #pseudoElements;
  #distributedNodesInternal;
  assignedSlot;
  shadowRootsInternal;
  #attributesInternal;
  #markers;
  #subtreeMarkerCount;
  childNodeCountInternal;
  childrenInternal;
  nextSibling;
  previousSibling;
  firstChild;
  lastChild;
  parentNode;
  templateContentInternal;
  contentDocumentInternal;
  childDocumentPromiseForTesting;
  #importedDocumentInternal;
  publicId;
  systemId;
  internalSubset;
  name;
  value;
  constructor(domModel) {
    this.#domModelInternal = domModel;
    this.#agent = this.#domModelInternal.getAgent();
    this.index = void 0;
    this.#creationStackTraceInternal = null;
    this.#pseudoElements = /* @__PURE__ */ new Map();
    this.#distributedNodesInternal = [];
    this.assignedSlot = null;
    this.shadowRootsInternal = [];
    this.#attributesInternal = /* @__PURE__ */ new Map();
    this.#markers = /* @__PURE__ */ new Map();
    this.#subtreeMarkerCount = 0;
    this.childrenInternal = null;
    this.nextSibling = null;
    this.previousSibling = null;
    this.firstChild = null;
    this.lastChild = null;
    this.parentNode = null;
  }
  static create(domModel, doc, isInShadowTree, payload) {
    const node = new _DOMNode(domModel);
    node.init(doc, isInShadowTree, payload);
    return node;
  }
  init(doc, isInShadowTree, payload) {
    this.#agent = this.#domModelInternal.getAgent();
    this.ownerDocument = doc;
    this.#isInShadowTreeInternal = isInShadowTree;
    this.id = payload.nodeId;
    this.#backendNodeIdInternal = payload.backendNodeId;
    this.#domModelInternal.registerNode(this);
    this.#nodeTypeInternal = payload.nodeType;
    this.#nodeNameInternal = payload.nodeName;
    this.#localNameInternal = payload.localName;
    this.nodeValueInternal = payload.nodeValue;
    this.#pseudoTypeInternal = payload.pseudoType;
    this.#pseudoIdentifier = payload.pseudoIdentifier;
    this.#shadowRootTypeInternal = payload.shadowRootType;
    this.#frameOwnerFrameIdInternal = payload.frameId || null;
    this.#xmlVersion = payload.xmlVersion;
    this.#isSVGNodeInternal = Boolean(payload.isSVG);
    this.#isScrollableInternal = Boolean(payload.isScrollable);
    if (payload.attributes) {
      this.setAttributesPayload(payload.attributes);
    }
    this.childNodeCountInternal = payload.childNodeCount || 0;
    if (payload.shadowRoots) {
      for (let i = 0; i < payload.shadowRoots.length; ++i) {
        const root = payload.shadowRoots[i];
        const node = _DOMNode.create(this.#domModelInternal, this.ownerDocument, true, root);
        this.shadowRootsInternal.push(node);
        node.parentNode = this;
      }
    }
    if (payload.templateContent) {
      this.templateContentInternal = _DOMNode.create(this.#domModelInternal, this.ownerDocument, true, payload.templateContent);
      this.templateContentInternal.parentNode = this;
      this.childrenInternal = [];
    }
    const frameOwnerTags = /* @__PURE__ */ new Set(["EMBED", "IFRAME", "OBJECT", "FENCEDFRAME"]);
    if (payload.contentDocument) {
      this.contentDocumentInternal = new DOMDocument(this.#domModelInternal, payload.contentDocument);
      this.contentDocumentInternal.parentNode = this;
      this.childrenInternal = [];
    } else if (payload.frameId && frameOwnerTags.has(payload.nodeName)) {
      this.childDocumentPromiseForTesting = this.requestChildDocument(payload.frameId, this.#domModelInternal.target());
      this.childrenInternal = [];
    }
    if (payload.importedDocument) {
      this.#importedDocumentInternal = _DOMNode.create(this.#domModelInternal, this.ownerDocument, true, payload.importedDocument);
      this.#importedDocumentInternal.parentNode = this;
      this.childrenInternal = [];
    }
    if (payload.distributedNodes) {
      this.setDistributedNodePayloads(payload.distributedNodes);
    }
    if (payload.assignedSlot) {
      this.setAssignedSlot(payload.assignedSlot);
    }
    if (payload.children) {
      this.setChildrenPayload(payload.children);
    }
    this.setPseudoElements(payload.pseudoElements);
    if (this.#nodeTypeInternal === Node.ELEMENT_NODE) {
      if (this.ownerDocument && !this.ownerDocument.documentElement && this.#nodeNameInternal === "HTML") {
        this.ownerDocument.documentElement = this;
      }
      if (this.ownerDocument && !this.ownerDocument.body && this.#nodeNameInternal === "BODY") {
        this.ownerDocument.body = this;
      }
    } else if (this.#nodeTypeInternal === Node.DOCUMENT_TYPE_NODE) {
      this.publicId = payload.publicId;
      this.systemId = payload.systemId;
      this.internalSubset = payload.internalSubset;
    } else if (this.#nodeTypeInternal === Node.ATTRIBUTE_NODE) {
      this.name = payload.name;
      this.value = payload.value;
    }
  }
  async requestChildDocument(frameId, notInTarget) {
    const frame = await FrameManager.instance().getOrWaitForFrame(frameId, notInTarget);
    const childModel = frame.resourceTreeModel()?.target().model(DOMModel);
    return childModel?.requestDocument() || null;
  }
  isAdFrameNode() {
    if (this.isIframe() && this.#frameOwnerFrameIdInternal) {
      const frame = FrameManager.instance().getFrame(this.#frameOwnerFrameIdInternal);
      if (!frame) {
        return false;
      }
      return frame.adFrameType() !== Page.AdFrameType.None;
    }
    return false;
  }
  isSVGNode() {
    return this.#isSVGNodeInternal;
  }
  isScrollable() {
    return this.#isScrollableInternal;
  }
  isMediaNode() {
    return this.#nodeNameInternal === "AUDIO" || this.#nodeNameInternal === "VIDEO";
  }
  isViewTransitionPseudoNode() {
    if (!this.#pseudoTypeInternal) {
      return false;
    }
    return [
      DOM.PseudoType.ViewTransition,
      DOM.PseudoType.ViewTransitionGroup,
      DOM.PseudoType.ViewTransitionImagePair,
      DOM.PseudoType.ViewTransitionOld,
      DOM.PseudoType.ViewTransitionNew
    ].includes(this.#pseudoTypeInternal);
  }
  creationStackTrace() {
    if (this.#creationStackTraceInternal) {
      return this.#creationStackTraceInternal;
    }
    const stackTracesPromise = this.#agent.invoke_getNodeStackTraces({ nodeId: this.id });
    this.#creationStackTraceInternal = stackTracesPromise.then((res) => res.creation || null);
    return this.#creationStackTraceInternal;
  }
  get subtreeMarkerCount() {
    return this.#subtreeMarkerCount;
  }
  domModel() {
    return this.#domModelInternal;
  }
  backendNodeId() {
    return this.#backendNodeIdInternal;
  }
  children() {
    return this.childrenInternal ? this.childrenInternal.slice() : null;
  }
  setChildren(children) {
    this.childrenInternal = children;
  }
  setIsScrollable(isScrollable) {
    this.#isScrollableInternal = isScrollable;
  }
  hasAttributes() {
    return this.#attributesInternal.size > 0;
  }
  childNodeCount() {
    return this.childNodeCountInternal;
  }
  setChildNodeCount(childNodeCount) {
    this.childNodeCountInternal = childNodeCount;
  }
  hasShadowRoots() {
    return Boolean(this.shadowRootsInternal.length);
  }
  shadowRoots() {
    return this.shadowRootsInternal.slice();
  }
  templateContent() {
    return this.templateContentInternal || null;
  }
  contentDocument() {
    return this.contentDocumentInternal || null;
  }
  setContentDocument(node) {
    this.contentDocumentInternal = node;
  }
  isIframe() {
    return this.#nodeNameInternal === "IFRAME";
  }
  importedDocument() {
    return this.#importedDocumentInternal || null;
  }
  nodeType() {
    return this.#nodeTypeInternal;
  }
  nodeName() {
    return this.#nodeNameInternal;
  }
  pseudoType() {
    return this.#pseudoTypeInternal;
  }
  pseudoIdentifier() {
    return this.#pseudoIdentifier;
  }
  hasPseudoElements() {
    return this.#pseudoElements.size > 0;
  }
  pseudoElements() {
    return this.#pseudoElements;
  }
  beforePseudoElement() {
    return this.#pseudoElements.get(DOM.PseudoType.Before)?.at(-1);
  }
  afterPseudoElement() {
    return this.#pseudoElements.get(DOM.PseudoType.After)?.at(-1);
  }
  markerPseudoElement() {
    return this.#pseudoElements.get(DOM.PseudoType.Marker)?.at(-1);
  }
  backdropPseudoElement() {
    return this.#pseudoElements.get(DOM.PseudoType.Backdrop)?.at(-1);
  }
  viewTransitionPseudoElements() {
    return [
      ...this.#pseudoElements.get(DOM.PseudoType.ViewTransition) || [],
      ...this.#pseudoElements.get(DOM.PseudoType.ViewTransitionGroup) || [],
      ...this.#pseudoElements.get(DOM.PseudoType.ViewTransitionImagePair) || [],
      ...this.#pseudoElements.get(DOM.PseudoType.ViewTransitionOld) || [],
      ...this.#pseudoElements.get(DOM.PseudoType.ViewTransitionNew) || []
    ];
  }
  hasAssignedSlot() {
    return this.assignedSlot !== null;
  }
  isInsertionPoint() {
    return !this.isXMLNode() && (this.#nodeNameInternal === "SHADOW" || this.#nodeNameInternal === "CONTENT" || this.#nodeNameInternal === "SLOT");
  }
  distributedNodes() {
    return this.#distributedNodesInternal;
  }
  isInShadowTree() {
    return this.#isInShadowTreeInternal;
  }
  ancestorShadowHost() {
    const ancestorShadowRoot = this.ancestorShadowRoot();
    return ancestorShadowRoot ? ancestorShadowRoot.parentNode : null;
  }
  ancestorShadowRoot() {
    if (!this.#isInShadowTreeInternal) {
      return null;
    }
    let current = this;
    while (current && !current.isShadowRoot()) {
      current = current.parentNode;
    }
    return current;
  }
  ancestorUserAgentShadowRoot() {
    const ancestorShadowRoot = this.ancestorShadowRoot();
    if (!ancestorShadowRoot) {
      return null;
    }
    return ancestorShadowRoot.shadowRootType() === _DOMNode.ShadowRootTypes.UserAgent ? ancestorShadowRoot : null;
  }
  isShadowRoot() {
    return Boolean(this.#shadowRootTypeInternal);
  }
  shadowRootType() {
    return this.#shadowRootTypeInternal || null;
  }
  nodeNameInCorrectCase() {
    const shadowRootType = this.shadowRootType();
    if (shadowRootType) {
      return "#shadow-root (" + shadowRootType + ")";
    }
    if (!this.localName()) {
      return this.nodeName();
    }
    if (this.localName().length !== this.nodeName().length) {
      return this.nodeName();
    }
    return this.localName();
  }
  setNodeName(name, callback) {
    void this.#agent.invoke_setNodeName({ nodeId: this.id, name }).then((response) => {
      if (!response.getError()) {
        this.#domModelInternal.markUndoableState();
      }
      if (callback) {
        callback(response.getError() || null, this.#domModelInternal.nodeForId(response.nodeId));
      }
    });
  }
  localName() {
    return this.#localNameInternal;
  }
  nodeValue() {
    return this.nodeValueInternal;
  }
  setNodeValueInternal(nodeValue) {
    this.nodeValueInternal = nodeValue;
  }
  setNodeValue(value, callback) {
    void this.#agent.invoke_setNodeValue({ nodeId: this.id, value }).then((response) => {
      if (!response.getError()) {
        this.#domModelInternal.markUndoableState();
      }
      if (callback) {
        callback(response.getError() || null);
      }
    });
  }
  getAttribute(name) {
    const attr = this.#attributesInternal.get(name);
    return attr ? attr.value : void 0;
  }
  setAttribute(name, text, callback) {
    void this.#agent.invoke_setAttributesAsText({ nodeId: this.id, text, name }).then((response) => {
      if (!response.getError()) {
        this.#domModelInternal.markUndoableState();
      }
      if (callback) {
        callback(response.getError() || null);
      }
    });
  }
  setAttributeValue(name, value, callback) {
    void this.#agent.invoke_setAttributeValue({ nodeId: this.id, name, value }).then((response) => {
      if (!response.getError()) {
        this.#domModelInternal.markUndoableState();
      }
      if (callback) {
        callback(response.getError() || null);
      }
    });
  }
  setAttributeValuePromise(name, value) {
    return new Promise((fulfill) => this.setAttributeValue(name, value, fulfill));
  }
  attributes() {
    return [...this.#attributesInternal.values()];
  }
  async removeAttribute(name) {
    const response = await this.#agent.invoke_removeAttribute({ nodeId: this.id, name });
    if (response.getError()) {
      return;
    }
    this.#attributesInternal.delete(name);
    this.#domModelInternal.markUndoableState();
  }
  getChildNodesPromise() {
    return new Promise((resolve) => {
      return this.getChildNodes((childNodes) => resolve(childNodes));
    });
  }
  getChildNodes(callback) {
    if (this.childrenInternal) {
      callback(this.children());
      return;
    }
    void this.#agent.invoke_requestChildNodes({ nodeId: this.id }).then((response) => {
      callback(response.getError() ? null : this.children());
    });
  }
  async getSubtree(depth, pierce) {
    const response = await this.#agent.invoke_requestChildNodes({ nodeId: this.id, depth, pierce });
    return response.getError() ? null : this.childrenInternal;
  }
  async getOuterHTML() {
    const { outerHTML } = await this.#agent.invoke_getOuterHTML({ nodeId: this.id });
    return outerHTML;
  }
  setOuterHTML(html, callback) {
    void this.#agent.invoke_setOuterHTML({ nodeId: this.id, outerHTML: html }).then((response) => {
      if (!response.getError()) {
        this.#domModelInternal.markUndoableState();
      }
      if (callback) {
        callback(response.getError() || null);
      }
    });
  }
  removeNode(callback) {
    return this.#agent.invoke_removeNode({ nodeId: this.id }).then((response) => {
      if (!response.getError()) {
        this.#domModelInternal.markUndoableState();
      }
      if (callback) {
        callback(response.getError() || null);
      }
    });
  }
  async copyNode() {
    const { outerHTML } = await this.#agent.invoke_getOuterHTML({ nodeId: this.id });
    if (outerHTML !== null) {
      Host7.InspectorFrontendHost.InspectorFrontendHostInstance.copyText(outerHTML);
    }
    return outerHTML;
  }
  path() {
    function getNodeKey(node2) {
      if (!node2.#nodeNameInternal.length) {
        return null;
      }
      if (node2.index !== void 0) {
        return node2.index;
      }
      if (!node2.parentNode) {
        return null;
      }
      if (node2.isShadowRoot()) {
        return node2.shadowRootType() === _DOMNode.ShadowRootTypes.UserAgent ? "u" : "a";
      }
      if (node2.nodeType() === Node.DOCUMENT_NODE) {
        return "d";
      }
      return null;
    }
    const path = [];
    let node = this;
    while (node) {
      const key = getNodeKey(node);
      if (key === null) {
        break;
      }
      path.push([key, node.#nodeNameInternal]);
      node = node.parentNode;
    }
    path.reverse();
    return path.join(",");
  }
  isAncestor(node) {
    if (!node) {
      return false;
    }
    let currentNode = node.parentNode;
    while (currentNode) {
      if (this === currentNode) {
        return true;
      }
      currentNode = currentNode.parentNode;
    }
    return false;
  }
  isDescendant(descendant) {
    return descendant !== null && descendant.isAncestor(this);
  }
  frameOwnerFrameId() {
    return this.#frameOwnerFrameIdInternal;
  }
  frameId() {
    let node = this.parentNode || this;
    while (!node.#frameOwnerFrameIdInternal && node.parentNode) {
      node = node.parentNode;
    }
    return node.#frameOwnerFrameIdInternal;
  }
  setAttributesPayload(attrs) {
    let attributesChanged = !this.#attributesInternal || attrs.length !== this.#attributesInternal.size * 2;
    const oldAttributesMap = this.#attributesInternal || /* @__PURE__ */ new Map();
    this.#attributesInternal = /* @__PURE__ */ new Map();
    for (let i = 0; i < attrs.length; i += 2) {
      const name = attrs[i];
      const value = attrs[i + 1];
      this.addAttribute(name, value);
      if (attributesChanged) {
        continue;
      }
      const oldAttribute = oldAttributesMap.get(name);
      if (!oldAttribute || oldAttribute.value !== value) {
        attributesChanged = true;
      }
    }
    return attributesChanged;
  }
  insertChild(prev, payload) {
    if (!this.childrenInternal) {
      throw new Error("DOMNode._children is expected to not be null.");
    }
    const node = _DOMNode.create(this.#domModelInternal, this.ownerDocument, this.#isInShadowTreeInternal, payload);
    this.childrenInternal.splice(prev ? this.childrenInternal.indexOf(prev) + 1 : 0, 0, node);
    this.renumber();
    return node;
  }
  removeChild(node) {
    const pseudoType = node.pseudoType();
    if (pseudoType) {
      const updatedPseudoElements = this.#pseudoElements.get(pseudoType)?.filter((element) => element !== node);
      if (updatedPseudoElements && updatedPseudoElements.length > 0) {
        this.#pseudoElements.set(pseudoType, updatedPseudoElements);
      } else {
        this.#pseudoElements.delete(pseudoType);
      }
    } else {
      const shadowRootIndex = this.shadowRootsInternal.indexOf(node);
      if (shadowRootIndex !== -1) {
        this.shadowRootsInternal.splice(shadowRootIndex, 1);
      } else {
        if (!this.childrenInternal) {
          throw new Error("DOMNode._children is expected to not be null.");
        }
        if (this.childrenInternal.indexOf(node) === -1) {
          throw new Error("DOMNode._children is expected to contain the node to be removed.");
        }
        this.childrenInternal.splice(this.childrenInternal.indexOf(node), 1);
      }
    }
    node.parentNode = null;
    this.#subtreeMarkerCount -= node.#subtreeMarkerCount;
    if (node.#subtreeMarkerCount) {
      this.#domModelInternal.dispatchEventToListeners("MarkersChanged", this);
    }
    this.renumber();
  }
  setChildrenPayload(payloads) {
    this.childrenInternal = [];
    for (let i = 0; i < payloads.length; ++i) {
      const payload = payloads[i];
      const node = _DOMNode.create(this.#domModelInternal, this.ownerDocument, this.#isInShadowTreeInternal, payload);
      this.childrenInternal.push(node);
    }
    this.renumber();
  }
  setPseudoElements(payloads) {
    if (!payloads) {
      return;
    }
    for (let i = 0; i < payloads.length; ++i) {
      const node = _DOMNode.create(this.#domModelInternal, this.ownerDocument, this.#isInShadowTreeInternal, payloads[i]);
      node.parentNode = this;
      const pseudoType = node.pseudoType();
      if (!pseudoType) {
        throw new Error("DOMNode.pseudoType() is expected to be defined.");
      }
      const currentPseudoElements = this.#pseudoElements.get(pseudoType);
      if (currentPseudoElements) {
        currentPseudoElements.push(node);
      } else {
        this.#pseudoElements.set(pseudoType, [node]);
      }
    }
  }
  setDistributedNodePayloads(payloads) {
    this.#distributedNodesInternal = [];
    for (const payload of payloads) {
      this.#distributedNodesInternal.push(new DOMNodeShortcut(
        this.#domModelInternal.target(),
        payload.backendNodeId,
        payload.nodeType,
        payload.nodeName
      ));
    }
  }
  setAssignedSlot(payload) {
    this.assignedSlot = new DOMNodeShortcut(this.#domModelInternal.target(), payload.backendNodeId, payload.nodeType, payload.nodeName);
  }
  renumber() {
    if (!this.childrenInternal) {
      throw new Error("DOMNode._children is expected to not be null.");
    }
    this.childNodeCountInternal = this.childrenInternal.length;
    if (this.childNodeCountInternal === 0) {
      this.firstChild = null;
      this.lastChild = null;
      return;
    }
    this.firstChild = this.childrenInternal[0];
    this.lastChild = this.childrenInternal[this.childNodeCountInternal - 1];
    for (let i = 0; i < this.childNodeCountInternal; ++i) {
      const child = this.childrenInternal[i];
      child.index = i;
      child.nextSibling = i + 1 < this.childNodeCountInternal ? this.childrenInternal[i + 1] : null;
      child.previousSibling = i - 1 >= 0 ? this.childrenInternal[i - 1] : null;
      child.parentNode = this;
    }
  }
  addAttribute(name, value) {
    const attr = { name, value, _node: this };
    this.#attributesInternal.set(name, attr);
  }
  setAttributeInternal(name, value) {
    const attr = this.#attributesInternal.get(name);
    if (attr) {
      attr.value = value;
    } else {
      this.addAttribute(name, value);
    }
  }
  removeAttributeInternal(name) {
    this.#attributesInternal.delete(name);
  }
  copyTo(targetNode, anchorNode, callback) {
    void this.#agent.invoke_copyTo(
      { nodeId: this.id, targetNodeId: targetNode.id, insertBeforeNodeId: anchorNode ? anchorNode.id : void 0 }
    ).then((response) => {
      if (!response.getError()) {
        this.#domModelInternal.markUndoableState();
      }
      if (callback) {
        callback(response.getError() || null, this.#domModelInternal.nodeForId(response.nodeId));
      }
    });
  }
  moveTo(targetNode, anchorNode, callback) {
    void this.#agent.invoke_moveTo(
      { nodeId: this.id, targetNodeId: targetNode.id, insertBeforeNodeId: anchorNode ? anchorNode.id : void 0 }
    ).then((response) => {
      if (!response.getError()) {
        this.#domModelInternal.markUndoableState();
      }
      if (callback) {
        callback(response.getError() || null, this.#domModelInternal.nodeForId(response.nodeId));
      }
    });
  }
  isXMLNode() {
    return Boolean(this.#xmlVersion);
  }
  setMarker(name, value) {
    if (value === null) {
      if (!this.#markers.has(name)) {
        return;
      }
      this.#markers.delete(name);
      for (let node = this; node; node = node.parentNode) {
        --node.#subtreeMarkerCount;
      }
      for (let node = this; node; node = node.parentNode) {
        this.#domModelInternal.dispatchEventToListeners("MarkersChanged", node);
      }
      return;
    }
    if (this.parentNode && !this.#markers.has(name)) {
      for (let node = this; node; node = node.parentNode) {
        ++node.#subtreeMarkerCount;
      }
    }
    this.#markers.set(name, value);
    for (let node = this; node; node = node.parentNode) {
      this.#domModelInternal.dispatchEventToListeners("MarkersChanged", node);
    }
  }
  marker(name) {
    return this.#markers.get(name) || null;
  }
  getMarkerKeysForTest() {
    return [...this.#markers.keys()];
  }
  traverseMarkers(visitor) {
    function traverse(node) {
      if (!node.#subtreeMarkerCount) {
        return;
      }
      for (const marker of node.#markers.keys()) {
        visitor(node, marker);
      }
      if (!node.childrenInternal) {
        return;
      }
      for (const child of node.childrenInternal) {
        traverse(child);
      }
    }
    traverse(this);
  }
  resolveURL(url) {
    if (!url) {
      return url;
    }
    for (let frameOwnerCandidate = this; frameOwnerCandidate; frameOwnerCandidate = frameOwnerCandidate.parentNode) {
      if (frameOwnerCandidate instanceof DOMDocument && frameOwnerCandidate.baseURL) {
        return Common20.ParsedURL.ParsedURL.completeURL(frameOwnerCandidate.baseURL, url);
      }
    }
    return null;
  }
  highlight(mode) {
    this.#domModelInternal.overlayModel().highlightInOverlay({ node: this, selectorList: void 0 }, mode);
  }
  highlightForTwoSeconds() {
    this.#domModelInternal.overlayModel().highlightInOverlayForTwoSeconds({ node: this, selectorList: void 0 });
  }
  async resolveToObject(objectGroup, executionContextId) {
    const { object } = await this.#agent.invoke_resolveNode(
      { nodeId: this.id, backendNodeId: void 0, executionContextId, objectGroup }
    );
    return object && this.#domModelInternal.runtimeModelInternal.createRemoteObject(object) || null;
  }
  async boxModel() {
    const { model } = await this.#agent.invoke_getBoxModel({ nodeId: this.id });
    return model;
  }
  async setAsInspectedNode() {
    let node = this;
    if (node && node.pseudoType()) {
      node = node.parentNode;
    }
    while (node) {
      let ancestor = node.ancestorUserAgentShadowRoot();
      if (!ancestor) {
        break;
      }
      ancestor = node.ancestorShadowHost();
      if (!ancestor) {
        break;
      }
      node = ancestor;
    }
    if (!node) {
      throw new Error("In DOMNode.setAsInspectedNode: node is expected to not be null.");
    }
    await this.#agent.invoke_setInspectedNode({ nodeId: node.id });
  }
  enclosingElementOrSelf() {
    let node = this;
    if (node && node.nodeType() === Node.TEXT_NODE && node.parentNode) {
      node = node.parentNode;
    }
    if (node && node.nodeType() !== Node.ELEMENT_NODE) {
      node = null;
    }
    return node;
  }
  async callFunction(fn, args = []) {
    const object = await this.resolveToObject();
    if (!object) {
      return null;
    }
    const result = await object.callFunction(fn, args.map((arg) => RemoteObject.toCallArgument(arg)));
    object.release();
    if (result.wasThrown || !result.object) {
      return null;
    }
    return {
      value: result.object.value
    };
  }
  async scrollIntoView() {
    const node = this.enclosingElementOrSelf();
    if (!node) {
      return;
    }
    const result = await node.callFunction(scrollIntoViewInPage);
    if (!result) {
      return;
    }
    node.highlightForTwoSeconds();
    function scrollIntoViewInPage() {
      this.scrollIntoViewIfNeeded(true);
    }
  }
  async focus() {
    const node = this.enclosingElementOrSelf();
    if (!node) {
      throw new Error("DOMNode.focus expects node to not be null.");
    }
    const result = await node.callFunction(focusInPage);
    if (!result) {
      return;
    }
    node.highlightForTwoSeconds();
    await this.#domModelInternal.target().pageAgent().invoke_bringToFront();
    function focusInPage() {
      this.focus();
    }
  }
  simpleSelector() {
    const lowerCaseName = this.localName() || this.nodeName().toLowerCase();
    if (this.nodeType() !== Node.ELEMENT_NODE) {
      return lowerCaseName;
    }
    const type = this.getAttribute("type");
    const id = this.getAttribute("id");
    const classes = this.getAttribute("class");
    if (lowerCaseName === "input" && type && !id && !classes) {
      return lowerCaseName + '[type="' + CSS.escape(type) + '"]';
    }
    if (id) {
      return lowerCaseName + "#" + CSS.escape(id);
    }
    if (classes) {
      const classList = classes.trim().split(/\s+/g);
      return (lowerCaseName === "div" ? "" : lowerCaseName) + "." + classList.map((cls) => CSS.escape(cls)).join(".");
    }
    if (this.pseudoIdentifier()) {
      return `${lowerCaseName}(${this.pseudoIdentifier()})`;
    }
    return lowerCaseName;
  }
  async getAnchorBySpecifier(specifier) {
    const response = await this.#agent.invoke_getAnchorElement({
      nodeId: this.id,
      anchorSpecifier: specifier
    });
    if (response.getError()) {
      return null;
    }
    return this.domModel().nodeForId(response.nodeId);
  }
};
((DOMNode2) => {
  let ShadowRootTypes;
  ((ShadowRootTypes2) => {
    ShadowRootTypes2["UserAgent"] = "user-agent";
    ShadowRootTypes2["Open"] = "open";
    ShadowRootTypes2["Closed"] = "closed";
  })(ShadowRootTypes = DOMNode2.ShadowRootTypes || (DOMNode2.ShadowRootTypes = {}));
})(DOMNode || (DOMNode = {}));
var DeferredDOMNode = class {
  #domModelInternal;
  #backendNodeIdInternal;
  constructor(target, backendNodeId) {
    this.#domModelInternal = target.model(DOMModel);
    this.#backendNodeIdInternal = backendNodeId;
  }
  resolve(callback) {
    void this.resolvePromise().then(callback);
  }
  async resolvePromise() {
    const nodeIds = await this.#domModelInternal.pushNodesByBackendIdsToFrontend(/* @__PURE__ */ new Set([this.#backendNodeIdInternal]));
    return nodeIds && nodeIds.get(this.#backendNodeIdInternal) || null;
  }
  backendNodeId() {
    return this.#backendNodeIdInternal;
  }
  domModel() {
    return this.#domModelInternal;
  }
  highlight() {
    this.#domModelInternal.overlayModel().highlightInOverlay({ deferredNode: this, selectorList: void 0 });
  }
};
var DOMNodeShortcut = class {
  nodeType;
  nodeName;
  deferredNode;
  constructor(target, backendNodeId, nodeType, nodeName) {
    this.nodeType = nodeType;
    this.nodeName = nodeName;
    this.deferredNode = new DeferredDOMNode(target, backendNodeId);
  }
};
var DOMDocument = class extends DOMNode {
  body;
  documentElement;
  documentURL;
  baseURL;
  constructor(domModel, payload) {
    super(domModel);
    this.body = null;
    this.documentElement = null;
    this.init(this, false, payload);
    this.documentURL = payload.documentURL || "";
    this.baseURL = payload.baseURL || "";
  }
};
var DOMModel = class _DOMModel extends SDKModel {
  agent;
  idToDOMNode = /* @__PURE__ */ new Map();
  #document;
  #attributeLoadNodeIds;
  runtimeModelInternal;
  #lastMutationId;
  #pendingDocumentRequestPromise;
  #frameOwnerNode;
  #loadNodeAttributesTimeout;
  #searchId;
  constructor(target) {
    super(target);
    this.agent = target.domAgent();
    this.#document = null;
    this.#attributeLoadNodeIds = /* @__PURE__ */ new Set();
    target.registerDOMDispatcher(new DOMDispatcher(this));
    this.runtimeModelInternal = target.model(RuntimeModel);
    this.#pendingDocumentRequestPromise = null;
    if (!target.suspended()) {
      void this.agent.invoke_enable({});
    }
    if (Root6.Runtime.experiments.isEnabled("capture-node-creation-stacks")) {
      void this.agent.invoke_setNodeStackTracesEnabled({ enable: true });
    }
  }
  runtimeModel() {
    return this.runtimeModelInternal;
  }
  cssModel() {
    return this.target().model(CSSModel);
  }
  overlayModel() {
    return this.target().model(OverlayModel);
  }
  static cancelSearch() {
    for (const domModel of TargetManager.instance().models(_DOMModel)) {
      domModel.cancelSearch();
    }
  }
  scheduleMutationEvent(node) {
    if (!this.hasEventListeners(
      "DOMMutated"
      /* DOMMutated */
    )) {
      return;
    }
    this.#lastMutationId = (this.#lastMutationId || 0) + 1;
    void Promise.resolve().then(callObserve.bind(this, node, this.#lastMutationId));
    function callObserve(node2, mutationId) {
      if (!this.hasEventListeners(
        "DOMMutated"
        /* DOMMutated */
      ) || this.#lastMutationId !== mutationId) {
        return;
      }
      this.dispatchEventToListeners("DOMMutated", node2);
    }
  }
  requestDocument() {
    if (this.#document) {
      return Promise.resolve(this.#document);
    }
    if (!this.#pendingDocumentRequestPromise) {
      this.#pendingDocumentRequestPromise = this.requestDocumentInternal();
    }
    return this.#pendingDocumentRequestPromise;
  }
  async getOwnerNodeForFrame(frameId) {
    const response = await this.agent.invoke_getFrameOwner({ frameId });
    if (response.getError()) {
      return null;
    }
    return new DeferredDOMNode(this.target(), response.backendNodeId);
  }
  async requestDocumentInternal() {
    const response = await this.agent.invoke_getDocument({});
    if (response.getError()) {
      return null;
    }
    const { root: documentPayload } = response;
    this.#pendingDocumentRequestPromise = null;
    if (documentPayload) {
      this.setDocument(documentPayload);
    }
    if (!this.#document) {
      console.error("No document");
      return null;
    }
    const parentModel = this.parentModel();
    if (parentModel && !this.#frameOwnerNode) {
      await parentModel.requestDocument();
      const mainFrame = this.target().model(ResourceTreeModel)?.mainFrame;
      if (mainFrame) {
        const response2 = await parentModel.agent.invoke_getFrameOwner({ frameId: mainFrame.id });
        if (!response2.getError() && response2.nodeId) {
          this.#frameOwnerNode = parentModel.nodeForId(response2.nodeId);
        }
      }
    }
    if (this.#frameOwnerNode) {
      const oldDocument = this.#frameOwnerNode.contentDocument();
      this.#frameOwnerNode.setContentDocument(this.#document);
      this.#frameOwnerNode.setChildren([]);
      if (this.#document) {
        this.#document.parentNode = this.#frameOwnerNode;
        this.dispatchEventToListeners("NodeInserted", this.#document);
      } else if (oldDocument) {
        this.dispatchEventToListeners("NodeRemoved", { node: oldDocument, parent: this.#frameOwnerNode });
      }
    }
    return this.#document;
  }
  existingDocument() {
    return this.#document;
  }
  async pushNodeToFrontend(objectId) {
    await this.requestDocument();
    const { nodeId } = await this.agent.invoke_requestNode({ objectId });
    return nodeId ? this.nodeForId(nodeId) : null;
  }
  pushNodeByPathToFrontend(path) {
    return this.requestDocument().then(() => this.agent.invoke_pushNodeByPathToFrontend({ path })).then(({ nodeId }) => nodeId);
  }
  async pushNodesByBackendIdsToFrontend(backendNodeIds) {
    await this.requestDocument();
    const backendNodeIdsArray = [...backendNodeIds];
    const { nodeIds } = await this.agent.invoke_pushNodesByBackendIdsToFrontend({ backendNodeIds: backendNodeIdsArray });
    if (!nodeIds) {
      return null;
    }
    const map = /* @__PURE__ */ new Map();
    for (let i = 0; i < nodeIds.length; ++i) {
      if (nodeIds[i]) {
        map.set(backendNodeIdsArray[i], this.nodeForId(nodeIds[i]));
      }
    }
    return map;
  }
  attributeModified(nodeId, name, value) {
    const node = this.idToDOMNode.get(nodeId);
    if (!node) {
      return;
    }
    node.setAttributeInternal(name, value);
    this.dispatchEventToListeners("AttrModified", { node, name });
    this.scheduleMutationEvent(node);
  }
  attributeRemoved(nodeId, name) {
    const node = this.idToDOMNode.get(nodeId);
    if (!node) {
      return;
    }
    node.removeAttributeInternal(name);
    this.dispatchEventToListeners("AttrRemoved", { node, name });
    this.scheduleMutationEvent(node);
  }
  inlineStyleInvalidated(nodeIds) {
    nodeIds.forEach((nodeId) => this.#attributeLoadNodeIds.add(nodeId));
    if (!this.#loadNodeAttributesTimeout) {
      this.#loadNodeAttributesTimeout = window.setTimeout(this.loadNodeAttributes.bind(this), 20);
    }
  }
  loadNodeAttributes() {
    this.#loadNodeAttributesTimeout = void 0;
    for (const nodeId of this.#attributeLoadNodeIds) {
      void this.agent.invoke_getAttributes({ nodeId }).then(({ attributes }) => {
        if (!attributes) {
          return;
        }
        const node = this.idToDOMNode.get(nodeId);
        if (!node) {
          return;
        }
        if (node.setAttributesPayload(attributes)) {
          this.dispatchEventToListeners("AttrModified", { node, name: "style" });
          this.scheduleMutationEvent(node);
        }
      });
    }
    this.#attributeLoadNodeIds.clear();
  }
  characterDataModified(nodeId, newValue) {
    const node = this.idToDOMNode.get(nodeId);
    if (!node) {
      console.error("nodeId could not be resolved to a node");
      return;
    }
    node.setNodeValueInternal(newValue);
    this.dispatchEventToListeners("CharacterDataModified", node);
    this.scheduleMutationEvent(node);
  }
  nodeForId(nodeId) {
    return nodeId ? this.idToDOMNode.get(nodeId) || null : null;
  }
  documentUpdated() {
    const alreadyHasDocument = Boolean(this.#document);
    this.setDocument(null);
    if (this.parentModel() && alreadyHasDocument && !this.#pendingDocumentRequestPromise) {
      void this.requestDocument();
    }
  }
  setDocument(payload) {
    this.idToDOMNode = /* @__PURE__ */ new Map();
    if (payload && "nodeId" in payload) {
      this.#document = new DOMDocument(this, payload);
    } else {
      this.#document = null;
    }
    DOMModelUndoStack.instance().dispose(this);
    if (!this.parentModel()) {
      this.dispatchEventToListeners("DocumentUpdated", this);
    }
  }
  setDocumentForTest(document2) {
    this.setDocument(document2);
  }
  setDetachedRoot(payload) {
    if (payload.nodeName === "#document") {
      new DOMDocument(this, payload);
    } else {
      DOMNode.create(this, null, false, payload);
    }
  }
  setChildNodes(parentId, payloads) {
    if (!parentId && payloads.length) {
      this.setDetachedRoot(payloads[0]);
      return;
    }
    const parent = this.idToDOMNode.get(parentId);
    parent?.setChildrenPayload(payloads);
  }
  childNodeCountUpdated(nodeId, newValue) {
    const node = this.idToDOMNode.get(nodeId);
    if (!node) {
      console.error("nodeId could not be resolved to a node");
      return;
    }
    node.setChildNodeCount(newValue);
    this.dispatchEventToListeners("ChildNodeCountUpdated", node);
    this.scheduleMutationEvent(node);
  }
  childNodeInserted(parentId, prevId, payload) {
    const parent = this.idToDOMNode.get(parentId);
    const prev = this.idToDOMNode.get(prevId);
    if (!parent) {
      console.error("parentId could not be resolved to a node");
      return;
    }
    const node = parent.insertChild(prev, payload);
    this.idToDOMNode.set(node.id, node);
    this.dispatchEventToListeners("NodeInserted", node);
    this.scheduleMutationEvent(node);
  }
  childNodeRemoved(parentId, nodeId) {
    const parent = this.idToDOMNode.get(parentId);
    const node = this.idToDOMNode.get(nodeId);
    if (!parent || !node) {
      console.error("parentId or nodeId could not be resolved to a node");
      return;
    }
    parent.removeChild(node);
    this.unbind(node);
    this.dispatchEventToListeners("NodeRemoved", { node, parent });
    this.scheduleMutationEvent(node);
  }
  shadowRootPushed(hostId, root) {
    const host = this.idToDOMNode.get(hostId);
    if (!host) {
      return;
    }
    const node = DOMNode.create(this, host.ownerDocument, true, root);
    node.parentNode = host;
    this.idToDOMNode.set(node.id, node);
    host.shadowRootsInternal.unshift(node);
    this.dispatchEventToListeners("NodeInserted", node);
    this.scheduleMutationEvent(node);
  }
  shadowRootPopped(hostId, rootId) {
    const host = this.idToDOMNode.get(hostId);
    if (!host) {
      return;
    }
    const root = this.idToDOMNode.get(rootId);
    if (!root) {
      return;
    }
    host.removeChild(root);
    this.unbind(root);
    this.dispatchEventToListeners("NodeRemoved", { node: root, parent: host });
    this.scheduleMutationEvent(root);
  }
  pseudoElementAdded(parentId, pseudoElement) {
    const parent = this.idToDOMNode.get(parentId);
    if (!parent) {
      return;
    }
    const node = DOMNode.create(this, parent.ownerDocument, false, pseudoElement);
    node.parentNode = parent;
    this.idToDOMNode.set(node.id, node);
    const pseudoType = node.pseudoType();
    if (!pseudoType) {
      throw new Error("DOMModel._pseudoElementAdded expects pseudoType to be defined.");
    }
    const currentPseudoElements = parent.pseudoElements().get(pseudoType);
    if (currentPseudoElements) {
      if (!pseudoType.startsWith("view-transition")) {
        throw new Error(
          "DOMModel.pseudoElementAdded expects parent to not already have this pseudo type added; only view-transition* pseudo elements can coexist under the same parent."
        );
      }
      currentPseudoElements.push(node);
    } else {
      parent.pseudoElements().set(pseudoType, [node]);
    }
    this.dispatchEventToListeners("NodeInserted", node);
    this.scheduleMutationEvent(node);
  }
  scrollableFlagUpdated(nodeId, isScrollable) {
    const node = this.nodeForId(nodeId);
    if (!node || node.isScrollable() === isScrollable) {
      return;
    }
    node.setIsScrollable(isScrollable);
    this.dispatchEventToListeners("ScrollableFlagUpdated", { node });
  }
  topLayerElementsUpdated() {
    this.dispatchEventToListeners(
      "TopLayerElementsChanged"
      /* TopLayerElementsChanged */
    );
  }
  pseudoElementRemoved(parentId, pseudoElementId) {
    const parent = this.idToDOMNode.get(parentId);
    if (!parent) {
      return;
    }
    const pseudoElement = this.idToDOMNode.get(pseudoElementId);
    if (!pseudoElement) {
      return;
    }
    parent.removeChild(pseudoElement);
    this.unbind(pseudoElement);
    this.dispatchEventToListeners("NodeRemoved", { node: pseudoElement, parent });
    this.scheduleMutationEvent(pseudoElement);
  }
  distributedNodesUpdated(insertionPointId, distributedNodes) {
    const insertionPoint = this.idToDOMNode.get(insertionPointId);
    if (!insertionPoint) {
      return;
    }
    insertionPoint.setDistributedNodePayloads(distributedNodes);
    this.dispatchEventToListeners("DistributedNodesChanged", insertionPoint);
    this.scheduleMutationEvent(insertionPoint);
  }
  unbind(node) {
    this.idToDOMNode.delete(node.id);
    const children = node.children();
    for (let i = 0; children && i < children.length; ++i) {
      this.unbind(children[i]);
    }
    for (let i = 0; i < node.shadowRootsInternal.length; ++i) {
      this.unbind(node.shadowRootsInternal[i]);
    }
    const pseudoElements = node.pseudoElements();
    for (const value of pseudoElements.values()) {
      for (const pseudoElement of value) {
        this.unbind(pseudoElement);
      }
    }
    const templateContent = node.templateContent();
    if (templateContent) {
      this.unbind(templateContent);
    }
  }
  async getNodesByStyle(computedStyles, pierce = false) {
    await this.requestDocument();
    if (!this.#document) {
      throw new Error("DOMModel.getNodesByStyle expects to have a document.");
    }
    const response = await this.agent.invoke_getNodesForSubtreeByStyle({ nodeId: this.#document.id, computedStyles, pierce });
    if (response.getError()) {
      throw response.getError();
    }
    return response.nodeIds;
  }
  async performSearch(query, includeUserAgentShadowDOM) {
    const response = await this.agent.invoke_performSearch({ query, includeUserAgentShadowDOM });
    if (!response.getError()) {
      this.#searchId = response.searchId;
    }
    return response.getError() ? 0 : response.resultCount;
  }
  async searchResult(index) {
    if (!this.#searchId) {
      return null;
    }
    const { nodeIds } = await this.agent.invoke_getSearchResults({ searchId: this.#searchId, fromIndex: index, toIndex: index + 1 });
    return nodeIds && nodeIds.length === 1 ? this.nodeForId(nodeIds[0]) : null;
  }
  cancelSearch() {
    if (!this.#searchId) {
      return;
    }
    void this.agent.invoke_discardSearchResults({ searchId: this.#searchId });
    this.#searchId = void 0;
  }
  classNamesPromise(nodeId) {
    return this.agent.invoke_collectClassNamesFromSubtree({ nodeId }).then(({ classNames }) => classNames || []);
  }
  querySelector(nodeId, selector) {
    return this.agent.invoke_querySelector({ nodeId, selector }).then(({ nodeId: nodeId2 }) => nodeId2);
  }
  querySelectorAll(nodeId, selector) {
    return this.agent.invoke_querySelectorAll({ nodeId, selector }).then(({ nodeIds }) => nodeIds);
  }
  getTopLayerElements() {
    return this.agent.invoke_getTopLayerElements().then(({ nodeIds }) => nodeIds);
  }
  getDetachedDOMNodes() {
    return this.agent.invoke_getDetachedDomNodes().then(({ detachedNodes }) => detachedNodes);
  }
  getElementByRelation(nodeId, relation) {
    return this.agent.invoke_getElementByRelation({ nodeId, relation }).then(({ nodeId: nodeId2 }) => nodeId2);
  }
  markUndoableState(minorChange) {
    void DOMModelUndoStack.instance().markUndoableState(this, minorChange || false);
  }
  async nodeForLocation(x, y, includeUserAgentShadowDOM) {
    const response = await this.agent.invoke_getNodeForLocation({ x, y, includeUserAgentShadowDOM });
    if (response.getError() || !response.nodeId) {
      return null;
    }
    return this.nodeForId(response.nodeId);
  }
  async getContainerForNode(nodeId, containerName, physicalAxes, logicalAxes, queriesScrollState) {
    const { nodeId: containerNodeId } = await this.agent.invoke_getContainerForNode(
      { nodeId, containerName, physicalAxes, logicalAxes, queriesScrollState }
    );
    if (!containerNodeId) {
      return null;
    }
    return this.nodeForId(containerNodeId);
  }
  pushObjectAsNodeToFrontend(object) {
    return object.isNode() && object.objectId ? this.pushNodeToFrontend(object.objectId) : Promise.resolve(null);
  }
  suspendModel() {
    return this.agent.invoke_disable().then(() => this.setDocument(null));
  }
  async resumeModel() {
    await this.agent.invoke_enable({});
  }
  dispose() {
    DOMModelUndoStack.instance().dispose(this);
  }
  parentModel() {
    const parentTarget = this.target().parentTarget();
    return parentTarget ? parentTarget.model(_DOMModel) : null;
  }
  getAgent() {
    return this.agent;
  }
  registerNode(node) {
    this.idToDOMNode.set(node.id, node);
  }
};
var Events12 = /* @__PURE__ */ ((Events210) => {
  Events210["AttrModified"] = "AttrModified";
  Events210["AttrRemoved"] = "AttrRemoved";
  Events210["CharacterDataModified"] = "CharacterDataModified";
  Events210["DOMMutated"] = "DOMMutated";
  Events210["NodeInserted"] = "NodeInserted";
  Events210["NodeRemoved"] = "NodeRemoved";
  Events210["DocumentUpdated"] = "DocumentUpdated";
  Events210["ChildNodeCountUpdated"] = "ChildNodeCountUpdated";
  Events210["DistributedNodesChanged"] = "DistributedNodesChanged";
  Events210["MarkersChanged"] = "MarkersChanged";
  Events210["TopLayerElementsChanged"] = "TopLayerElementsChanged";
  Events210["ScrollableFlagUpdated"] = "ScrollableFlagUpdated";
  return Events210;
})(Events12 || {});
var DOMDispatcher = class {
  #domModel;
  constructor(domModel) {
    this.#domModel = domModel;
  }
  documentUpdated() {
    this.#domModel.documentUpdated();
  }
  attributeModified({ nodeId, name, value }) {
    this.#domModel.attributeModified(nodeId, name, value);
  }
  attributeRemoved({ nodeId, name }) {
    this.#domModel.attributeRemoved(nodeId, name);
  }
  inlineStyleInvalidated({ nodeIds }) {
    this.#domModel.inlineStyleInvalidated(nodeIds);
  }
  characterDataModified({ nodeId, characterData }) {
    this.#domModel.characterDataModified(nodeId, characterData);
  }
  setChildNodes({ parentId, nodes }) {
    this.#domModel.setChildNodes(parentId, nodes);
  }
  childNodeCountUpdated({ nodeId, childNodeCount }) {
    this.#domModel.childNodeCountUpdated(nodeId, childNodeCount);
  }
  childNodeInserted({ parentNodeId, previousNodeId, node }) {
    this.#domModel.childNodeInserted(parentNodeId, previousNodeId, node);
  }
  childNodeRemoved({ parentNodeId, nodeId }) {
    this.#domModel.childNodeRemoved(parentNodeId, nodeId);
  }
  shadowRootPushed({ hostId, root }) {
    this.#domModel.shadowRootPushed(hostId, root);
  }
  shadowRootPopped({ hostId, rootId }) {
    this.#domModel.shadowRootPopped(hostId, rootId);
  }
  pseudoElementAdded({ parentId, pseudoElement }) {
    this.#domModel.pseudoElementAdded(parentId, pseudoElement);
  }
  pseudoElementRemoved({ parentId, pseudoElementId }) {
    this.#domModel.pseudoElementRemoved(parentId, pseudoElementId);
  }
  distributedNodesUpdated({ insertionPointId, distributedNodes }) {
    this.#domModel.distributedNodesUpdated(insertionPointId, distributedNodes);
  }
  topLayerElementsUpdated() {
    this.#domModel.topLayerElementsUpdated();
  }
  scrollableFlagUpdated({ nodeId, isScrollable }) {
    this.#domModel.scrollableFlagUpdated(nodeId, isScrollable);
  }
};
var domModelUndoStackInstance = null;
var DOMModelUndoStack = class _DOMModelUndoStack {
  #stack;
  #index;
  #lastModelWithMinorChange;
  constructor() {
    this.#stack = [];
    this.#index = 0;
    this.#lastModelWithMinorChange = null;
  }
  static instance(opts = { forceNew: null }) {
    const { forceNew } = opts;
    if (!domModelUndoStackInstance || forceNew) {
      domModelUndoStackInstance = new _DOMModelUndoStack();
    }
    return domModelUndoStackInstance;
  }
  async markUndoableState(model, minorChange) {
    if (this.#lastModelWithMinorChange && model !== this.#lastModelWithMinorChange) {
      this.#lastModelWithMinorChange.markUndoableState();
      this.#lastModelWithMinorChange = null;
    }
    if (minorChange && this.#lastModelWithMinorChange === model) {
      return;
    }
    this.#stack = this.#stack.slice(0, this.#index);
    this.#stack.push(model);
    this.#index = this.#stack.length;
    if (minorChange) {
      this.#lastModelWithMinorChange = model;
    } else {
      await model.getAgent().invoke_markUndoableState();
      this.#lastModelWithMinorChange = null;
    }
  }
  async undo() {
    if (this.#index === 0) {
      return Promise.resolve();
    }
    --this.#index;
    this.#lastModelWithMinorChange = null;
    await this.#stack[this.#index].getAgent().invoke_undo();
  }
  async redo() {
    if (this.#index >= this.#stack.length) {
      return Promise.resolve();
    }
    ++this.#index;
    this.#lastModelWithMinorChange = null;
    await this.#stack[this.#index - 1].getAgent().invoke_redo();
  }
  dispose(model) {
    let shift = 0;
    for (let i = 0; i < this.#index; ++i) {
      if (this.#stack[i] === model) {
        ++shift;
      }
    }
    Platform14.ArrayUtilities.removeElement(this.#stack, model);
    this.#index -= shift;
    if (this.#lastModelWithMinorChange === model) {
      this.#lastModelWithMinorChange = null;
    }
  }
};
SDKModel.register(DOMModel, { capabilities: Capability.DOM, autostart: true });

// gen/front_end/core/sdk/Resource.js
var Resource_exports = {};
__export(Resource_exports, {
  Resource: () => Resource
});
import * as TextUtils18 from "./../../models/text_utils/text_utils.js";
import * as Common21 from "./../common/common.js";
import * as Platform15 from "./../platform/platform.js";
var Resource = class {
  #resourceTreeModel;
  #requestInternal;
  #urlInternal;
  #documentURLInternal;
  #frameIdInternal;
  #loaderIdInternal;
  #type;
  #mimeTypeInternal;
  #isGeneratedInternal;
  #lastModifiedInternal;
  #contentSizeInternal;
  #parsedURLInternal;
  #contentData = null;
  /**
   * There is always at most one CDP "getResourceContent" call in-flight. But once it's done
   * we'll hit the backend again in case we failed.
   */
  #pendingContentData = null;
  constructor(resourceTreeModel, request, url, documentURL, frameId, loaderId, type, mimeType, lastModified, contentSize) {
    this.#resourceTreeModel = resourceTreeModel;
    this.#requestInternal = request;
    this.url = url;
    this.#documentURLInternal = documentURL;
    this.#frameIdInternal = frameId;
    this.#loaderIdInternal = loaderId;
    this.#type = type || Common21.ResourceType.resourceTypes.Other;
    this.#mimeTypeInternal = mimeType;
    this.#isGeneratedInternal = false;
    this.#lastModifiedInternal = lastModified && Platform15.DateUtilities.isValid(lastModified) ? lastModified : null;
    this.#contentSizeInternal = contentSize;
  }
  lastModified() {
    if (this.#lastModifiedInternal || !this.#requestInternal) {
      return this.#lastModifiedInternal;
    }
    const lastModifiedHeader = this.#requestInternal.responseLastModified();
    const date = lastModifiedHeader ? new Date(lastModifiedHeader) : null;
    this.#lastModifiedInternal = date && Platform15.DateUtilities.isValid(date) ? date : null;
    return this.#lastModifiedInternal;
  }
  contentSize() {
    if (typeof this.#contentSizeInternal === "number" || !this.#requestInternal) {
      return this.#contentSizeInternal;
    }
    return this.#requestInternal.resourceSize;
  }
  get request() {
    return this.#requestInternal;
  }
  get url() {
    return this.#urlInternal;
  }
  set url(x) {
    this.#urlInternal = x;
    this.#parsedURLInternal = new Common21.ParsedURL.ParsedURL(x);
  }
  get parsedURL() {
    return this.#parsedURLInternal;
  }
  get documentURL() {
    return this.#documentURLInternal;
  }
  get frameId() {
    return this.#frameIdInternal;
  }
  get loaderId() {
    return this.#loaderIdInternal;
  }
  get displayName() {
    return this.#parsedURLInternal ? this.#parsedURLInternal.displayName : "";
  }
  resourceType() {
    return this.#requestInternal ? this.#requestInternal.resourceType() : this.#type;
  }
  get mimeType() {
    return this.#requestInternal ? this.#requestInternal.mimeType : this.#mimeTypeInternal;
  }
  get content() {
    if (this.#contentData?.isTextContent) {
      return this.#contentData.text;
    }
    return this.#contentData?.base64 ?? null;
  }
  get isGenerated() {
    return this.#isGeneratedInternal;
  }
  set isGenerated(val) {
    this.#isGeneratedInternal = val;
  }
  contentURL() {
    return this.#urlInternal;
  }
  contentType() {
    if (this.resourceType() === Common21.ResourceType.resourceTypes.Document && this.mimeType.indexOf("javascript") !== -1) {
      return Common21.ResourceType.resourceTypes.Script;
    }
    return this.resourceType();
  }
  async requestContent() {
    const contentData = await this.requestContentData();
    return TextUtils18.ContentData.ContentData.asDeferredContent(contentData);
  }
  async requestContentData() {
    if (this.#contentData) {
      return this.#contentData;
    }
    if (this.#pendingContentData) {
      return this.#pendingContentData;
    }
    this.#pendingContentData = this.innerRequestContent().then((contentData) => {
      if (!TextUtils18.ContentData.ContentData.isError(contentData)) {
        this.#contentData = contentData;
      }
      this.#pendingContentData = null;
      return contentData;
    });
    return this.#pendingContentData;
  }
  canonicalMimeType() {
    return this.contentType().canonicalMimeType() || this.mimeType;
  }
  async searchInContent(query, caseSensitive, isRegex) {
    if (!this.frameId) {
      return [];
    }
    if (this.request) {
      return this.request.searchInContent(query, caseSensitive, isRegex);
    }
    const result = await this.#resourceTreeModel.target().pageAgent().invoke_searchInResource(
      { frameId: this.frameId, url: this.url, query, caseSensitive, isRegex }
    );
    return TextUtils18.TextUtils.performSearchInSearchMatches(result.result || [], query, caseSensitive, isRegex);
  }
  async populateImageSource(image) {
    const contentData = await this.requestContentData();
    if (TextUtils18.ContentData.ContentData.isError(contentData)) {
      return;
    }
    image.src = contentData.asDataUrl() ?? this.#urlInternal;
  }
  async innerRequestContent() {
    if (this.request) {
      return this.request.requestContentData();
    }
    const response = await this.#resourceTreeModel.target().pageAgent().invoke_getResourceContent(
      { frameId: this.frameId, url: this.url }
    );
    const error = response.getError();
    if (error) {
      return { error };
    }
    return new TextUtils18.ContentData.ContentData(response.content, response.base64Encoded, this.mimeType);
  }
  hasTextContent() {
    if (this.#contentData?.isTextContent) {
      return true;
    }
    return this.#type.isTextType() || Platform15.MimeType.isTextType(this.mimeType);
  }
  frame() {
    return this.#frameIdInternal ? this.#resourceTreeModel.frameForId(this.#frameIdInternal) : null;
  }
  statusCode() {
    return this.#requestInternal ? this.#requestInternal.statusCode : 0;
  }
};

// gen/front_end/core/sdk/SecurityOriginManager.js
var SecurityOriginManager_exports = {};
__export(SecurityOriginManager_exports, {
  Events: () => Events14,
  SecurityOriginManager: () => SecurityOriginManager
});
var SecurityOriginManager = class extends SDKModel {
  #mainSecurityOriginInternal;
  #unreachableMainSecurityOriginInternal;
  #securityOriginsInternal;
  constructor(target) {
    super(target);
    this.#mainSecurityOriginInternal = "";
    this.#unreachableMainSecurityOriginInternal = "";
    this.#securityOriginsInternal = /* @__PURE__ */ new Set();
  }
  updateSecurityOrigins(securityOrigins) {
    const oldOrigins = this.#securityOriginsInternal;
    this.#securityOriginsInternal = securityOrigins;
    for (const origin of oldOrigins) {
      if (!this.#securityOriginsInternal.has(origin)) {
        this.dispatchEventToListeners("SecurityOriginRemoved", origin);
      }
    }
    for (const origin of this.#securityOriginsInternal) {
      if (!oldOrigins.has(origin)) {
        this.dispatchEventToListeners("SecurityOriginAdded", origin);
      }
    }
  }
  securityOrigins() {
    return [...this.#securityOriginsInternal];
  }
  mainSecurityOrigin() {
    return this.#mainSecurityOriginInternal;
  }
  unreachableMainSecurityOrigin() {
    return this.#unreachableMainSecurityOriginInternal;
  }
  setMainSecurityOrigin(securityOrigin, unreachableSecurityOrigin) {
    this.#mainSecurityOriginInternal = securityOrigin;
    this.#unreachableMainSecurityOriginInternal = unreachableSecurityOrigin || null;
    this.dispatchEventToListeners("MainSecurityOriginChanged", {
      mainSecurityOrigin: this.#mainSecurityOriginInternal,
      unreachableMainSecurityOrigin: this.#unreachableMainSecurityOriginInternal
    });
  }
};
var Events14 = /* @__PURE__ */ ((Events210) => {
  Events210["SecurityOriginAdded"] = "SecurityOriginAdded";
  Events210["SecurityOriginRemoved"] = "SecurityOriginRemoved";
  Events210["MainSecurityOriginChanged"] = "MainSecurityOriginChanged";
  return Events210;
})(Events14 || {});
SDKModel.register(SecurityOriginManager, { capabilities: Capability.NONE, autostart: false });

// gen/front_end/core/sdk/StorageKeyManager.js
var StorageKeyManager_exports = {};
__export(StorageKeyManager_exports, {
  Events: () => Events15,
  StorageKeyComponent: () => StorageKeyComponent,
  StorageKeyManager: () => StorageKeyManager,
  parseStorageKey: () => parseStorageKey
});
import * as Common22 from "./../common/common.js";
var StorageKeyManager = class extends SDKModel {
  #mainStorageKeyInternal;
  #storageKeysInternal;
  constructor(target) {
    super(target);
    this.#mainStorageKeyInternal = "";
    this.#storageKeysInternal = /* @__PURE__ */ new Set();
  }
  updateStorageKeys(storageKeys) {
    const oldStorageKeys = this.#storageKeysInternal;
    this.#storageKeysInternal = storageKeys;
    for (const storageKey of oldStorageKeys) {
      if (!this.#storageKeysInternal.has(storageKey)) {
        this.dispatchEventToListeners("StorageKeyRemoved", storageKey);
      }
    }
    for (const storageKey of this.#storageKeysInternal) {
      if (!oldStorageKeys.has(storageKey)) {
        this.dispatchEventToListeners("StorageKeyAdded", storageKey);
      }
    }
  }
  storageKeys() {
    return [...this.#storageKeysInternal];
  }
  mainStorageKey() {
    return this.#mainStorageKeyInternal;
  }
  setMainStorageKey(storageKey) {
    this.#mainStorageKeyInternal = storageKey;
    this.dispatchEventToListeners("MainStorageKeyChanged", {
      mainStorageKey: this.#mainStorageKeyInternal
    });
  }
};
function parseStorageKey(storageKeyString) {
  const components = storageKeyString.split("^");
  const origin = Common22.ParsedURL.ParsedURL.extractOrigin(components[0]);
  const storageKey = { origin, components: /* @__PURE__ */ new Map() };
  for (let i = 1; i < components.length; ++i) {
    storageKey.components.set(components[i].charAt(0), components[i].substring(1));
  }
  return storageKey;
}
var StorageKeyComponent = /* @__PURE__ */ ((StorageKeyComponent2) => {
  StorageKeyComponent2["TOP_LEVEL_SITE"] = "0";
  StorageKeyComponent2["NONCE_HIGH"] = "1";
  StorageKeyComponent2["NONCE_LOW"] = "2";
  StorageKeyComponent2["ANCESTOR_CHAIN_BIT"] = "3";
  StorageKeyComponent2["TOP_LEVEL_SITE_OPAQUE_NONCE_HIGH"] = "4";
  StorageKeyComponent2["TOP_LEVEL_SITE_OPAQUE_NONCE_LOW"] = "5";
  StorageKeyComponent2["TOP_LEVEL_SITE_OPAQUE_NONCE_PRECURSOR"] = "6";
  return StorageKeyComponent2;
})(StorageKeyComponent || {});
var Events15 = /* @__PURE__ */ ((Events210) => {
  Events210["STORAGE_KEY_ADDED"] = "StorageKeyAdded";
  Events210["STORAGE_KEY_REMOVED"] = "StorageKeyRemoved";
  Events210["MAIN_STORAGE_KEY_CHANGED"] = "MainStorageKeyChanged";
  return Events210;
})(Events15 || {});
SDKModel.register(StorageKeyManager, { capabilities: Capability.NONE, autostart: false });

// gen/front_end/core/sdk/ResourceTreeModel.js
var ResourceTreeModel = class _ResourceTreeModel extends SDKModel {
  agent;
  storageAgent;
  #securityOriginManager;
  #storageKeyManager;
  framesInternal;
  #cachedResourcesProcessed;
  #pendingReloadOptions;
  #reloadSuspensionCount;
  isInterstitialShowing;
  mainFrame;
  #pendingBackForwardCacheNotUsedEvents;
  constructor(target) {
    super(target);
    const networkManager = target.model(NetworkManager);
    if (networkManager) {
      networkManager.addEventListener(Events3.RequestFinished, this.onRequestFinished, this);
      networkManager.addEventListener(Events3.RequestUpdateDropped, this.onRequestUpdateDropped, this);
    }
    this.agent = target.pageAgent();
    this.storageAgent = target.storageAgent();
    void this.agent.invoke_enable();
    this.#securityOriginManager = target.model(SecurityOriginManager);
    this.#storageKeyManager = target.model(StorageKeyManager);
    this.#pendingBackForwardCacheNotUsedEvents = /* @__PURE__ */ new Set();
    target.registerPageDispatcher(new PageDispatcher(this));
    this.framesInternal = /* @__PURE__ */ new Map();
    this.#cachedResourcesProcessed = false;
    this.#pendingReloadOptions = null;
    this.#reloadSuspensionCount = 0;
    this.isInterstitialShowing = false;
    this.mainFrame = null;
    void this.#buildResourceTree();
  }
  async #buildResourceTree() {
    return this.agent.invoke_getResourceTree().then((event) => {
      this.processCachedResources(event.getError() ? null : event.frameTree);
      if (this.mainFrame) {
        this.processPendingEvents(this.mainFrame);
      }
    });
  }
  static frameForRequest(request) {
    const networkManager = NetworkManager.forRequest(request);
    const resourceTreeModel = networkManager ? networkManager.target().model(_ResourceTreeModel) : null;
    if (!resourceTreeModel) {
      return null;
    }
    return request.frameId ? resourceTreeModel.frameForId(request.frameId) : null;
  }
  static frames() {
    const result = [];
    for (const resourceTreeModel of TargetManager.instance().models(_ResourceTreeModel)) {
      result.push(...resourceTreeModel.frames());
    }
    return result;
  }
  static resourceForURL(url) {
    for (const resourceTreeModel of TargetManager.instance().models(_ResourceTreeModel)) {
      const mainFrame = resourceTreeModel.mainFrame;
      const result = mainFrame ? mainFrame.resourceForURL(url) : null;
      if (result) {
        return result;
      }
    }
    return null;
  }
  static reloadAllPages(bypassCache, scriptToEvaluateOnLoad) {
    for (const resourceTreeModel of TargetManager.instance().models(_ResourceTreeModel)) {
      if (resourceTreeModel.target().parentTarget()?.type() !== Type2.FRAME) {
        resourceTreeModel.reloadPage(bypassCache, scriptToEvaluateOnLoad);
      }
    }
  }
  async storageKeyForFrame(frameId) {
    if (!this.framesInternal.has(frameId)) {
      return null;
    }
    const response = await this.storageAgent.invoke_getStorageKeyForFrame({ frameId });
    if (response.getError() === "Frame tree node for given frame not found") {
      return null;
    }
    return response.storageKey;
  }
  domModel() {
    return this.target().model(DOMModel);
  }
  processCachedResources(mainFramePayload) {
    if (mainFramePayload && mainFramePayload.frame.url !== ":") {
      this.dispatchEventToListeners(
        "WillLoadCachedResources"
        /* WillLoadCachedResources */
      );
      this.addFramesRecursively(null, mainFramePayload);
      this.target().setInspectedURL(mainFramePayload.frame.url);
    }
    this.#cachedResourcesProcessed = true;
    const runtimeModel = this.target().model(RuntimeModel);
    if (runtimeModel) {
      runtimeModel.setExecutionContextComparator(this.executionContextComparator.bind(this));
      runtimeModel.fireExecutionContextOrderChanged();
    }
    this.dispatchEventToListeners("CachedResourcesLoaded", this);
  }
  cachedResourcesLoaded() {
    return this.#cachedResourcesProcessed;
  }
  addFrame(frame, _aboutToNavigate) {
    this.framesInternal.set(frame.id, frame);
    if (frame.isMainFrame()) {
      this.mainFrame = frame;
    }
    this.dispatchEventToListeners("FrameAdded", frame);
    this.updateSecurityOrigins();
    void this.updateStorageKeys();
  }
  frameAttached(frameId, parentFrameId, stackTrace) {
    const sameTargetParentFrame = parentFrameId ? this.framesInternal.get(parentFrameId) || null : null;
    if (!this.#cachedResourcesProcessed && sameTargetParentFrame) {
      return null;
    }
    if (this.framesInternal.has(frameId)) {
      return null;
    }
    const frame = new ResourceTreeFrame(this, sameTargetParentFrame, frameId, null, stackTrace || null);
    if (parentFrameId && !sameTargetParentFrame) {
      frame.crossTargetParentFrameId = parentFrameId;
    }
    if (frame.isMainFrame() && this.mainFrame) {
      this.frameDetached(this.mainFrame.id, false);
    }
    this.addFrame(frame, true);
    return frame;
  }
  frameNavigated(framePayload, type) {
    const sameTargetParentFrame = framePayload.parentId ? this.framesInternal.get(framePayload.parentId) || null : null;
    if (!this.#cachedResourcesProcessed && sameTargetParentFrame) {
      return;
    }
    let frame = this.framesInternal.get(framePayload.id) || null;
    if (!frame) {
      frame = this.frameAttached(framePayload.id, framePayload.parentId || null);
      console.assert(Boolean(frame));
      if (!frame) {
        return;
      }
    }
    this.dispatchEventToListeners("FrameWillNavigate", frame);
    frame.navigate(framePayload);
    if (type) {
      frame.backForwardCacheDetails.restoredFromCache = type === Page.NavigationType.BackForwardCacheRestore;
    }
    if (frame.isMainFrame()) {
      this.target().setInspectedURL(frame.url);
    }
    this.dispatchEventToListeners("FrameNavigated", frame);
    if (frame.isPrimaryFrame()) {
      this.primaryPageChanged(
        frame,
        "Navigation"
        /* NAVIGATION */
      );
    }
    const resources = frame.resources();
    for (let i = 0; i < resources.length; ++i) {
      this.dispatchEventToListeners("ResourceAdded", resources[i]);
    }
    this.updateSecurityOrigins();
    void this.updateStorageKeys();
    if (frame.backForwardCacheDetails.restoredFromCache) {
      FrameManager.instance().modelRemoved(this);
      FrameManager.instance().modelAdded(this);
      void this.#buildResourceTree();
    }
  }
  primaryPageChanged(frame, type) {
    this.processPendingEvents(frame);
    this.dispatchEventToListeners("PrimaryPageChanged", { frame, type });
    const networkManager = this.target().model(NetworkManager);
    if (networkManager && frame.isOutermostFrame()) {
      networkManager.clearRequests();
    }
  }
  documentOpened(framePayload) {
    this.frameNavigated(framePayload, void 0);
    const frame = this.framesInternal.get(framePayload.id);
    if (frame && !frame.getResourcesMap().get(framePayload.url)) {
      const frameResource = this.createResourceFromFramePayload(
        framePayload,
        framePayload.url,
        Common23.ResourceType.resourceTypes.Document,
        framePayload.mimeType,
        null,
        null
      );
      frameResource.isGenerated = true;
      frame.addResource(frameResource);
    }
  }
  frameDetached(frameId, isSwap) {
    if (!this.#cachedResourcesProcessed) {
      return;
    }
    const frame = this.framesInternal.get(frameId);
    if (!frame) {
      return;
    }
    const sameTargetParentFrame = frame.sameTargetParentFrame();
    if (sameTargetParentFrame) {
      sameTargetParentFrame.removeChildFrame(frame, isSwap);
    } else {
      frame.remove(isSwap);
    }
    this.updateSecurityOrigins();
    void this.updateStorageKeys();
  }
  onRequestFinished(event) {
    if (!this.#cachedResourcesProcessed) {
      return;
    }
    const request = event.data;
    if (request.failed) {
      return;
    }
    const frame = request.frameId ? this.framesInternal.get(request.frameId) : null;
    if (frame) {
      frame.addRequest(request);
    }
  }
  onRequestUpdateDropped(event) {
    if (!this.#cachedResourcesProcessed) {
      return;
    }
    const data = event.data;
    const frameId = data.frameId;
    if (!frameId) {
      return;
    }
    const frame = this.framesInternal.get(frameId);
    if (!frame) {
      return;
    }
    const url = data.url;
    if (frame.getResourcesMap().get(url)) {
      return;
    }
    const resource = new Resource(
      this,
      null,
      url,
      frame.url,
      frameId,
      data.loaderId,
      Common23.ResourceType.resourceTypes[data.resourceType],
      data.mimeType,
      data.lastModified,
      null
    );
    frame.addResource(resource);
  }
  frameForId(frameId) {
    return this.framesInternal.get(frameId) || null;
  }
  forAllResources(callback) {
    if (this.mainFrame) {
      return this.mainFrame.callForFrameResources(callback);
    }
    return false;
  }
  frames() {
    return [...this.framesInternal.values()];
  }
  resourceForURL(url) {
    return this.mainFrame ? this.mainFrame.resourceForURL(url) : null;
  }
  addFramesRecursively(sameTargetParentFrame, frameTreePayload) {
    const framePayload = frameTreePayload.frame;
    let frame = this.framesInternal.get(framePayload.id);
    if (!frame) {
      frame = new ResourceTreeFrame(this, sameTargetParentFrame, framePayload.id, framePayload, null);
    }
    if (!sameTargetParentFrame && framePayload.parentId) {
      frame.crossTargetParentFrameId = framePayload.parentId;
    }
    this.addFrame(frame);
    for (const childFrame of frameTreePayload.childFrames || []) {
      this.addFramesRecursively(frame, childFrame);
    }
    for (let i = 0; i < frameTreePayload.resources.length; ++i) {
      const subresource = frameTreePayload.resources[i];
      const resource = this.createResourceFromFramePayload(
        framePayload,
        subresource.url,
        Common23.ResourceType.resourceTypes[subresource.type],
        subresource.mimeType,
        subresource.lastModified || null,
        subresource.contentSize || null
      );
      frame.addResource(resource);
    }
    if (!frame.getResourcesMap().get(framePayload.url)) {
      const frameResource = this.createResourceFromFramePayload(
        framePayload,
        framePayload.url,
        Common23.ResourceType.resourceTypes.Document,
        framePayload.mimeType,
        null,
        null
      );
      frame.addResource(frameResource);
    }
  }
  createResourceFromFramePayload(frame, url, type, mimeType, lastModifiedTime, contentSize) {
    const lastModified = typeof lastModifiedTime === "number" ? new Date(lastModifiedTime * 1e3) : null;
    return new Resource(
      this,
      null,
      url,
      frame.url,
      frame.id,
      frame.loaderId,
      type,
      mimeType,
      lastModified,
      contentSize
    );
  }
  suspendReload() {
    this.#reloadSuspensionCount++;
  }
  resumeReload() {
    this.#reloadSuspensionCount--;
    console.assert(this.#reloadSuspensionCount >= 0, "Unbalanced call to ResourceTreeModel.resumeReload()");
    if (!this.#reloadSuspensionCount && this.#pendingReloadOptions) {
      const { ignoreCache, scriptToEvaluateOnLoad } = this.#pendingReloadOptions;
      this.reloadPage(ignoreCache, scriptToEvaluateOnLoad);
    }
  }
  reloadPage(ignoreCache, scriptToEvaluateOnLoad) {
    const loaderId = this.mainFrame?.loaderId;
    if (!loaderId) {
      return;
    }
    if (!this.#pendingReloadOptions) {
      this.dispatchEventToListeners("PageReloadRequested", this);
    }
    if (this.#reloadSuspensionCount) {
      this.#pendingReloadOptions = { ignoreCache, scriptToEvaluateOnLoad };
      return;
    }
    this.#pendingReloadOptions = null;
    const networkManager = this.target().model(NetworkManager);
    if (networkManager) {
      networkManager.clearRequests();
    }
    this.dispatchEventToListeners(
      "WillReloadPage"
      /* WillReloadPage */
    );
    void this.agent.invoke_reload({ ignoreCache, scriptToEvaluateOnLoad, loaderId });
  }
  navigate(url) {
    return this.agent.invoke_navigate({ url });
  }
  async navigationHistory() {
    const response = await this.agent.invoke_getNavigationHistory();
    if (response.getError()) {
      return null;
    }
    return { currentIndex: response.currentIndex, entries: response.entries };
  }
  navigateToHistoryEntry(entry) {
    void this.agent.invoke_navigateToHistoryEntry({ entryId: entry.id });
  }
  setLifecycleEventsEnabled(enabled) {
    return this.agent.invoke_setLifecycleEventsEnabled({ enabled });
  }
  async fetchAppManifest() {
    const response = await this.agent.invoke_getAppManifest({});
    if (response.getError()) {
      return { url: response.url, data: null, errors: [] };
    }
    return { url: response.url, data: response.data || null, errors: response.errors };
  }
  async getInstallabilityErrors() {
    const response = await this.agent.invoke_getInstallabilityErrors();
    return response.installabilityErrors || [];
  }
  async getAppId() {
    return this.agent.invoke_getAppId();
  }
  executionContextComparator(a, b) {
    function framePath(frame) {
      let currentFrame = frame;
      const parents = [];
      while (currentFrame) {
        parents.push(currentFrame);
        currentFrame = currentFrame.sameTargetParentFrame();
      }
      return parents.reverse();
    }
    if (a.target() !== b.target()) {
      return ExecutionContext.comparator(a, b);
    }
    const framesA = a.frameId ? framePath(this.frameForId(a.frameId)) : [];
    const framesB = b.frameId ? framePath(this.frameForId(b.frameId)) : [];
    let frameA;
    let frameB;
    for (let i = 0; ; i++) {
      if (!framesA[i] || !framesB[i] || framesA[i] !== framesB[i]) {
        frameA = framesA[i];
        frameB = framesB[i];
        break;
      }
    }
    if (!frameA && frameB) {
      return -1;
    }
    if (!frameB && frameA) {
      return 1;
    }
    if (frameA && frameB) {
      return frameA.id.localeCompare(frameB.id);
    }
    return ExecutionContext.comparator(a, b);
  }
  getSecurityOriginData() {
    const securityOrigins = /* @__PURE__ */ new Set();
    let mainSecurityOrigin = null;
    let unreachableMainSecurityOrigin = null;
    for (const frame of this.framesInternal.values()) {
      const origin = frame.securityOrigin;
      if (!origin) {
        continue;
      }
      securityOrigins.add(origin);
      if (frame.isMainFrame()) {
        mainSecurityOrigin = origin;
        if (frame.unreachableUrl()) {
          const unreachableParsed = new Common23.ParsedURL.ParsedURL(frame.unreachableUrl());
          unreachableMainSecurityOrigin = unreachableParsed.securityOrigin();
        }
      }
    }
    return {
      securityOrigins,
      mainSecurityOrigin,
      unreachableMainSecurityOrigin
    };
  }
  async getStorageKeyData() {
    const storageKeys = /* @__PURE__ */ new Set();
    let mainStorageKey = null;
    for (const { isMainFrame, storageKey } of await Promise.all([...this.framesInternal.values()].map(
      (f) => f.getStorageKey(
        /* forceFetch */
        false
      ).then((k) => ({
        isMainFrame: f.isMainFrame(),
        storageKey: k
      }))
    ))) {
      if (isMainFrame) {
        mainStorageKey = storageKey;
      }
      if (storageKey) {
        storageKeys.add(storageKey);
      }
    }
    return { storageKeys, mainStorageKey };
  }
  updateSecurityOrigins() {
    const data = this.getSecurityOriginData();
    this.#securityOriginManager.setMainSecurityOrigin(
      data.mainSecurityOrigin || "",
      data.unreachableMainSecurityOrigin || ""
    );
    this.#securityOriginManager.updateSecurityOrigins(data.securityOrigins);
  }
  async updateStorageKeys() {
    const data = await this.getStorageKeyData();
    this.#storageKeyManager.setMainStorageKey(data.mainStorageKey || "");
    this.#storageKeyManager.updateStorageKeys(data.storageKeys);
  }
  async getMainStorageKey() {
    return this.mainFrame ? this.mainFrame.getStorageKey(
      /* forceFetch */
      false
    ) : null;
  }
  getMainSecurityOrigin() {
    const data = this.getSecurityOriginData();
    return data.mainSecurityOrigin || data.unreachableMainSecurityOrigin;
  }
  onBackForwardCacheNotUsed(event) {
    if (this.mainFrame && this.mainFrame.id === event.frameId && this.mainFrame.loaderId === event.loaderId) {
      this.mainFrame.setBackForwardCacheDetails(event);
      this.dispatchEventToListeners("BackForwardCacheDetailsUpdated", this.mainFrame);
    } else {
      this.#pendingBackForwardCacheNotUsedEvents.add(event);
    }
  }
  processPendingEvents(frame) {
    if (!frame.isMainFrame()) {
      return;
    }
    for (const event of this.#pendingBackForwardCacheNotUsedEvents) {
      if (frame.id === event.frameId && frame.loaderId === event.loaderId) {
        frame.setBackForwardCacheDetails(event);
        this.#pendingBackForwardCacheNotUsedEvents.delete(event);
        break;
      }
    }
  }
};
var Events4 = /* @__PURE__ */ ((Events210) => {
  Events210["FrameAdded"] = "FrameAdded";
  Events210["FrameNavigated"] = "FrameNavigated";
  Events210["FrameDetached"] = "FrameDetached";
  Events210["FrameResized"] = "FrameResized";
  Events210["FrameWillNavigate"] = "FrameWillNavigate";
  Events210["PrimaryPageChanged"] = "PrimaryPageChanged";
  Events210["ResourceAdded"] = "ResourceAdded";
  Events210["WillLoadCachedResources"] = "WillLoadCachedResources";
  Events210["CachedResourcesLoaded"] = "CachedResourcesLoaded";
  Events210["DOMContentLoaded"] = "DOMContentLoaded";
  Events210["LifecycleEvent"] = "LifecycleEvent";
  Events210["Load"] = "Load";
  Events210["PageReloadRequested"] = "PageReloadRequested";
  Events210["WillReloadPage"] = "WillReloadPage";
  Events210["InterstitialShown"] = "InterstitialShown";
  Events210["InterstitialHidden"] = "InterstitialHidden";
  Events210["BackForwardCacheDetailsUpdated"] = "BackForwardCacheDetailsUpdated";
  Events210["JavaScriptDialogOpening"] = "JavaScriptDialogOpening";
  return Events210;
})(Events4 || {});
var ResourceTreeFrame = class {
  #model;
  #sameTargetParentFrameInternal;
  #idInternal;
  crossTargetParentFrameId;
  #loaderIdInternal;
  #nameInternal;
  #urlInternal;
  #domainAndRegistryInternal;
  #securityOriginInternal;
  #storageKeyInternal;
  #unreachableUrlInternal;
  #adFrameStatusInternal;
  #secureContextType;
  #crossOriginIsolatedContextType;
  #gatedAPIFeatures;
  #creationStackTrace;
  #creationStackTraceTarget;
  #childFramesInternal;
  resourcesMap;
  backForwardCacheDetails = {
    restoredFromCache: void 0,
    explanations: [],
    explanationsTree: void 0
  };
  constructor(model, parentFrame, frameId, payload, creationStackTrace) {
    this.#model = model;
    this.#sameTargetParentFrameInternal = parentFrame;
    this.#idInternal = frameId;
    this.crossTargetParentFrameId = null;
    this.#loaderIdInternal = payload?.loaderId ?? "";
    this.#nameInternal = payload && payload.name;
    this.#urlInternal = payload && payload.url || Platform16.DevToolsPath.EmptyUrlString;
    this.#domainAndRegistryInternal = payload && payload.domainAndRegistry || "";
    this.#securityOriginInternal = payload && payload.securityOrigin;
    this.#unreachableUrlInternal = payload && payload.unreachableUrl || Platform16.DevToolsPath.EmptyUrlString;
    this.#adFrameStatusInternal = payload?.adFrameStatus;
    this.#secureContextType = payload && payload.secureContextType;
    this.#crossOriginIsolatedContextType = payload && payload.crossOriginIsolatedContextType;
    this.#gatedAPIFeatures = payload && payload.gatedAPIFeatures;
    this.#creationStackTrace = creationStackTrace;
    this.#creationStackTraceTarget = null;
    this.#childFramesInternal = /* @__PURE__ */ new Set();
    this.resourcesMap = /* @__PURE__ */ new Map();
    if (this.#sameTargetParentFrameInternal) {
      this.#sameTargetParentFrameInternal.#childFramesInternal.add(this);
    }
  }
  isSecureContext() {
    return this.#secureContextType !== null && this.#secureContextType.startsWith("Secure");
  }
  getSecureContextType() {
    return this.#secureContextType;
  }
  isCrossOriginIsolated() {
    return this.#crossOriginIsolatedContextType !== null && this.#crossOriginIsolatedContextType.startsWith("Isolated");
  }
  getCrossOriginIsolatedContextType() {
    return this.#crossOriginIsolatedContextType;
  }
  getGatedAPIFeatures() {
    return this.#gatedAPIFeatures;
  }
  getCreationStackTraceData() {
    return {
      creationStackTrace: this.#creationStackTrace,
      creationStackTraceTarget: this.#creationStackTraceTarget || this.resourceTreeModel().target()
    };
  }
  navigate(framePayload) {
    this.#loaderIdInternal = framePayload.loaderId;
    this.#nameInternal = framePayload.name;
    this.#urlInternal = framePayload.url;
    this.#domainAndRegistryInternal = framePayload.domainAndRegistry;
    this.#securityOriginInternal = framePayload.securityOrigin;
    void this.getStorageKey(
      /* forceFetch */
      true
    );
    this.#unreachableUrlInternal = framePayload.unreachableUrl || Platform16.DevToolsPath.EmptyUrlString;
    this.#adFrameStatusInternal = framePayload?.adFrameStatus;
    this.#secureContextType = framePayload.secureContextType;
    this.#crossOriginIsolatedContextType = framePayload.crossOriginIsolatedContextType;
    this.#gatedAPIFeatures = framePayload.gatedAPIFeatures;
    this.backForwardCacheDetails = {
      restoredFromCache: void 0,
      explanations: [],
      explanationsTree: void 0
    };
    const mainResource = this.resourcesMap.get(this.#urlInternal);
    this.resourcesMap.clear();
    this.removeChildFrames();
    if (mainResource && mainResource.loaderId === this.#loaderIdInternal) {
      this.addResource(mainResource);
    }
  }
  resourceTreeModel() {
    return this.#model;
  }
  get id() {
    return this.#idInternal;
  }
  get name() {
    return this.#nameInternal || "";
  }
  get url() {
    return this.#urlInternal;
  }
  domainAndRegistry() {
    return this.#domainAndRegistryInternal;
  }
  async getAdScriptId(frameId) {
    const res = await this.#model.agent.invoke_getAdScriptId({ frameId });
    return res.adScriptId || null;
  }
  get securityOrigin() {
    return this.#securityOriginInternal;
  }
  getStorageKey(forceFetch) {
    if (!this.#storageKeyInternal || forceFetch) {
      this.#storageKeyInternal = this.#model.storageKeyForFrame(this.#idInternal);
    }
    return this.#storageKeyInternal;
  }
  unreachableUrl() {
    return this.#unreachableUrlInternal;
  }
  get loaderId() {
    return this.#loaderIdInternal;
  }
  adFrameType() {
    return this.#adFrameStatusInternal?.adFrameType || Page.AdFrameType.None;
  }
  adFrameStatus() {
    return this.#adFrameStatusInternal;
  }
  get childFrames() {
    return [...this.#childFramesInternal];
  }
  /**
   * Returns the parent frame if both #frames are part of the same process/target.
   */
  sameTargetParentFrame() {
    return this.#sameTargetParentFrameInternal;
  }
  /**
   * Returns the parent frame if both #frames are part of different processes/targets (child is an OOPIF).
   */
  crossTargetParentFrame() {
    if (!this.crossTargetParentFrameId) {
      return null;
    }
    const parentTarget = this.#model.target().parentTarget();
    if (parentTarget?.type() !== Type2.FRAME) {
      return null;
    }
    const parentModel = parentTarget.model(ResourceTreeModel);
    if (!parentModel) {
      return null;
    }
    return parentModel.framesInternal.get(this.crossTargetParentFrameId) || null;
  }
  /**
   * Returns the parent frame. There is only 1 parent and it's either in the
   * same target or it's cross-target.
   */
  parentFrame() {
    return this.sameTargetParentFrame() || this.crossTargetParentFrame();
  }
  /**
   * Returns true if this is the main frame of its target. A main frame is the root of the frame tree i.e. a frame without
   * a parent, but the whole frame tree could be embedded in another frame tree (e.g. OOPIFs, fenced frames, portals).
   * https://chromium.googlesource.com/chromium/src/+/HEAD/docs/frame_trees.md
   */
  isMainFrame() {
    return !this.#sameTargetParentFrameInternal;
  }
  /**
   * Returns true if this is a main frame which is not embedded in another frame tree. With MPArch features such as
   * back/forward cache or prerender there can be multiple outermost frames.
   * https://chromium.googlesource.com/chromium/src/+/HEAD/docs/frame_trees.md
   */
  isOutermostFrame() {
    return this.#model.target().parentTarget()?.type() !== Type2.FRAME && !this.#sameTargetParentFrameInternal && !this.crossTargetParentFrameId;
  }
  /**
   * Returns true if this is the primary frame of the browser tab. There can only be one primary frame for each
   * browser tab. It is the outermost frame being actively displayed in the browser tab.
   * https://chromium.googlesource.com/chromium/src/+/HEAD/docs/frame_trees.md
   */
  isPrimaryFrame() {
    return !this.#sameTargetParentFrameInternal && this.#model.target() === TargetManager.instance().primaryPageTarget();
  }
  removeChildFrame(frame, isSwap) {
    this.#childFramesInternal.delete(frame);
    frame.remove(isSwap);
  }
  removeChildFrames() {
    const frames = this.#childFramesInternal;
    this.#childFramesInternal = /* @__PURE__ */ new Set();
    for (const frame of frames) {
      frame.remove(false);
    }
  }
  remove(isSwap) {
    this.removeChildFrames();
    this.#model.framesInternal.delete(this.id);
    this.#model.dispatchEventToListeners("FrameDetached", { frame: this, isSwap });
  }
  addResource(resource) {
    if (this.resourcesMap.get(resource.url) === resource) {
      return;
    }
    this.resourcesMap.set(resource.url, resource);
    this.#model.dispatchEventToListeners("ResourceAdded", resource);
  }
  addRequest(request) {
    let resource = this.resourcesMap.get(request.url());
    if (resource && resource.request === request) {
      return;
    }
    resource = new Resource(
      this.#model,
      request,
      request.url(),
      request.documentURL,
      request.frameId,
      request.loaderId,
      request.resourceType(),
      request.mimeType,
      null,
      null
    );
    this.resourcesMap.set(resource.url, resource);
    this.#model.dispatchEventToListeners("ResourceAdded", resource);
  }
  resources() {
    return Array.from(this.resourcesMap.values());
  }
  resourceForURL(url) {
    const resource = this.resourcesMap.get(url);
    if (resource) {
      return resource;
    }
    for (const frame of this.#childFramesInternal) {
      const resource2 = frame.resourceForURL(url);
      if (resource2) {
        return resource2;
      }
    }
    return null;
  }
  callForFrameResources(callback) {
    for (const resource of this.resourcesMap.values()) {
      if (callback(resource)) {
        return true;
      }
    }
    for (const frame of this.#childFramesInternal) {
      if (frame.callForFrameResources(callback)) {
        return true;
      }
    }
    return false;
  }
  displayName() {
    if (this.isOutermostFrame()) {
      return i18n15.i18n.lockedString("top");
    }
    const subtitle = new Common23.ParsedURL.ParsedURL(this.#urlInternal).displayName;
    if (subtitle) {
      if (!this.#nameInternal) {
        return subtitle;
      }
      return this.#nameInternal + " (" + subtitle + ")";
    }
    return i18n15.i18n.lockedString("iframe");
  }
  async getOwnerDeferredDOMNode() {
    const parentFrame = this.parentFrame();
    if (!parentFrame) {
      return null;
    }
    return parentFrame.resourceTreeModel().domModel().getOwnerNodeForFrame(this.#idInternal);
  }
  async getOwnerDOMNodeOrDocument() {
    const deferredNode = await this.getOwnerDeferredDOMNode();
    if (deferredNode) {
      return deferredNode.resolvePromise();
    }
    if (this.isOutermostFrame()) {
      return this.resourceTreeModel().domModel().requestDocument();
    }
    return null;
  }
  async highlight() {
    const parentFrame = this.parentFrame();
    const parentTarget = this.resourceTreeModel().target().parentTarget();
    const highlightFrameOwner = async (domModel) => {
      const deferredNode = await domModel.getOwnerNodeForFrame(this.#idInternal);
      if (deferredNode) {
        domModel.overlayModel().highlightInOverlay({ deferredNode, selectorList: "" }, "all", true);
      }
    };
    if (parentFrame) {
      return highlightFrameOwner(parentFrame.resourceTreeModel().domModel());
    }
    if (parentTarget?.type() === Type2.FRAME) {
      const domModel = parentTarget.model(DOMModel);
      if (domModel) {
        return highlightFrameOwner(domModel);
      }
    }
    const document2 = await this.resourceTreeModel().domModel().requestDocument();
    if (document2) {
      this.resourceTreeModel().domModel().overlayModel().highlightInOverlay(
        { node: document2, selectorList: "" },
        "all",
        true
      );
    }
  }
  async getPermissionsPolicyState() {
    const response = await this.resourceTreeModel().target().pageAgent().invoke_getPermissionsPolicyState(
      { frameId: this.#idInternal }
    );
    if (response.getError()) {
      return null;
    }
    return response.states;
  }
  async getOriginTrials() {
    const response = await this.resourceTreeModel().target().pageAgent().invoke_getOriginTrials({ frameId: this.#idInternal });
    if (response.getError()) {
      return [];
    }
    return response.originTrials;
  }
  setCreationStackTrace(creationStackTraceData) {
    this.#creationStackTrace = creationStackTraceData.creationStackTrace;
    this.#creationStackTraceTarget = creationStackTraceData.creationStackTraceTarget;
  }
  setBackForwardCacheDetails(event) {
    this.backForwardCacheDetails.restoredFromCache = false;
    this.backForwardCacheDetails.explanations = event.notRestoredExplanations;
    this.backForwardCacheDetails.explanationsTree = event.notRestoredExplanationsTree;
  }
  getResourcesMap() {
    return this.resourcesMap;
  }
};
var PageDispatcher = class {
  #resourceTreeModel;
  constructor(resourceTreeModel) {
    this.#resourceTreeModel = resourceTreeModel;
  }
  backForwardCacheNotUsed(params) {
    this.#resourceTreeModel.onBackForwardCacheNotUsed(params);
  }
  domContentEventFired({ timestamp }) {
    this.#resourceTreeModel.dispatchEventToListeners("DOMContentLoaded", timestamp);
  }
  loadEventFired({ timestamp }) {
    this.#resourceTreeModel.dispatchEventToListeners(
      "Load",
      { resourceTreeModel: this.#resourceTreeModel, loadTime: timestamp }
    );
  }
  lifecycleEvent({ frameId, name }) {
    this.#resourceTreeModel.dispatchEventToListeners("LifecycleEvent", { frameId, name });
  }
  frameAttached({ frameId, parentFrameId, stack }) {
    this.#resourceTreeModel.frameAttached(frameId, parentFrameId, stack);
  }
  frameNavigated({ frame, type }) {
    this.#resourceTreeModel.frameNavigated(frame, type);
  }
  documentOpened({ frame }) {
    this.#resourceTreeModel.documentOpened(frame);
  }
  frameDetached({ frameId, reason }) {
    this.#resourceTreeModel.frameDetached(frameId, reason === Page.FrameDetachedEventReason.Swap);
  }
  frameSubtreeWillBeDetached(_params) {
  }
  frameStartedLoading({}) {
  }
  frameStoppedLoading({}) {
  }
  frameRequestedNavigation({}) {
  }
  frameScheduledNavigation({}) {
  }
  frameClearedScheduledNavigation({}) {
  }
  navigatedWithinDocument({}) {
  }
  frameResized() {
    this.#resourceTreeModel.dispatchEventToListeners(
      "FrameResized"
      /* FrameResized */
    );
  }
  javascriptDialogOpening(event) {
    this.#resourceTreeModel.dispatchEventToListeners("JavaScriptDialogOpening", event);
    if (!event.hasBrowserHandler) {
      void this.#resourceTreeModel.agent.invoke_handleJavaScriptDialog({ accept: false });
    }
  }
  javascriptDialogClosed({}) {
  }
  screencastFrame({}) {
  }
  screencastVisibilityChanged({}) {
  }
  interstitialShown() {
    this.#resourceTreeModel.isInterstitialShowing = true;
    this.#resourceTreeModel.dispatchEventToListeners(
      "InterstitialShown"
      /* InterstitialShown */
    );
  }
  interstitialHidden() {
    this.#resourceTreeModel.isInterstitialShowing = false;
    this.#resourceTreeModel.dispatchEventToListeners(
      "InterstitialHidden"
      /* InterstitialHidden */
    );
  }
  windowOpen({}) {
  }
  compilationCacheProduced({}) {
  }
  fileChooserOpened({}) {
  }
  downloadWillBegin({}) {
  }
  downloadProgress() {
  }
};
SDKModel.register(ResourceTreeModel, { capabilities: Capability.DOM, autostart: true, early: true });
var PrimaryPageChangeType = /* @__PURE__ */ ((PrimaryPageChangeType2) => {
  PrimaryPageChangeType2["NAVIGATION"] = "Navigation";
  PrimaryPageChangeType2["ACTIVATION"] = "Activation";
  return PrimaryPageChangeType2;
})(PrimaryPageChangeType || {});

// gen/front_end/core/sdk/CookieModel.js
var CookieModel = class extends SDKModel {
  #blockedCookies;
  #cookieToBlockedReasons;
  #refreshThrottler;
  #cookies;
  constructor(target) {
    super(target);
    this.#refreshThrottler = new Common24.Throttler.Throttler(300);
    this.#blockedCookies = /* @__PURE__ */ new Map();
    this.#cookieToBlockedReasons = /* @__PURE__ */ new Map();
    this.#cookies = /* @__PURE__ */ new Map();
    target.model(ResourceTreeModel)?.addEventListener(Events4.PrimaryPageChanged, this.#onPrimaryPageChanged, this);
    target.model(NetworkManager)?.addEventListener(Events3.ResponseReceived, this.#onResponseReceived, this);
    target.model(NetworkManager)?.addEventListener(Events3.LoadingFinished, this.#onLoadingFinished, this);
  }
  addBlockedCookie(cookie, blockedReasons) {
    const key = cookie.key();
    const previousCookie = this.#blockedCookies.get(key);
    this.#blockedCookies.set(key, cookie);
    if (blockedReasons) {
      this.#cookieToBlockedReasons.set(cookie, blockedReasons);
    } else {
      this.#cookieToBlockedReasons.delete(cookie);
    }
    if (previousCookie) {
      this.#cookieToBlockedReasons.delete(previousCookie);
    }
  }
  removeBlockedCookie(cookie) {
    this.#blockedCookies.delete(cookie.key());
  }
  async #onPrimaryPageChanged() {
    this.#blockedCookies.clear();
    this.#cookieToBlockedReasons.clear();
    await this.#refresh();
  }
  getCookieToBlockedReasonsMap() {
    return this.#cookieToBlockedReasons;
  }
  async #getCookies(urls) {
    const networkAgent = this.target().networkAgent();
    const newCookies = new Map(await Promise.all(urls.keysArray().map(
      (domain) => networkAgent.invoke_getCookies({ urls: [...urls.get(domain).values()] }).then(({ cookies }) => [domain, cookies.map(Cookie.fromProtocolCookie)])
    )));
    const updated = this.#isUpdated(newCookies);
    this.#cookies = newCookies;
    if (updated) {
      this.dispatchEventToListeners(
        "CookieListUpdated"
        /* COOKIE_LIST_UPDATED */
      );
    }
  }
  async deleteCookie(cookie) {
    await this.deleteCookies([cookie]);
  }
  async clear(domain, securityOrigin) {
    if (!this.#isRefreshing()) {
      await this.#refreshThrottled();
    }
    const cookies = domain ? this.#cookies.get(domain) || [] : [...this.#cookies.values()].flat();
    cookies.push(...this.#blockedCookies.values());
    if (securityOrigin) {
      const cookiesToDelete = cookies.filter((cookie) => {
        return cookie.matchesSecurityOrigin(securityOrigin);
      });
      await this.deleteCookies(cookiesToDelete);
    } else {
      await this.deleteCookies(cookies);
    }
  }
  async saveCookie(cookie) {
    let domain = cookie.domain();
    if (!domain.startsWith(".")) {
      domain = "";
    }
    let expires = void 0;
    if (cookie.expires()) {
      expires = Math.floor(Date.parse(`${cookie.expires()}`) / 1e3);
    }
    const enabled = Root7.Runtime.experiments.isEnabled("experimental-cookie-features");
    const preserveUnset = (scheme) => scheme === Network.CookieSourceScheme.Unset ? scheme : void 0;
    const protocolCookie = {
      name: cookie.name(),
      value: cookie.value(),
      url: cookie.url() || void 0,
      domain,
      path: cookie.path(),
      secure: cookie.secure(),
      httpOnly: cookie.httpOnly(),
      sameSite: cookie.sameSite(),
      expires,
      priority: cookie.priority(),
      partitionKey: cookie.partitionKey(),
      sourceScheme: enabled ? cookie.sourceScheme() : preserveUnset(cookie.sourceScheme()),
      sourcePort: enabled ? cookie.sourcePort() : void 0
    };
    const response = await this.target().networkAgent().invoke_setCookie(protocolCookie);
    const error = response.getError();
    if (error || !response.success) {
      return false;
    }
    await this.#refreshThrottled();
    return response.success;
  }
  /**
   * Returns cookies needed by current page's frames whose security origins are |domain|.
   */
  async getCookiesForDomain(domain, forceUpdate) {
    if (!this.#isRefreshing() || forceUpdate) {
      await this.#refreshThrottled();
    }
    const normalCookies = this.#cookies.get(domain) || [];
    return normalCookies.concat(Array.from(this.#blockedCookies.values()));
  }
  async deleteCookies(cookies) {
    const networkAgent = this.target().networkAgent();
    this.#blockedCookies.clear();
    this.#cookieToBlockedReasons.clear();
    await Promise.all(cookies.map((cookie) => networkAgent.invoke_deleteCookies({
      name: cookie.name(),
      url: void 0,
      domain: cookie.domain(),
      path: cookie.path(),
      partitionKey: cookie.partitionKey()
    })));
    await this.#refreshThrottled();
  }
  #isRefreshing() {
    return Boolean(this.listeners?.size);
  }
  #isUpdated(newCookies) {
    if (newCookies.size !== this.#cookies.size) {
      return true;
    }
    for (const [domain, newDomainCookies] of newCookies) {
      if (!this.#cookies.has(domain)) {
        return true;
      }
      const oldDomainCookies = this.#cookies.get(domain) || [];
      if (newDomainCookies.length !== oldDomainCookies.length) {
        return true;
      }
      const comparisonKey = (c) => c.key() + " " + c.value();
      const oldDomainCookieKeys = new Set(oldDomainCookies.map(comparisonKey));
      for (const newCookie of newDomainCookies) {
        if (!oldDomainCookieKeys.has(comparisonKey(newCookie))) {
          return true;
        }
      }
    }
    return false;
  }
  #refreshThrottled() {
    return this.#refreshThrottler.schedule(() => this.#refresh());
  }
  #refresh() {
    const resourceURLs = new Platform17.MapUtilities.Multimap();
    function populateResourceURLs(resource) {
      const documentURL = Common24.ParsedURL.ParsedURL.fromString(resource.documentURL);
      if (documentURL) {
        resourceURLs.set(documentURL.securityOrigin(), resource.url);
      }
      return false;
    }
    const resourceTreeModel = this.target().model(ResourceTreeModel);
    if (resourceTreeModel) {
      const unreachableUrl = resourceTreeModel.mainFrame?.unreachableUrl();
      if (unreachableUrl) {
        const documentURL = Common24.ParsedURL.ParsedURL.fromString(unreachableUrl);
        if (documentURL) {
          resourceURLs.set(documentURL.securityOrigin(), unreachableUrl);
        }
      }
      resourceTreeModel.forAllResources(populateResourceURLs);
    }
    return this.#getCookies(resourceURLs);
  }
  #onResponseReceived() {
    if (this.#isRefreshing()) {
      void this.#refreshThrottled();
    }
  }
  #onLoadingFinished() {
    if (this.#isRefreshing()) {
      void this.#refreshThrottled();
    }
  }
};
SDKModel.register(CookieModel, { capabilities: Capability.NETWORK, autostart: false });
var Events16 = /* @__PURE__ */ ((Events210) => {
  Events210["COOKIE_LIST_UPDATED"] = "CookieListUpdated";
  return Events210;
})(Events16 || {});

// gen/front_end/core/sdk/CookieParser.js
var CookieParser_exports = {};
__export(CookieParser_exports, {
  CookieParser: () => CookieParser
});
var CookieParser = class _CookieParser {
  #domain;
  #cookiesInternal;
  #input;
  #originalInputLength;
  #lastCookie;
  #lastCookieLine;
  #lastCookiePosition;
  constructor(domain) {
    if (domain) {
      this.#domain = domain.toLowerCase().replace(/^\./, "");
    }
    this.#cookiesInternal = [];
    this.#originalInputLength = 0;
  }
  static parseSetCookie(header, domain) {
    return new _CookieParser(domain).parseSetCookie(header);
  }
  getCookieAttribute(header) {
    if (!header) {
      return null;
    }
    switch (header.toLowerCase()) {
      case "domain":
        return Attribute.DOMAIN;
      case "expires":
        return Attribute.EXPIRES;
      case "max-age":
        return Attribute.MAX_AGE;
      case "httponly":
        return Attribute.HTTP_ONLY;
      case "name":
        return Attribute.NAME;
      case "path":
        return Attribute.PATH;
      case "samesite":
        return Attribute.SAME_SITE;
      case "secure":
        return Attribute.SECURE;
      case "value":
        return Attribute.VALUE;
      case "priority":
        return Attribute.PRIORITY;
      case "sourceport":
        return Attribute.SOURCE_PORT;
      case "sourcescheme":
        return Attribute.SOURCE_SCHEME;
      case "partitioned":
        return Attribute.PARTITIONED;
      default:
        console.error("Failed getting cookie attribute: " + header);
        return null;
    }
  }
  cookies() {
    return this.#cookiesInternal;
  }
  parseSetCookie(setCookieHeader) {
    if (!this.initialize(setCookieHeader)) {
      return null;
    }
    for (let kv = this.extractKeyValue(); kv; kv = this.extractKeyValue()) {
      if (this.#lastCookie) {
        this.#lastCookie.addAttribute(this.getCookieAttribute(kv.key), kv.value);
      } else {
        this.addCookie(kv, Type.RESPONSE);
      }
      if (this.advanceAndCheckCookieDelimiter()) {
        this.flushCookie();
      }
    }
    this.flushCookie();
    return this.#cookiesInternal;
  }
  initialize(headerValue) {
    this.#input = headerValue;
    if (typeof headerValue !== "string") {
      return false;
    }
    this.#cookiesInternal = [];
    this.#lastCookie = null;
    this.#lastCookieLine = "";
    this.#originalInputLength = this.#input.length;
    return true;
  }
  flushCookie() {
    if (this.#lastCookie) {
      this.#lastCookie.setSize(
        this.#originalInputLength - this.#input.length - this.#lastCookiePosition
      );
      this.#lastCookie.setCookieLine(this.#lastCookieLine.replace("\n", ""));
    }
    this.#lastCookie = null;
    this.#lastCookieLine = "";
  }
  extractKeyValue() {
    if (!this.#input || !this.#input.length) {
      return null;
    }
    const keyValueMatch = /^[ \t]*([^=;\n]+)[ \t]*(?:=[ \t]*([^;\n]*))?/.exec(this.#input);
    if (!keyValueMatch) {
      console.error("Failed parsing cookie header before: " + this.#input);
      return null;
    }
    const result = new KeyValue(
      keyValueMatch[1] && keyValueMatch[1].trim(),
      keyValueMatch[2] && keyValueMatch[2].trim(),
      this.#originalInputLength - this.#input.length
    );
    this.#lastCookieLine += keyValueMatch[0];
    this.#input = this.#input.slice(keyValueMatch[0].length);
    return result;
  }
  advanceAndCheckCookieDelimiter() {
    if (!this.#input) {
      return false;
    }
    const match = /^\s*[\n;]\s*/.exec(this.#input);
    if (!match) {
      return false;
    }
    this.#lastCookieLine += match[0];
    this.#input = this.#input.slice(match[0].length);
    return match[0].match("\n") !== null;
  }
  addCookie(keyValue, type) {
    if (this.#lastCookie) {
      this.#lastCookie.setSize(keyValue.position - this.#lastCookiePosition);
    }
    this.#lastCookie = typeof keyValue.value === "string" ? new Cookie(keyValue.key, keyValue.value, type) : new Cookie("", keyValue.key, type);
    if (this.#domain) {
      this.#lastCookie.addAttribute(Attribute.DOMAIN, this.#domain);
    }
    this.#lastCookiePosition = keyValue.position;
    this.#cookiesInternal.push(this.#lastCookie);
  }
};
var KeyValue = class {
  key;
  value;
  position;
  constructor(key, value, position) {
    this.key = key;
    this.value = value;
    this.position = position;
  }
};

// gen/front_end/core/sdk/HttpReasonPhraseStrings.js
import * as i18n17 from "./../i18n/i18n.js";
function getStatusText(statusCode) {
  const statusTextLookup = {
    100: "Continue",
    101: "Switching Protocols",
    102: "Processing",
    103: "Early Hints",
    200: "OK",
    201: "Created",
    202: "Accepted",
    203: "Non-Authoritative Information",
    204: "No Content",
    205: "Reset Content",
    206: "Partial Content",
    207: "Multi-Status",
    208: "Already Reported",
    226: "IM Used",
    300: "Multiple Choices",
    301: "Moved Permanently",
    302: "Found",
    303: "See Other",
    304: "Not Modified",
    305: "Use Proxy",
    307: "Temporary Redirect",
    308: "Permanent Redirect",
    400: "Bad Request",
    401: "Unauthorized",
    402: "Payment Required",
    403: "Forbidden",
    404: "Not Found",
    405: "Method Not Allowed",
    406: "Not Acceptable",
    407: "Proxy Authentication Required",
    408: "Request Timeout",
    409: "Conflict",
    410: "Gone",
    411: "Length Required",
    412: "Precondition Failed",
    413: "Payload Too Large",
    414: "URI Too Long",
    415: "Unsupported Media Type",
    416: "Range Not Satisfiable",
    417: "Expectation Failed",
    418: "I'm a teapot",
    421: "Misdirected Request",
    422: "Unprocessable Content",
    423: "Locked",
    424: "Failed Dependency",
    425: "Too Early",
    426: "Upgrade Required",
    428: "Precondition Required",
    429: "Too Many Requests",
    431: "Request Header Fields Too Large",
    451: "Unavailable For Legal Reasons",
    500: "Internal Server Error",
    501: "Not Implemented",
    502: "Bad Gateway",
    503: "Service Unavailable",
    504: "Gateway Timeout",
    505: "HTTP Version Not Supported",
    506: "Variant Also Negotiates",
    507: "Insufficient Storage",
    508: "Loop Detected",
    510: "Not Extended",
    511: "Network Authentication Required"
  };
  return i18n17.i18n.lockedString(statusTextLookup[statusCode] ?? "");
}

// gen/front_end/core/sdk/ServerSentEvents.js
import * as TextUtils20 from "./../../models/text_utils/text_utils.js";

// gen/front_end/core/sdk/ServerSentEventsProtocol.js
var ServerSentEventsProtocol_exports = {};
__export(ServerSentEventsProtocol_exports, {
  ServerSentEventsParser: () => ServerSentEventsParser
});
var ServerSentEventsParser = class {
  #onEventCallback;
  #decoder;
  // Parser state.
  #isRecognizingCrLf = false;
  #line = "";
  #id = "";
  #data = "";
  #eventType = "";
  constructor(callback, encodingLabel) {
    this.#onEventCallback = callback;
    this.#decoder = new Base64TextDecoder(this.#onTextChunk.bind(this), encodingLabel);
  }
  async addBase64Chunk(raw) {
    await this.#decoder.addBase64Chunk(raw);
  }
  #onTextChunk(chunk) {
    let start = 0;
    for (let i = 0; i < chunk.length; ++i) {
      if (this.#isRecognizingCrLf && chunk[i] === "\n") {
        this.#isRecognizingCrLf = false;
        ++start;
        continue;
      }
      this.#isRecognizingCrLf = false;
      if (chunk[i] === "\r" || chunk[i] === "\n") {
        this.#line += chunk.substring(start, i);
        this.#parseLine();
        this.#line = "";
        start = i + 1;
        this.#isRecognizingCrLf = chunk[i] === "\r";
      }
    }
    this.#line += chunk.substring(start);
  }
  #parseLine() {
    if (this.#line.length === 0) {
      if (this.#data.length > 0) {
        const data = this.#data.slice(0, -1);
        this.#onEventCallback(this.#eventType || "message", data, this.#id);
        this.#data = "";
      }
      this.#eventType = "";
      return;
    }
    let fieldNameEnd = this.#line.indexOf(":");
    let fieldValueStart;
    if (fieldNameEnd < 0) {
      fieldNameEnd = this.#line.length;
      fieldValueStart = fieldNameEnd;
    } else {
      fieldValueStart = fieldNameEnd + 1;
      if (fieldValueStart < this.#line.length && this.#line[fieldValueStart] === " ") {
        ++fieldValueStart;
      }
    }
    const fieldName = this.#line.substring(0, fieldNameEnd);
    if (fieldName === "event") {
      this.#eventType = this.#line.substring(fieldValueStart);
      return;
    }
    if (fieldName === "data") {
      this.#data += this.#line.substring(fieldValueStart);
      this.#data += "\n";
    }
    if (fieldName === "id") {
      this.#id = this.#line.substring(fieldValueStart);
    }
  }
};
var Base64TextDecoder = class {
  #decoder;
  #writer;
  constructor(onTextChunk, encodingLabel) {
    this.#decoder = new TextDecoderStream(encodingLabel);
    this.#writer = this.#decoder.writable.getWriter();
    void this.#decoder.readable.pipeTo(new WritableStream({ write: onTextChunk }));
  }
  async addBase64Chunk(chunk) {
    const binString = window.atob(chunk);
    const bytes = Uint8Array.from(binString, (m) => m.codePointAt(0));
    await this.#writer.ready;
    await this.#writer.write(bytes);
  }
};

// gen/front_end/core/sdk/ServerSentEvents.js
var ServerSentEvents = class {
  #request;
  #parser;
  // In the case where we parse the events ourselves we use the time of the last 'dataReceived'
  // event for all the events that come out of the corresponding chunk of data.
  #lastDataReceivedTime = 0;
  #eventSourceMessages = [];
  constructor(request, parseFromStreamedData) {
    this.#request = request;
    if (parseFromStreamedData) {
      this.#lastDataReceivedTime = request.pseudoWallTime(request.startTime);
      this.#parser = new ServerSentEventsParser(this.#onParserEvent.bind(this), request.charset() ?? void 0);
      void this.#request.requestStreamingContent().then((streamingContentData) => {
        if (!TextUtils20.StreamingContentData.isError(streamingContentData)) {
          void this.#parser?.addBase64Chunk(streamingContentData.content().base64);
          streamingContentData.addEventListener(
            TextUtils20.StreamingContentData.Events.CHUNK_ADDED,
            ({ data: { chunk } }) => {
              this.#lastDataReceivedTime = request.pseudoWallTime(request.endTime);
              void this.#parser?.addBase64Chunk(chunk);
            }
          );
        }
      });
    }
  }
  get eventSourceMessages() {
    return this.#eventSourceMessages;
  }
  /** Forwarded Network.eventSourceMessage received */
  onProtocolEventSourceMessageReceived(eventName, data, eventId, time) {
    this.#recordMessageAndDispatchEvent({
      eventName,
      eventId,
      data,
      time
    });
  }
  #onParserEvent(eventName, data, eventId) {
    this.#recordMessageAndDispatchEvent({
      eventName,
      eventId,
      data,
      time: this.#lastDataReceivedTime
    });
  }
  #recordMessageAndDispatchEvent(message) {
    this.#eventSourceMessages.push(message);
    this.#request.dispatchEventToListeners(Events2.EVENT_SOURCE_MESSAGE_ADDED, message);
  }
};

// gen/front_end/core/sdk/ServerTiming.js
var ServerTiming_exports = {};
__export(ServerTiming_exports, {
  ServerTiming: () => ServerTiming2
});
import * as i18n19 from "./../i18n/i18n.js";
import * as Platform18 from "./../platform/platform.js";
var UIStrings8 = {
  /**
   *@description Text in Server Timing
   */
  deprecatedSyntaxFoundPleaseUse: "Deprecated syntax found. Please use: <name>;dur=<duration>;desc=<description>",
  /**
   *@description Text in Server Timing
   *@example {https} PH1
   */
  duplicateParameterSIgnored: 'Duplicate parameter "{PH1}" ignored.',
  /**
   *@description Text in Server Timing
   *@example {https} PH1
   */
  noValueFoundForParameterS: 'No value found for parameter "{PH1}".',
  /**
   *@description Text in Server Timing
   *@example {https} PH1
   */
  unrecognizedParameterS: 'Unrecognized parameter "{PH1}".',
  /**
   *@description Text in Server Timing
   */
  extraneousTrailingCharacters: "Extraneous trailing characters.",
  /**
   *@description Text in Server Timing
   *@example {https} PH1
   *@example {2.0} PH2
   */
  unableToParseSValueS: 'Unable to parse "{PH1}" value "{PH2}".'
};
var str_8 = i18n19.i18n.registerUIStrings("core/sdk/ServerTiming.ts", UIStrings8);
var i18nString8 = i18n19.i18n.getLocalizedString.bind(void 0, str_8);
var warningMessage = {
  deprecratedSyntax: () => i18nString8(UIStrings8.deprecatedSyntaxFoundPleaseUse),
  duplicateParameter: (param) => i18nString8(UIStrings8.duplicateParameterSIgnored, { PH1: param }),
  noValueFoundForParameter: (param) => i18nString8(UIStrings8.noValueFoundForParameterS, { PH1: param }),
  unrecognizedParameter: (param) => i18nString8(UIStrings8.unrecognizedParameterS, { PH1: param }),
  extraneousTrailingCharacters: () => i18nString8(UIStrings8.extraneousTrailingCharacters),
  unableToParseValue: (paramName, paramValue) => i18nString8(UIStrings8.unableToParseSValueS, { PH1: paramName, PH2: paramValue })
};
var ServerTiming2 = class extends Platform18.ServerTiming.ServerTiming {
  static parseHeaders(headers) {
    return Platform18.ServerTiming.ServerTiming.parseHeaders(headers, warningMessage);
  }
  /**
   * TODO(crbug.com/1011811): Instead of using !Object<string, *> we should have a proper type
   *                          with #name, desc and dur properties.
   */
  static createFromHeaderValue(valueString) {
    return Platform18.ServerTiming.ServerTiming.createFromHeaderValue(valueString, warningMessage);
  }
  static getParserForParameter(paramName) {
    return Platform18.ServerTiming.ServerTiming.getParserForParameter(paramName, warningMessage);
  }
};

// gen/front_end/core/sdk/NetworkRequest.js
var UIStrings9 = {
  /**
   *@description Text in Network Request
   */
  binary: "(binary)",
  /**
   *@description Tooltip to explain why a cookie was blocked
   */
  secureOnly: 'This cookie was blocked because it had the "`Secure`" attribute and the connection was not secure.',
  /**
   *@description Tooltip to explain why a cookie was blocked
   */
  notOnPath: "This cookie was blocked because its path was not an exact match for or a superdirectory of the request url's path.",
  /**
   *@description Tooltip to explain why a cookie was blocked
   */
  domainMismatch: "This cookie was blocked because neither did the request URL's domain exactly match the cookie's domain, nor was the request URL's domain a subdomain of the cookie's Domain attribute value.",
  /**
   *@description Tooltip to explain why a cookie was blocked
   */
  sameSiteStrict: 'This cookie was blocked because it had the "`SameSite=Strict`" attribute and the request was made from a different site. This includes top-level navigation requests initiated by other sites.',
  /**
   *@description Tooltip to explain why a cookie was blocked
   */
  sameSiteLax: 'This cookie was blocked because it had the "`SameSite=Lax`" attribute and the request was made from a different site and was not initiated by a top-level navigation.',
  /**
   *@description Tooltip to explain why a cookie was blocked
   */
  sameSiteUnspecifiedTreatedAsLax: 'This cookie didn\'t specify a "`SameSite`" attribute when it was stored and was defaulted to "SameSite=Lax," and was blocked because the request was made from a different site and was not initiated by a top-level navigation. The cookie had to have been set with "`SameSite=None`" to enable cross-site usage.',
  /**
   *@description Tooltip to explain why a cookie was blocked
   */
  sameSiteNoneInsecure: 'This cookie was blocked because it had the "`SameSite=None`" attribute but was not marked "Secure". Cookies without SameSite restrictions must be marked "Secure" and sent over a secure connection.',
  /**
   *@description Tooltip to explain why a cookie was blocked
   */
  userPreferences: "This cookie was blocked due to user preferences.",
  /**
   *@description Tooltip to explain why a cookie was blocked
   */
  thirdPartyPhaseout: "This cookie was blocked either because of Chrome flags or browser configuration. Learn more in the Issues panel.",
  /**
   *@description Tooltip to explain why a cookie was blocked
   */
  unknownError: "An unknown error was encountered when trying to send this cookie.",
  /**
   *@description Tooltip to explain why a cookie was blocked due to Schemeful Same-Site
   */
  schemefulSameSiteStrict: 'This cookie was blocked because it had the "`SameSite=Strict`" attribute but the request was cross-site. This includes top-level navigation requests initiated by other sites. This request is considered cross-site because the URL has a different scheme than the current site.',
  /**
   *@description Tooltip to explain why a cookie was blocked due to Schemeful Same-Site
   */
  schemefulSameSiteLax: 'This cookie was blocked because it had the "`SameSite=Lax`" attribute but the request was cross-site and was not initiated by a top-level navigation. This request is considered cross-site because the URL has a different scheme than the current site.',
  /**
   *@description Tooltip to explain why a cookie was blocked due to Schemeful Same-Site
   */
  schemefulSameSiteUnspecifiedTreatedAsLax: 'This cookie didn\'t specify a "`SameSite`" attribute when it was stored, was defaulted to "`SameSite=Lax"`, and was blocked because the request was cross-site and was not initiated by a top-level navigation. This request is considered cross-site because the URL has a different scheme than the current site.',
  /**
   *@description Tooltip to explain why a cookie was blocked due to SameParty
   */
  samePartyFromCrossPartyContext: "This cookie was blocked because it had the \"`SameParty`\" attribute but the request was cross-party. The request was considered cross-party because the domain of the resource's URL and the domains of the resource's enclosing frames/documents are neither owners nor members in the same First-Party Set.",
  /**
   *@description Tooltip to explain why a cookie was blocked due to exceeding the maximum size
   */
  nameValuePairExceedsMaxSize: "This cookie was blocked because it was too large. The combined size of the name and value must be less than or equal to 4096 characters.",
  /**
   *@description Tooltip to explain why an attempt to set a cookie via `Set-Cookie` HTTP header on a request's response was blocked.
   */
  thisSetcookieWasBlockedDueToUser: "This attempt to set a cookie via a `Set-Cookie` header was blocked due to user preferences.",
  /**
   *@description Tooltip to explain why an attempt to set a cookie via `Set-Cookie` HTTP header on a request's response was blocked.
   */
  thisSetcookieWasBlockedDueThirdPartyPhaseout: "Setting this cookie was blocked either because of Chrome flags or browser configuration. Learn more in the Issues panel.",
  /**
   *@description Tooltip to explain why an attempt to set a cookie via `Set-Cookie` HTTP header on a request's response was blocked.
   */
  thisSetcookieHadInvalidSyntax: "This `Set-Cookie` header had invalid syntax.",
  /**
   *@description Tooltip to explain why a cookie was blocked
   */
  thisSetcookieHadADisallowedCharacter: "This `Set-Cookie` header contained a disallowed character (a forbidden ASCII control character, or the tab character if it appears in the middle of the cookie name, value, an attribute name, or an attribute value).",
  /**
   *@description Tooltip to explain why a cookie was blocked
   */
  theSchemeOfThisConnectionIsNot: "The scheme of this connection is not allowed to store cookies.",
  /**
   *@description Tooltip to explain why a cookie was blocked
   */
  anUnknownErrorWasEncounteredWhenTrying: "An unknown error was encountered when trying to store this cookie.",
  /**
   *@description Tooltip to explain why a cookie was blocked due to Schemeful Same-Site
   *@example {SameSite=Strict} PH1
   */
  thisSetcookieWasBlockedBecauseItHadTheSamesiteStrictLax: 'This attempt to set a cookie via a `Set-Cookie` header was blocked because it had the "{PH1}" attribute but came from a cross-site response which was not the response to a top-level navigation. This response is considered cross-site because the URL has a different scheme than the current site.',
  /**
   *@description Tooltip to explain why a cookie was blocked due to Schemeful Same-Site
   */
  thisSetcookieDidntSpecifyASamesite: 'This `Set-Cookie` header didn\'t specify a "`SameSite`" attribute, was defaulted to "`SameSite=Lax"`, and was blocked because it came from a cross-site response which was not the response to a top-level navigation. This response is considered cross-site because the URL has a different scheme than the current site.',
  /**
   *@description Tooltip to explain why a cookie was blocked due to SameParty
   */
  thisSetcookieWasBlockedBecauseItHadTheSameparty: "This attempt to set a cookie via a `Set-Cookie` header was blocked because it had the \"`SameParty`\" attribute but the request was cross-party. The request was considered cross-party because the domain of the resource's URL and the domains of the resource's enclosing frames/documents are neither owners nor members in the same First-Party Set.",
  /**
   *@description Tooltip to explain why a cookie was blocked due to SameParty
   */
  thisSetcookieWasBlockedBecauseItHadTheSamepartyAttribute: 'This attempt to set a cookie via a `Set-Cookie` header was blocked because it had the "`SameParty`" attribute but also had other conflicting attributes. Chrome requires cookies that use the "`SameParty`" attribute to also have the "Secure" attribute, and to not be restricted to "`SameSite=Strict`".',
  /**
   *@description Tooltip to explain why an attempt to set a cookie via a `Set-Cookie` HTTP header on a request's response was blocked.
   */
  blockedReasonSecureOnly: 'This attempt to set a cookie via a `Set-Cookie` header was blocked because it had the "Secure" attribute but was not received over a secure connection.',
  /**
   *@description Tooltip to explain why an attempt to set a cookie via a `Set-Cookie` HTTP header on a request's response was blocked.
   *@example {SameSite=Strict} PH1
   */
  blockedReasonSameSiteStrictLax: 'This attempt to set a cookie via a `Set-Cookie` header was blocked because it had the "{PH1}" attribute but came from a cross-site response which was not the response to a top-level navigation.',
  /**
   *@description Tooltip to explain why an attempt to set a cookie via a `Set-Cookie` HTTP header on a request's response was blocked.
   */
  blockedReasonSameSiteUnspecifiedTreatedAsLax: 'This `Set-Cookie` header didn\'t specify a "`SameSite`" attribute and was defaulted to "`SameSite=Lax,`" and was blocked because it came from a cross-site response which was not the response to a top-level navigation. The `Set-Cookie` had to have been set with "`SameSite=None`" to enable cross-site usage.',
  /**
   *@description Tooltip to explain why an attempt to set a cookie via a `Set-Cookie` HTTP header on a request's response was blocked.
   */
  blockedReasonSameSiteNoneInsecure: 'This attempt to set a cookie via a `Set-Cookie` header was blocked because it had the "`SameSite=None`" attribute but did not have the "Secure" attribute, which is required in order to use "`SameSite=None`".',
  /**
   *@description Tooltip to explain why an attempt to set a cookie via a `Set-Cookie` HTTP header on a request's response was blocked.
   */
  blockedReasonOverwriteSecure: "This attempt to set a cookie via a `Set-Cookie` header was blocked because it was not sent over a secure connection and would have overwritten a cookie with the Secure attribute.",
  /**
   *@description Tooltip to explain why an attempt to set a cookie via a `Set-Cookie` HTTP header on a request's response was blocked.
   */
  blockedReasonInvalidDomain: "This attempt to set a cookie via a `Set-Cookie` header was blocked because its Domain attribute was invalid with regards to the current host url.",
  /**
   *@description Tooltip to explain why an attempt to set a cookie via a `Set-Cookie` HTTP header on a request's response was blocked.
   */
  blockedReasonInvalidPrefix: 'This attempt to set a cookie via a `Set-Cookie` header was blocked because it used the "`__Secure-`" or "`__Host-`" prefix in its name and broke the additional rules applied to cookies with these prefixes as defined in `https://tools.ietf.org/html/draft-west-cookie-prefixes-05`.',
  /**
   *@description Tooltip to explain why a cookie was blocked when the size of the #name plus the size of the value exceeds the max size.
   */
  thisSetcookieWasBlockedBecauseTheNameValuePairExceedsMaxSize: "This attempt to set a cookie via a `Set-Cookie` header was blocked because the cookie was too large. The combined size of the name and value must be less than or equal to 4096 characters.",
  /**
   *@description Text in Network Manager
   *@example {https://example.com} PH1
   */
  setcookieHeaderIsIgnoredIn: "Set-Cookie header is ignored in response from url: {PH1}. The combined size of the name and value must be less than or equal to 4096 characters.",
  /**
   *@description Tooltip to explain why the cookie should have been blocked by third-party cookie phaseout but is exempted.
   */
  exemptionReasonUserSetting: "This cookie is allowed by user preference.",
  /**
   *@description Tooltip to explain why the cookie should have been blocked by third-party cookie phaseout but is exempted.
   */
  exemptionReasonTPCDMetadata: "This cookie is allowed by a third-party cookie deprecation trial grace period. Learn more: goo.gle/dt-grace.",
  /**
   *@description Tooltip to explain why the cookie should have been blocked by third-party cookie phaseout but is exempted.
   */
  exemptionReasonTPCDDeprecationTrial: "This cookie is allowed by third-party cookie deprecation trial. Learn more: goo.gle/ps-dt.",
  /**
   *@description Tooltip to explain why the cookie should have been blocked by third-party cookie phaseout but is exempted.
   */
  exemptionReasonTopLevelTPCDDeprecationTrial: "This cookie is allowed by top-level third-party cookie deprecation trial. Learn more: goo.gle/ps-dt.",
  /**
   *@description Tooltip to explain why the cookie should have been blocked by third-party cookie phaseout but is exempted.
   */
  exemptionReasonTPCDHeuristics: "This cookie is allowed by third-party cookie heuristics. Learn more: goo.gle/hbe",
  /**
   *@description Tooltip to explain why the cookie should have been blocked by third-party cookie phaseout but is exempted.
   */
  exemptionReasonEnterprisePolicy: "This cookie is allowed by Chrome Enterprise policy. Learn more: goo.gle/ce-3pc",
  /**
   *@description Tooltip to explain why the cookie should have been blocked by third-party cookie phaseout but is exempted.
   */
  exemptionReasonStorageAccessAPI: "This cookie is allowed by the Storage Access API. Learn more: goo.gle/saa",
  /**
   *@description Tooltip to explain why the cookie should have been blocked by third-party cookie phaseout but is exempted.
   */
  exemptionReasonTopLevelStorageAccessAPI: "This cookie is allowed by the top-level Storage Access API. Learn more: goo.gle/saa-top",
  /**
   *@description Tooltip to explain why the cookie should have been blocked by third-party cookie phaseout but is exempted.
   */
  exemptionReasonScheme: "This cookie is allowed by the top-level url scheme"
};
var str_9 = i18n21.i18n.registerUIStrings("core/sdk/NetworkRequest.ts", UIStrings9);
var i18nString9 = i18n21.i18n.getLocalizedString.bind(void 0, str_9);
var NetworkRequest = class _NetworkRequest extends Common25.ObjectWrapper.ObjectWrapper {
  #requestIdInternal;
  #backendRequestIdInternal;
  #documentURLInternal;
  #frameIdInternal;
  #loaderIdInternal;
  #hasUserGesture;
  #initiatorInternal;
  #redirectSourceInternal;
  #preflightRequestInternal;
  #preflightInitiatorRequestInternal;
  #isRedirectInternal;
  #redirectDestinationInternal;
  #issueTimeInternal;
  #startTimeInternal;
  #endTimeInternal;
  #blockedReasonInternal;
  #corsErrorStatusInternal;
  statusCode;
  statusText;
  requestMethod;
  requestTime;
  protocol;
  alternateProtocolUsage;
  mixedContentType;
  #initialPriorityInternal;
  #currentPriority;
  #signedExchangeInfoInternal;
  #webBundleInfoInternal;
  #webBundleInnerRequestInfoInternal;
  #resourceTypeInternal;
  #contentDataInternal;
  #streamingContentData;
  #framesInternal;
  #responseHeaderValues;
  #responseHeadersTextInternal;
  #originalResponseHeaders;
  #sortedOriginalResponseHeaders;
  // This field is only used when intercepting and overriding requests, because
  // in that case 'this.responseHeaders' does not contain 'set-cookie' headers.
  #setCookieHeaders;
  #requestHeadersInternal;
  #requestHeaderValues;
  #remoteAddressInternal;
  #remoteAddressSpaceInternal;
  #referrerPolicyInternal;
  #securityStateInternal;
  #securityDetailsInternal;
  connectionId;
  connectionReused;
  hasNetworkData;
  #formParametersPromise;
  #requestFormDataPromise;
  #hasExtraRequestInfoInternal;
  #hasExtraResponseInfoInternal;
  #blockedRequestCookiesInternal;
  #includedRequestCookiesInternal;
  #blockedResponseCookiesInternal;
  #exemptedResponseCookiesInternal;
  #responseCookiesPartitionKey;
  #responseCookiesPartitionKeyOpaque;
  #siteHasCookieInOtherPartition;
  localizedFailDescription;
  #urlInternal;
  #responseReceivedTimeInternal;
  #transferSizeInternal;
  #finishedInternal;
  #failedInternal;
  #canceledInternal;
  #preservedInternal;
  #mimeTypeInternal;
  #charset;
  #parsedURLInternal;
  #nameInternal;
  #pathInternal;
  #clientSecurityStateInternal;
  #trustTokenParamsInternal;
  #trustTokenOperationDoneEventInternal;
  #responseCacheStorageCacheName;
  #serviceWorkerResponseSourceInternal;
  #wallIssueTime;
  #responseRetrievalTime;
  #resourceSizeInternal;
  #fromMemoryCache;
  #fromDiskCache;
  #fromPrefetchCacheInternal;
  #fromEarlyHints;
  #fetchedViaServiceWorkerInternal;
  #serviceWorkerRouterInfoInternal;
  #timingInternal;
  #requestHeadersTextInternal;
  #responseHeadersInternal;
  #earlyHintsHeadersInternal;
  #sortedResponseHeadersInternal;
  #responseCookiesInternal;
  #serverTimingsInternal;
  #queryStringInternal;
  #parsedQueryParameters;
  #contentDataProvider;
  #isSameSiteInternal;
  #wasIntercepted;
  #associatedData = /* @__PURE__ */ new Map();
  #hasOverriddenContent;
  #hasThirdPartyCookiePhaseoutIssue;
  #serverSentEvents;
  responseReceivedPromise;
  responseReceivedPromiseResolve;
  constructor(requestId, backendRequestId, url, documentURL, frameId, loaderId, initiator, hasUserGesture) {
    super();
    this.#requestIdInternal = requestId;
    this.#backendRequestIdInternal = backendRequestId;
    this.setUrl(url);
    this.#documentURLInternal = documentURL;
    this.#frameIdInternal = frameId;
    this.#loaderIdInternal = loaderId;
    this.#initiatorInternal = initiator;
    this.#hasUserGesture = hasUserGesture;
    this.#redirectSourceInternal = null;
    this.#preflightRequestInternal = null;
    this.#preflightInitiatorRequestInternal = null;
    this.#isRedirectInternal = false;
    this.#redirectDestinationInternal = null;
    this.#issueTimeInternal = -1;
    this.#startTimeInternal = -1;
    this.#endTimeInternal = -1;
    this.#blockedReasonInternal = void 0;
    this.#corsErrorStatusInternal = void 0;
    this.statusCode = 0;
    this.statusText = "";
    this.requestMethod = "";
    this.requestTime = 0;
    this.protocol = "";
    this.alternateProtocolUsage = void 0;
    this.mixedContentType = Security.MixedContentType.None;
    this.#initialPriorityInternal = null;
    this.#currentPriority = null;
    this.#signedExchangeInfoInternal = null;
    this.#webBundleInfoInternal = null;
    this.#webBundleInnerRequestInfoInternal = null;
    this.#resourceTypeInternal = Common25.ResourceType.resourceTypes.Other;
    this.#contentDataInternal = null;
    this.#streamingContentData = null;
    this.#framesInternal = [];
    this.#responseHeaderValues = {};
    this.#responseHeadersTextInternal = "";
    this.#originalResponseHeaders = [];
    this.#setCookieHeaders = [];
    this.#requestHeadersInternal = [];
    this.#requestHeaderValues = {};
    this.#remoteAddressInternal = "";
    this.#remoteAddressSpaceInternal = Network.IPAddressSpace.Unknown;
    this.#referrerPolicyInternal = null;
    this.#securityStateInternal = Security.SecurityState.Unknown;
    this.#securityDetailsInternal = null;
    this.connectionId = "0";
    this.connectionReused = false;
    this.hasNetworkData = false;
    this.#formParametersPromise = null;
    this.#requestFormDataPromise = Promise.resolve(null);
    this.#hasExtraRequestInfoInternal = false;
    this.#hasExtraResponseInfoInternal = false;
    this.#blockedRequestCookiesInternal = [];
    this.#includedRequestCookiesInternal = [];
    this.#blockedResponseCookiesInternal = [];
    this.#exemptedResponseCookiesInternal = [];
    this.#siteHasCookieInOtherPartition = false;
    this.#responseCookiesPartitionKey = null;
    this.#responseCookiesPartitionKeyOpaque = null;
    this.localizedFailDescription = null;
    this.#isSameSiteInternal = null;
    this.#wasIntercepted = false;
    this.#hasOverriddenContent = false;
    this.#hasThirdPartyCookiePhaseoutIssue = false;
  }
  static create(backendRequestId, url, documentURL, frameId, loaderId, initiator, hasUserGesture) {
    return new _NetworkRequest(
      backendRequestId,
      backendRequestId,
      url,
      documentURL,
      frameId,
      loaderId,
      initiator,
      hasUserGesture
    );
  }
  static createForWebSocket(backendRequestId, requestURL, initiator) {
    return new _NetworkRequest(
      backendRequestId,
      backendRequestId,
      requestURL,
      Platform19.DevToolsPath.EmptyUrlString,
      null,
      null,
      initiator || null
    );
  }
  static createWithoutBackendRequest(requestId, url, documentURL, initiator) {
    return new _NetworkRequest(requestId, void 0, url, documentURL, null, null, initiator);
  }
  identityCompare(other) {
    const thisId = this.requestId();
    const thatId = other.requestId();
    if (thisId > thatId) {
      return 1;
    }
    if (thisId < thatId) {
      return -1;
    }
    return 0;
  }
  requestId() {
    return this.#requestIdInternal;
  }
  backendRequestId() {
    return this.#backendRequestIdInternal;
  }
  url() {
    return this.#urlInternal;
  }
  isBlobRequest() {
    return Common25.ParsedURL.schemeIs(this.#urlInternal, "blob:");
  }
  setUrl(x) {
    if (this.#urlInternal === x) {
      return;
    }
    this.#urlInternal = x;
    this.#parsedURLInternal = new Common25.ParsedURL.ParsedURL(x);
    this.#queryStringInternal = void 0;
    this.#parsedQueryParameters = void 0;
    this.#nameInternal = void 0;
    this.#pathInternal = void 0;
  }
  get documentURL() {
    return this.#documentURLInternal;
  }
  get parsedURL() {
    return this.#parsedURLInternal;
  }
  get frameId() {
    return this.#frameIdInternal;
  }
  get loaderId() {
    return this.#loaderIdInternal;
  }
  setRemoteAddress(ip, port) {
    this.#remoteAddressInternal = ip + ":" + port;
    this.dispatchEventToListeners("RemoteAddressChanged", this);
  }
  remoteAddress() {
    return this.#remoteAddressInternal;
  }
  remoteAddressSpace() {
    return this.#remoteAddressSpaceInternal;
  }
  /**
   * The cache #name of the CacheStorage from where the response is served via
   * the ServiceWorker.
   */
  getResponseCacheStorageCacheName() {
    return this.#responseCacheStorageCacheName;
  }
  setResponseCacheStorageCacheName(x) {
    this.#responseCacheStorageCacheName = x;
  }
  serviceWorkerResponseSource() {
    return this.#serviceWorkerResponseSourceInternal;
  }
  setServiceWorkerResponseSource(serviceWorkerResponseSource) {
    this.#serviceWorkerResponseSourceInternal = serviceWorkerResponseSource;
  }
  setReferrerPolicy(referrerPolicy) {
    this.#referrerPolicyInternal = referrerPolicy;
  }
  referrerPolicy() {
    return this.#referrerPolicyInternal;
  }
  securityState() {
    return this.#securityStateInternal;
  }
  setSecurityState(securityState) {
    this.#securityStateInternal = securityState;
  }
  securityDetails() {
    return this.#securityDetailsInternal;
  }
  securityOrigin() {
    return this.#parsedURLInternal.securityOrigin();
  }
  setSecurityDetails(securityDetails) {
    this.#securityDetailsInternal = securityDetails;
  }
  get startTime() {
    return this.#startTimeInternal || -1;
  }
  setIssueTime(monotonicTime, wallTime) {
    this.#issueTimeInternal = monotonicTime;
    this.#wallIssueTime = wallTime;
    this.#startTimeInternal = monotonicTime;
  }
  issueTime() {
    return this.#issueTimeInternal;
  }
  pseudoWallTime(monotonicTime) {
    return this.#wallIssueTime ? this.#wallIssueTime - this.#issueTimeInternal + monotonicTime : monotonicTime;
  }
  get responseReceivedTime() {
    return this.#responseReceivedTimeInternal || -1;
  }
  set responseReceivedTime(x) {
    this.#responseReceivedTimeInternal = x;
  }
  /**
   * The time at which the returned response was generated. For cached
   * responses, this is the last time the cache entry was validated.
   */
  getResponseRetrievalTime() {
    return this.#responseRetrievalTime;
  }
  setResponseRetrievalTime(x) {
    this.#responseRetrievalTime = x;
  }
  get endTime() {
    return this.#endTimeInternal || -1;
  }
  set endTime(x) {
    if (this.timing && this.timing.requestTime) {
      this.#endTimeInternal = Math.max(x, this.responseReceivedTime);
    } else {
      this.#endTimeInternal = x;
      if (this.#responseReceivedTimeInternal > x) {
        this.#responseReceivedTimeInternal = x;
      }
    }
    this.dispatchEventToListeners("TimingChanged", this);
  }
  get duration() {
    if (this.#endTimeInternal === -1 || this.#startTimeInternal === -1) {
      return -1;
    }
    return this.#endTimeInternal - this.#startTimeInternal;
  }
  get latency() {
    if (this.#responseReceivedTimeInternal === -1 || this.#startTimeInternal === -1) {
      return -1;
    }
    return this.#responseReceivedTimeInternal - this.#startTimeInternal;
  }
  get resourceSize() {
    return this.#resourceSizeInternal || 0;
  }
  set resourceSize(x) {
    this.#resourceSizeInternal = x;
  }
  get transferSize() {
    return this.#transferSizeInternal || 0;
  }
  increaseTransferSize(x) {
    this.#transferSizeInternal = (this.#transferSizeInternal || 0) + x;
  }
  setTransferSize(x) {
    this.#transferSizeInternal = x;
  }
  get finished() {
    return this.#finishedInternal;
  }
  set finished(x) {
    if (this.#finishedInternal === x) {
      return;
    }
    this.#finishedInternal = x;
    if (x) {
      this.dispatchEventToListeners("FinishedLoading", this);
    }
  }
  get failed() {
    return this.#failedInternal;
  }
  set failed(x) {
    this.#failedInternal = x;
  }
  get canceled() {
    return this.#canceledInternal;
  }
  set canceled(x) {
    this.#canceledInternal = x;
  }
  get preserved() {
    return this.#preservedInternal;
  }
  set preserved(x) {
    this.#preservedInternal = x;
  }
  blockedReason() {
    return this.#blockedReasonInternal;
  }
  setBlockedReason(reason) {
    this.#blockedReasonInternal = reason;
  }
  corsErrorStatus() {
    return this.#corsErrorStatusInternal;
  }
  setCorsErrorStatus(corsErrorStatus) {
    this.#corsErrorStatusInternal = corsErrorStatus;
  }
  wasBlocked() {
    return Boolean(this.#blockedReasonInternal);
  }
  cached() {
    return (Boolean(this.#fromMemoryCache) || Boolean(this.#fromDiskCache)) && !this.#transferSizeInternal;
  }
  cachedInMemory() {
    return Boolean(this.#fromMemoryCache) && !this.#transferSizeInternal;
  }
  fromPrefetchCache() {
    return Boolean(this.#fromPrefetchCacheInternal);
  }
  setFromMemoryCache() {
    this.#fromMemoryCache = true;
    this.#timingInternal = void 0;
  }
  get fromDiskCache() {
    return this.#fromDiskCache;
  }
  setFromDiskCache() {
    this.#fromDiskCache = true;
  }
  setFromPrefetchCache() {
    this.#fromPrefetchCacheInternal = true;
  }
  fromEarlyHints() {
    return Boolean(this.#fromEarlyHints);
  }
  setFromEarlyHints() {
    this.#fromEarlyHints = true;
  }
  /**
   * Returns true if the request was intercepted by a service worker and it
   * provided its own response.
   */
  get fetchedViaServiceWorker() {
    return Boolean(this.#fetchedViaServiceWorkerInternal);
  }
  set fetchedViaServiceWorker(x) {
    this.#fetchedViaServiceWorkerInternal = x;
  }
  get serviceWorkerRouterInfo() {
    return this.#serviceWorkerRouterInfoInternal;
  }
  set serviceWorkerRouterInfo(x) {
    this.#serviceWorkerRouterInfoInternal = x;
  }
  /**
   * Returns true if the request was sent by a service worker.
   */
  initiatedByServiceWorker() {
    const networkManager = NetworkManager.forRequest(this);
    if (!networkManager) {
      return false;
    }
    return networkManager.target().type() === Type2.ServiceWorker;
  }
  get timing() {
    return this.#timingInternal;
  }
  set timing(timingInfo) {
    if (!timingInfo || this.#fromMemoryCache) {
      return;
    }
    this.#startTimeInternal = timingInfo.requestTime;
    const headersReceivedTime = timingInfo.requestTime + timingInfo.receiveHeadersEnd / 1e3;
    if ((this.#responseReceivedTimeInternal || -1) < 0 || this.#responseReceivedTimeInternal > headersReceivedTime) {
      this.#responseReceivedTimeInternal = headersReceivedTime;
    }
    if (this.#startTimeInternal > this.#responseReceivedTimeInternal) {
      this.#responseReceivedTimeInternal = this.#startTimeInternal;
    }
    this.#timingInternal = timingInfo;
    this.dispatchEventToListeners("TimingChanged", this);
  }
  setConnectTimingFromExtraInfo(connectTiming) {
    this.#startTimeInternal = connectTiming.requestTime;
    this.dispatchEventToListeners("TimingChanged", this);
  }
  get mimeType() {
    return this.#mimeTypeInternal;
  }
  set mimeType(x) {
    this.#mimeTypeInternal = x;
    if (x === Platform19.MimeType.MimeType.EVENTSTREAM && !this.#serverSentEvents) {
      const parseFromStreamedData = this.resourceType() !== Common25.ResourceType.resourceTypes.EventSource;
      this.#serverSentEvents = new ServerSentEvents(this, parseFromStreamedData);
    }
  }
  get displayName() {
    return this.#parsedURLInternal.displayName;
  }
  name() {
    if (this.#nameInternal) {
      return this.#nameInternal;
    }
    this.parseNameAndPathFromURL();
    return this.#nameInternal;
  }
  path() {
    if (this.#pathInternal) {
      return this.#pathInternal;
    }
    this.parseNameAndPathFromURL();
    return this.#pathInternal;
  }
  parseNameAndPathFromURL() {
    if (this.#parsedURLInternal.isDataURL()) {
      this.#nameInternal = this.#parsedURLInternal.dataURLDisplayName();
      this.#pathInternal = "";
    } else if (this.#parsedURLInternal.isBlobURL()) {
      this.#nameInternal = this.#parsedURLInternal.url;
      this.#pathInternal = "";
    } else if (this.#parsedURLInternal.isAboutBlank()) {
      this.#nameInternal = this.#parsedURLInternal.url;
      this.#pathInternal = "";
    } else {
      this.#pathInternal = this.#parsedURLInternal.host + this.#parsedURLInternal.folderPathComponents;
      const networkManager = NetworkManager.forRequest(this);
      const inspectedURL = networkManager ? Common25.ParsedURL.ParsedURL.fromString(networkManager.target().inspectedURL()) : null;
      this.#pathInternal = Platform19.StringUtilities.trimURL(this.#pathInternal, inspectedURL ? inspectedURL.host : "");
      if (this.#parsedURLInternal.lastPathComponent || this.#parsedURLInternal.queryParams) {
        this.#nameInternal = this.#parsedURLInternal.lastPathComponent + (this.#parsedURLInternal.queryParams ? "?" + this.#parsedURLInternal.queryParams : "");
      } else if (this.#parsedURLInternal.folderPathComponents) {
        this.#nameInternal = this.#parsedURLInternal.folderPathComponents.substring(
          this.#parsedURLInternal.folderPathComponents.lastIndexOf("/") + 1
        ) + "/";
        this.#pathInternal = this.#pathInternal.substring(0, this.#pathInternal.lastIndexOf("/"));
      } else {
        this.#nameInternal = this.#parsedURLInternal.host;
        this.#pathInternal = "";
      }
    }
  }
  get folder() {
    let path = this.#parsedURLInternal.path;
    const indexOfQuery = path.indexOf("?");
    if (indexOfQuery !== -1) {
      path = path.substring(0, indexOfQuery);
    }
    const lastSlashIndex = path.lastIndexOf("/");
    return lastSlashIndex !== -1 ? path.substring(0, lastSlashIndex) : "";
  }
  get pathname() {
    return this.#parsedURLInternal.path;
  }
  resourceType() {
    return this.#resourceTypeInternal;
  }
  setResourceType(resourceType) {
    this.#resourceTypeInternal = resourceType;
  }
  get domain() {
    return this.#parsedURLInternal.host;
  }
  get scheme() {
    return this.#parsedURLInternal.scheme;
  }
  getInferredStatusText() {
    return this.statusText || getStatusText(this.statusCode);
  }
  redirectSource() {
    return this.#redirectSourceInternal;
  }
  setRedirectSource(originatingRequest) {
    this.#redirectSourceInternal = originatingRequest;
  }
  preflightRequest() {
    return this.#preflightRequestInternal;
  }
  setPreflightRequest(preflightRequest) {
    this.#preflightRequestInternal = preflightRequest;
  }
  preflightInitiatorRequest() {
    return this.#preflightInitiatorRequestInternal;
  }
  setPreflightInitiatorRequest(preflightInitiatorRequest) {
    this.#preflightInitiatorRequestInternal = preflightInitiatorRequest;
  }
  isPreflightRequest() {
    return this.#initiatorInternal !== null && this.#initiatorInternal !== void 0 && this.#initiatorInternal.type === Network.InitiatorType.Preflight;
  }
  redirectDestination() {
    return this.#redirectDestinationInternal;
  }
  setRedirectDestination(redirectDestination) {
    this.#redirectDestinationInternal = redirectDestination;
  }
  requestHeaders() {
    return this.#requestHeadersInternal;
  }
  setRequestHeaders(headers) {
    this.#requestHeadersInternal = headers;
    this.dispatchEventToListeners(
      "RequestHeadersChanged"
      /* REQUEST_HEADERS_CHANGED */
    );
  }
  requestHeadersText() {
    return this.#requestHeadersTextInternal;
  }
  setRequestHeadersText(text) {
    this.#requestHeadersTextInternal = text;
    this.dispatchEventToListeners(
      "RequestHeadersChanged"
      /* REQUEST_HEADERS_CHANGED */
    );
  }
  requestHeaderValue(headerName) {
    if (this.#requestHeaderValues[headerName]) {
      return this.#requestHeaderValues[headerName];
    }
    this.#requestHeaderValues[headerName] = this.computeHeaderValue(this.requestHeaders(), headerName);
    return this.#requestHeaderValues[headerName];
  }
  requestFormData() {
    if (!this.#requestFormDataPromise) {
      this.#requestFormDataPromise = NetworkManager.requestPostData(this);
    }
    return this.#requestFormDataPromise;
  }
  setRequestFormData(hasData, data) {
    this.#requestFormDataPromise = hasData && data === null ? null : Promise.resolve(data);
    this.#formParametersPromise = null;
  }
  filteredProtocolName() {
    const protocol = this.protocol.toLowerCase();
    if (protocol === "h2") {
      return "http/2.0";
    }
    return protocol.replace(/^http\/2(\.0)?\+/, "http/2.0+");
  }
  requestHttpVersion() {
    const headersText = this.requestHeadersText();
    if (!headersText) {
      const version = this.requestHeaderValue("version") || this.requestHeaderValue(":version");
      if (version) {
        return version;
      }
      return this.filteredProtocolName();
    }
    const firstLine = headersText.split(/\r\n/)[0];
    const match = firstLine.match(/(HTTP\/\d+\.\d+)$/);
    return match ? match[1] : "HTTP/0.9";
  }
  get responseHeaders() {
    return this.#responseHeadersInternal || [];
  }
  set responseHeaders(x) {
    this.#responseHeadersInternal = x;
    this.#sortedResponseHeadersInternal = void 0;
    this.#serverTimingsInternal = void 0;
    this.#responseCookiesInternal = void 0;
    this.#responseHeaderValues = {};
    this.dispatchEventToListeners(
      "ResponseHeadersChanged"
      /* RESPONSE_HEADERS_CHANGED */
    );
  }
  get earlyHintsHeaders() {
    return this.#earlyHintsHeadersInternal || [];
  }
  set earlyHintsHeaders(x) {
    this.#earlyHintsHeadersInternal = x;
  }
  get originalResponseHeaders() {
    return this.#originalResponseHeaders;
  }
  set originalResponseHeaders(headers) {
    this.#originalResponseHeaders = headers;
    this.#sortedOriginalResponseHeaders = void 0;
  }
  get setCookieHeaders() {
    return this.#setCookieHeaders;
  }
  set setCookieHeaders(headers) {
    this.#setCookieHeaders = headers;
  }
  get responseHeadersText() {
    return this.#responseHeadersTextInternal;
  }
  set responseHeadersText(x) {
    this.#responseHeadersTextInternal = x;
    this.dispatchEventToListeners(
      "ResponseHeadersChanged"
      /* RESPONSE_HEADERS_CHANGED */
    );
  }
  get sortedResponseHeaders() {
    if (this.#sortedResponseHeadersInternal !== void 0) {
      return this.#sortedResponseHeadersInternal;
    }
    this.#sortedResponseHeadersInternal = this.responseHeaders.slice();
    return this.#sortedResponseHeadersInternal.sort(function(a, b) {
      return Platform19.StringUtilities.compare(a.name.toLowerCase(), b.name.toLowerCase());
    });
  }
  get sortedOriginalResponseHeaders() {
    if (this.#sortedOriginalResponseHeaders !== void 0) {
      return this.#sortedOriginalResponseHeaders;
    }
    this.#sortedOriginalResponseHeaders = this.originalResponseHeaders.slice();
    return this.#sortedOriginalResponseHeaders.sort(function(a, b) {
      return Platform19.StringUtilities.compare(a.name.toLowerCase(), b.name.toLowerCase());
    });
  }
  get overrideTypes() {
    const types = [];
    if (this.hasOverriddenContent) {
      types.push("content");
    }
    if (this.hasOverriddenHeaders()) {
      types.push("headers");
    }
    return types;
  }
  get hasOverriddenContent() {
    return this.#hasOverriddenContent;
  }
  set hasOverriddenContent(value) {
    this.#hasOverriddenContent = value;
  }
  #deduplicateHeaders(sortedHeaders) {
    const dedupedHeaders = [];
    for (const header of sortedHeaders) {
      if (dedupedHeaders.length && dedupedHeaders[dedupedHeaders.length - 1].name === header.name) {
        dedupedHeaders[dedupedHeaders.length - 1].value += `, ${header.value}`;
      } else {
        dedupedHeaders.push({ name: header.name, value: header.value });
      }
    }
    return dedupedHeaders;
  }
  hasOverriddenHeaders() {
    if (!this.#originalResponseHeaders.length) {
      return false;
    }
    const responseHeaders = this.#deduplicateHeaders(this.sortedResponseHeaders);
    const originalResponseHeaders = this.#deduplicateHeaders(this.sortedOriginalResponseHeaders);
    if (responseHeaders.length !== originalResponseHeaders.length) {
      return true;
    }
    for (let i = 0; i < responseHeaders.length; i++) {
      if (responseHeaders[i].name.toLowerCase() !== originalResponseHeaders[i].name.toLowerCase()) {
        return true;
      }
      if (responseHeaders[i].value !== originalResponseHeaders[i].value) {
        return true;
      }
    }
    return false;
  }
  responseHeaderValue(headerName) {
    if (headerName in this.#responseHeaderValues) {
      return this.#responseHeaderValues[headerName];
    }
    this.#responseHeaderValues[headerName] = this.computeHeaderValue(this.responseHeaders, headerName);
    return this.#responseHeaderValues[headerName];
  }
  wasIntercepted() {
    return this.#wasIntercepted;
  }
  setWasIntercepted(wasIntercepted) {
    this.#wasIntercepted = wasIntercepted;
  }
  setEarlyHintsHeaders(headers) {
    this.earlyHintsHeaders = headers;
  }
  get responseCookies() {
    if (!this.#responseCookiesInternal) {
      this.#responseCookiesInternal = CookieParser.parseSetCookie(this.responseHeaderValue("Set-Cookie"), this.domain) || [];
      if (this.#responseCookiesPartitionKey) {
        for (const cookie of this.#responseCookiesInternal) {
          if (cookie.partitioned()) {
            cookie.setPartitionKey(
              this.#responseCookiesPartitionKey.topLevelSite,
              this.#responseCookiesPartitionKey.hasCrossSiteAncestor
            );
          }
        }
      } else if (this.#responseCookiesPartitionKeyOpaque) {
        for (const cookie of this.#responseCookiesInternal) {
          cookie.setPartitionKeyOpaque();
        }
      }
    }
    return this.#responseCookiesInternal;
  }
  responseLastModified() {
    return this.responseHeaderValue("last-modified");
  }
  allCookiesIncludingBlockedOnes() {
    return [
      ...this.includedRequestCookies().map((includedRequestCookie) => includedRequestCookie.cookie),
      ...this.responseCookies,
      ...this.blockedRequestCookies().map((blockedRequestCookie) => blockedRequestCookie.cookie),
      ...this.blockedResponseCookies().map((blockedResponseCookie) => blockedResponseCookie.cookie)
    ].filter((v) => Boolean(v));
  }
  get serverTimings() {
    if (typeof this.#serverTimingsInternal === "undefined") {
      this.#serverTimingsInternal = ServerTiming2.parseHeaders(this.responseHeaders);
    }
    return this.#serverTimingsInternal;
  }
  queryString() {
    if (this.#queryStringInternal !== void 0) {
      return this.#queryStringInternal;
    }
    let queryString = null;
    const url = this.url();
    const questionMarkPosition = url.indexOf("?");
    if (questionMarkPosition !== -1) {
      queryString = url.substring(questionMarkPosition + 1);
      const hashSignPosition = queryString.indexOf("#");
      if (hashSignPosition !== -1) {
        queryString = queryString.substring(0, hashSignPosition);
      }
    }
    this.#queryStringInternal = queryString;
    return this.#queryStringInternal;
  }
  get queryParameters() {
    if (this.#parsedQueryParameters) {
      return this.#parsedQueryParameters;
    }
    const queryString = this.queryString();
    if (!queryString) {
      return null;
    }
    this.#parsedQueryParameters = this.parseParameters(queryString);
    return this.#parsedQueryParameters;
  }
  async parseFormParameters() {
    const requestContentType = this.requestContentType();
    if (!requestContentType) {
      return null;
    }
    if (requestContentType.match(/^application\/x-www-form-urlencoded\s*(;.*)?$/i)) {
      const formData2 = await this.requestFormData();
      if (!formData2) {
        return null;
      }
      return this.parseParameters(formData2);
    }
    const multipartDetails = requestContentType.match(/^multipart\/form-data\s*;\s*boundary\s*=\s*(\S+)\s*$/);
    if (!multipartDetails) {
      return null;
    }
    const boundary = multipartDetails[1];
    if (!boundary) {
      return null;
    }
    const formData = await this.requestFormData();
    if (!formData) {
      return null;
    }
    return this.parseMultipartFormDataParameters(formData, boundary);
  }
  formParameters() {
    if (!this.#formParametersPromise) {
      this.#formParametersPromise = this.parseFormParameters();
    }
    return this.#formParametersPromise;
  }
  responseHttpVersion() {
    const headersText = this.#responseHeadersTextInternal;
    if (!headersText) {
      const version = this.responseHeaderValue("version") || this.responseHeaderValue(":version");
      if (version) {
        return version;
      }
      return this.filteredProtocolName();
    }
    const firstLine = headersText.split(/\r\n/)[0];
    const match = firstLine.match(/^(HTTP\/\d+\.\d+)/);
    return match ? match[1] : "HTTP/0.9";
  }
  parseParameters(queryString) {
    function parseNameValue(pair) {
      const position = pair.indexOf("=");
      if (position === -1) {
        return { name: pair, value: "" };
      }
      return { name: pair.substring(0, position), value: pair.substring(position + 1) };
    }
    return queryString.split("&").map(parseNameValue);
  }
  /**
   * Parses multipart/form-data; boundary=boundaryString request bodies -
   * --boundaryString
   * Content-Disposition: form-data; #name="field-#name"; filename="r.gif"
   * Content-Type: application/octet-stream
   *
   * optionalValue
   * --boundaryString
   * Content-Disposition: form-data; #name="field-#name-2"
   *
   * optionalValue2
   * --boundaryString--
   */
  parseMultipartFormDataParameters(data, boundary) {
    const sanitizedBoundary = Platform19.StringUtilities.escapeForRegExp(boundary);
    const keyValuePattern = new RegExp(
      // Header with an optional file #name.
      '^\\r\\ncontent-disposition\\s*:\\s*form-data\\s*;\\s*name="([^"]*)"(?:\\s*;\\s*filename="([^"]*)")?(?:\\r\\ncontent-type\\s*:\\s*([^\\r\\n]*))?\\r\\n\\r\\n(.*)\\r\\n$',
      "is"
    );
    const fields = data.split(new RegExp(`--${sanitizedBoundary}(?:--s*$)?`, "g"));
    return fields.reduce(parseMultipartField, []);
    function parseMultipartField(result, field) {
      const [match, name, filename, contentType, value] = field.match(keyValuePattern) || [];
      if (!match) {
        return result;
      }
      const processedValue = filename || contentType ? i18nString9(UIStrings9.binary) : value;
      result.push({ name, value: processedValue });
      return result;
    }
  }
  computeHeaderValue(headers, headerName) {
    headerName = headerName.toLowerCase();
    const values = [];
    for (let i = 0; i < headers.length; ++i) {
      if (headers[i].name.toLowerCase() === headerName) {
        values.push(headers[i].value);
      }
    }
    if (!values.length) {
      return void 0;
    }
    if (headerName === "set-cookie") {
      return values.join("\n");
    }
    return values.join(", ");
  }
  requestContentData() {
    if (this.#contentDataInternal) {
      return this.#contentDataInternal;
    }
    if (this.#contentDataProvider) {
      this.#contentDataInternal = this.#contentDataProvider();
    } else {
      this.#contentDataInternal = NetworkManager.requestContentData(this);
    }
    return this.#contentDataInternal;
  }
  setContentDataProvider(dataProvider) {
    console.assert(!this.#contentDataInternal, "contentData can only be set once.");
    this.#contentDataProvider = dataProvider;
  }
  requestStreamingContent() {
    if (this.#streamingContentData) {
      return this.#streamingContentData;
    }
    const contentPromise = this.finished ? this.requestContentData() : NetworkManager.streamResponseBody(this);
    this.#streamingContentData = contentPromise.then((contentData) => {
      if (TextUtils21.ContentData.ContentData.isError(contentData)) {
        return contentData;
      }
      return TextUtils21.StreamingContentData.StreamingContentData.from(contentData);
    });
    return this.#streamingContentData;
  }
  contentURL() {
    return this.#urlInternal;
  }
  contentType() {
    return this.#resourceTypeInternal;
  }
  async requestContent() {
    return TextUtils21.ContentData.ContentData.asDeferredContent(await this.requestContentData());
  }
  async searchInContent(query, caseSensitive, isRegex) {
    if (!this.#contentDataProvider) {
      return NetworkManager.searchInRequest(this, query, caseSensitive, isRegex);
    }
    const contentData = await this.requestContentData();
    if (TextUtils21.ContentData.ContentData.isError(contentData) || !contentData.isTextContent) {
      return [];
    }
    return TextUtils21.TextUtils.performSearchInContentData(contentData, query, caseSensitive, isRegex);
  }
  isHttpFamily() {
    return Boolean(this.url().match(/^https?:/i));
  }
  requestContentType() {
    return this.requestHeaderValue("Content-Type");
  }
  hasErrorStatusCode() {
    return this.statusCode >= 400;
  }
  setInitialPriority(priority) {
    this.#initialPriorityInternal = priority;
  }
  initialPriority() {
    return this.#initialPriorityInternal;
  }
  setPriority(priority) {
    this.#currentPriority = priority;
  }
  priority() {
    return this.#currentPriority || this.#initialPriorityInternal || null;
  }
  setSignedExchangeInfo(info) {
    this.#signedExchangeInfoInternal = info;
  }
  signedExchangeInfo() {
    return this.#signedExchangeInfoInternal;
  }
  setWebBundleInfo(info) {
    this.#webBundleInfoInternal = info;
  }
  webBundleInfo() {
    return this.#webBundleInfoInternal;
  }
  setWebBundleInnerRequestInfo(info) {
    this.#webBundleInnerRequestInfoInternal = info;
  }
  webBundleInnerRequestInfo() {
    return this.#webBundleInnerRequestInfoInternal;
  }
  async populateImageSource(image) {
    const contentData = await this.requestContentData();
    if (TextUtils21.ContentData.ContentData.isError(contentData)) {
      return;
    }
    let imageSrc = contentData.asDataUrl();
    if (imageSrc === null && !this.#failedInternal) {
      const cacheControl = this.responseHeaderValue("cache-control") || "";
      if (!cacheControl.includes("no-cache")) {
        imageSrc = this.#urlInternal;
      }
    }
    if (imageSrc !== null) {
      image.src = imageSrc;
    }
  }
  initiator() {
    return this.#initiatorInternal || null;
  }
  hasUserGesture() {
    return this.#hasUserGesture ?? null;
  }
  frames() {
    return this.#framesInternal;
  }
  addProtocolFrameError(errorMessage, time) {
    this.addFrame(
      { type: "error", text: errorMessage, time: this.pseudoWallTime(time), opCode: -1, mask: false }
    );
  }
  addProtocolFrame(response, time, sent) {
    const type = sent ? "send" : "receive";
    this.addFrame({
      type,
      text: response.payloadData,
      time: this.pseudoWallTime(time),
      opCode: response.opcode,
      mask: response.mask
    });
  }
  addFrame(frame) {
    this.#framesInternal.push(frame);
    this.dispatchEventToListeners("WebsocketFrameAdded", frame);
  }
  eventSourceMessages() {
    return this.#serverSentEvents?.eventSourceMessages ?? [];
  }
  addEventSourceMessage(time, eventName, eventId, data) {
    this.#serverSentEvents?.onProtocolEventSourceMessageReceived(eventName, data, eventId, this.pseudoWallTime(time));
  }
  markAsRedirect(redirectCount) {
    this.#isRedirectInternal = true;
    this.#requestIdInternal = `${this.#backendRequestIdInternal}:redirected.${redirectCount}`;
  }
  isRedirect() {
    return this.#isRedirectInternal;
  }
  setRequestIdForTest(requestId) {
    this.#backendRequestIdInternal = requestId;
    this.#requestIdInternal = requestId;
  }
  charset() {
    return this.#charset ?? null;
  }
  setCharset(charset) {
    this.#charset = charset;
  }
  addExtraRequestInfo(extraRequestInfo) {
    this.#blockedRequestCookiesInternal = extraRequestInfo.blockedRequestCookies;
    this.#includedRequestCookiesInternal = extraRequestInfo.includedRequestCookies;
    this.setRequestHeaders(extraRequestInfo.requestHeaders);
    this.#hasExtraRequestInfoInternal = true;
    this.setRequestHeadersText("");
    this.#clientSecurityStateInternal = extraRequestInfo.clientSecurityState;
    this.setConnectTimingFromExtraInfo(extraRequestInfo.connectTiming);
    this.#siteHasCookieInOtherPartition = extraRequestInfo.siteHasCookieInOtherPartition ?? false;
    this.#hasThirdPartyCookiePhaseoutIssue = this.#blockedRequestCookiesInternal.some(
      (item) => item.blockedReasons.includes(Network.CookieBlockedReason.ThirdPartyPhaseout)
    );
  }
  hasExtraRequestInfo() {
    return this.#hasExtraRequestInfoInternal;
  }
  blockedRequestCookies() {
    return this.#blockedRequestCookiesInternal;
  }
  includedRequestCookies() {
    return this.#includedRequestCookiesInternal;
  }
  hasRequestCookies() {
    return this.#includedRequestCookiesInternal.length > 0 || this.#blockedRequestCookiesInternal.length > 0;
  }
  siteHasCookieInOtherPartition() {
    return this.#siteHasCookieInOtherPartition;
  }
  // Parse the status text from the first line of the response headers text.
  // See net::HttpResponseHeaders::GetStatusText.
  static parseStatusTextFromResponseHeadersText(responseHeadersText) {
    const firstLineParts = responseHeadersText.split("\r")[0].split(" ");
    return firstLineParts.slice(2).join(" ");
  }
  addExtraResponseInfo(extraResponseInfo) {
    this.#blockedResponseCookiesInternal = extraResponseInfo.blockedResponseCookies;
    if (extraResponseInfo.exemptedResponseCookies) {
      this.#exemptedResponseCookiesInternal = extraResponseInfo.exemptedResponseCookies;
    }
    this.#responseCookiesPartitionKey = extraResponseInfo.cookiePartitionKey ? extraResponseInfo.cookiePartitionKey : null;
    this.#responseCookiesPartitionKeyOpaque = extraResponseInfo.cookiePartitionKeyOpaque || null;
    this.responseHeaders = extraResponseInfo.responseHeaders;
    this.originalResponseHeaders = extraResponseInfo.responseHeaders.map((headerEntry) => ({ ...headerEntry }));
    if (extraResponseInfo.responseHeadersText) {
      this.responseHeadersText = extraResponseInfo.responseHeadersText;
      if (!this.requestHeadersText()) {
        let requestHeadersText = `${this.requestMethod} ${this.parsedURL.path}`;
        if (this.parsedURL.queryParams) {
          requestHeadersText += `?${this.parsedURL.queryParams}`;
        }
        requestHeadersText += " HTTP/1.1\r\n";
        for (const { name, value } of this.requestHeaders()) {
          requestHeadersText += `${name}: ${value}\r
`;
        }
        this.setRequestHeadersText(requestHeadersText);
      }
      this.statusText = _NetworkRequest.parseStatusTextFromResponseHeadersText(extraResponseInfo.responseHeadersText);
    }
    this.#remoteAddressSpaceInternal = extraResponseInfo.resourceIPAddressSpace;
    if (extraResponseInfo.statusCode) {
      this.statusCode = extraResponseInfo.statusCode;
    }
    this.#hasExtraResponseInfoInternal = true;
    const networkManager = NetworkManager.forRequest(this);
    if (!networkManager) {
      return;
    }
    for (const blockedCookie of this.#blockedResponseCookiesInternal) {
      if (blockedCookie.blockedReasons.includes(Network.SetCookieBlockedReason.NameValuePairExceedsMaxSize)) {
        const message = i18nString9(UIStrings9.setcookieHeaderIsIgnoredIn, { PH1: this.url() });
        networkManager.dispatchEventToListeners(
          Events3.MessageGenerated,
          { message, requestId: this.#requestIdInternal, warning: true }
        );
      }
    }
    const cookieModel = networkManager.target().model(CookieModel);
    if (!cookieModel) {
      return;
    }
    for (const exemptedCookie of this.#exemptedResponseCookiesInternal) {
      cookieModel.removeBlockedCookie(exemptedCookie.cookie);
    }
    for (const blockedCookie of this.#blockedResponseCookiesInternal) {
      const cookie = blockedCookie.cookie;
      if (!cookie) {
        continue;
      }
      if (blockedCookie.blockedReasons.includes(Network.SetCookieBlockedReason.ThirdPartyPhaseout)) {
        this.#hasThirdPartyCookiePhaseoutIssue = true;
      }
      cookieModel.addBlockedCookie(
        cookie,
        blockedCookie.blockedReasons.map((blockedReason) => ({
          attribute: setCookieBlockedReasonToAttribute(blockedReason),
          uiString: setCookieBlockedReasonToUiString(blockedReason)
        }))
      );
    }
  }
  hasExtraResponseInfo() {
    return this.#hasExtraResponseInfoInternal;
  }
  blockedResponseCookies() {
    return this.#blockedResponseCookiesInternal;
  }
  exemptedResponseCookies() {
    return this.#exemptedResponseCookiesInternal;
  }
  nonBlockedResponseCookies() {
    const blockedCookieLines = this.blockedResponseCookies().map((blockedCookie) => blockedCookie.cookieLine);
    const responseCookies = this.responseCookies.filter((cookie) => {
      const index = blockedCookieLines.indexOf(cookie.getCookieLine());
      if (index !== -1) {
        blockedCookieLines[index] = null;
        return false;
      }
      return true;
    });
    return responseCookies;
  }
  responseCookiesPartitionKey() {
    return this.#responseCookiesPartitionKey;
  }
  responseCookiesPartitionKeyOpaque() {
    return this.#responseCookiesPartitionKeyOpaque;
  }
  redirectSourceSignedExchangeInfoHasNoErrors() {
    return this.#redirectSourceInternal !== null && this.#redirectSourceInternal.#signedExchangeInfoInternal !== null && !this.#redirectSourceInternal.#signedExchangeInfoInternal.errors;
  }
  clientSecurityState() {
    return this.#clientSecurityStateInternal;
  }
  setTrustTokenParams(trustTokenParams) {
    this.#trustTokenParamsInternal = trustTokenParams;
  }
  trustTokenParams() {
    return this.#trustTokenParamsInternal;
  }
  setTrustTokenOperationDoneEvent(doneEvent) {
    this.#trustTokenOperationDoneEventInternal = doneEvent;
    this.dispatchEventToListeners(
      "TrustTokenResultAdded"
      /* TRUST_TOKEN_RESULT_ADDED */
    );
  }
  trustTokenOperationDoneEvent() {
    return this.#trustTokenOperationDoneEventInternal;
  }
  setIsSameSite(isSameSite) {
    this.#isSameSiteInternal = isSameSite;
  }
  isSameSite() {
    return this.#isSameSiteInternal;
  }
  getAssociatedData(key) {
    return this.#associatedData.get(key) || null;
  }
  setAssociatedData(key, data) {
    this.#associatedData.set(key, data);
  }
  deleteAssociatedData(key) {
    this.#associatedData.delete(key);
  }
  hasThirdPartyCookiePhaseoutIssue() {
    return this.#hasThirdPartyCookiePhaseoutIssue;
  }
  addDataReceivedEvent({ timestamp, dataLength, encodedDataLength, data }) {
    this.resourceSize += dataLength;
    if (encodedDataLength !== -1) {
      this.increaseTransferSize(encodedDataLength);
    }
    this.endTime = timestamp;
    if (data) {
      void this.#streamingContentData?.then((contentData) => {
        if (!TextUtils21.StreamingContentData.isError(contentData)) {
          contentData.addChunk(data);
        }
      });
    }
  }
  waitForResponseReceived() {
    if (this.responseReceivedPromise) {
      return this.responseReceivedPromise;
    }
    const { promise, resolve } = Promise.withResolvers();
    this.responseReceivedPromise = promise;
    this.responseReceivedPromiseResolve = resolve;
    return this.responseReceivedPromise;
  }
};
var Events2 = /* @__PURE__ */ ((Events210) => {
  Events210["FINISHED_LOADING"] = "FinishedLoading";
  Events210["TIMING_CHANGED"] = "TimingChanged";
  Events210["REMOTE_ADDRESS_CHANGED"] = "RemoteAddressChanged";
  Events210["REQUEST_HEADERS_CHANGED"] = "RequestHeadersChanged";
  Events210["RESPONSE_HEADERS_CHANGED"] = "ResponseHeadersChanged";
  Events210["WEBSOCKET_FRAME_ADDED"] = "WebsocketFrameAdded";
  Events210["EVENT_SOURCE_MESSAGE_ADDED"] = "EventSourceMessageAdded";
  Events210["TRUST_TOKEN_RESULT_ADDED"] = "TrustTokenResultAdded";
  return Events210;
})(Events2 || {});
var InitiatorType = /* @__PURE__ */ ((InitiatorType2) => {
  InitiatorType2["OTHER"] = "other";
  InitiatorType2["PARSER"] = "parser";
  InitiatorType2["REDIRECT"] = "redirect";
  InitiatorType2["SCRIPT"] = "script";
  InitiatorType2["PRELOAD"] = "preload";
  InitiatorType2["SIGNED_EXCHANGE"] = "signedExchange";
  InitiatorType2["PREFLIGHT"] = "preflight";
  return InitiatorType2;
})(InitiatorType || {});
var WebSocketFrameType = /* @__PURE__ */ ((WebSocketFrameType2) => {
  WebSocketFrameType2["Send"] = "send";
  WebSocketFrameType2["Receive"] = "receive";
  WebSocketFrameType2["Error"] = "error";
  return WebSocketFrameType2;
})(WebSocketFrameType || {});
var cookieExemptionReasonToUiString = function(exemptionReason) {
  switch (exemptionReason) {
    case Network.CookieExemptionReason.UserSetting:
      return i18nString9(UIStrings9.exemptionReasonUserSetting);
    case Network.CookieExemptionReason.TPCDMetadata:
      return i18nString9(UIStrings9.exemptionReasonTPCDMetadata);
    case Network.CookieExemptionReason.TopLevelTPCDDeprecationTrial:
      return i18nString9(UIStrings9.exemptionReasonTopLevelTPCDDeprecationTrial);
    case Network.CookieExemptionReason.TPCDDeprecationTrial:
      return i18nString9(UIStrings9.exemptionReasonTPCDDeprecationTrial);
    case Network.CookieExemptionReason.TPCDHeuristics:
      return i18nString9(UIStrings9.exemptionReasonTPCDHeuristics);
    case Network.CookieExemptionReason.EnterprisePolicy:
      return i18nString9(UIStrings9.exemptionReasonEnterprisePolicy);
    case Network.CookieExemptionReason.StorageAccess:
      return i18nString9(UIStrings9.exemptionReasonStorageAccessAPI);
    case Network.CookieExemptionReason.TopLevelStorageAccess:
      return i18nString9(UIStrings9.exemptionReasonTopLevelStorageAccessAPI);
    case Network.CookieExemptionReason.Scheme:
      return i18nString9(UIStrings9.exemptionReasonScheme);
  }
  return "";
};
var cookieBlockedReasonToUiString = function(blockedReason) {
  switch (blockedReason) {
    case Network.CookieBlockedReason.SecureOnly:
      return i18nString9(UIStrings9.secureOnly);
    case Network.CookieBlockedReason.NotOnPath:
      return i18nString9(UIStrings9.notOnPath);
    case Network.CookieBlockedReason.DomainMismatch:
      return i18nString9(UIStrings9.domainMismatch);
    case Network.CookieBlockedReason.SameSiteStrict:
      return i18nString9(UIStrings9.sameSiteStrict);
    case Network.CookieBlockedReason.SameSiteLax:
      return i18nString9(UIStrings9.sameSiteLax);
    case Network.CookieBlockedReason.SameSiteUnspecifiedTreatedAsLax:
      return i18nString9(UIStrings9.sameSiteUnspecifiedTreatedAsLax);
    case Network.CookieBlockedReason.SameSiteNoneInsecure:
      return i18nString9(UIStrings9.sameSiteNoneInsecure);
    case Network.CookieBlockedReason.UserPreferences:
      return i18nString9(UIStrings9.userPreferences);
    case Network.CookieBlockedReason.UnknownError:
      return i18nString9(UIStrings9.unknownError);
    case Network.CookieBlockedReason.SchemefulSameSiteStrict:
      return i18nString9(UIStrings9.schemefulSameSiteStrict);
    case Network.CookieBlockedReason.SchemefulSameSiteLax:
      return i18nString9(UIStrings9.schemefulSameSiteLax);
    case Network.CookieBlockedReason.SchemefulSameSiteUnspecifiedTreatedAsLax:
      return i18nString9(UIStrings9.schemefulSameSiteUnspecifiedTreatedAsLax);
    case Network.CookieBlockedReason.SamePartyFromCrossPartyContext:
      return i18nString9(UIStrings9.samePartyFromCrossPartyContext);
    case Network.CookieBlockedReason.NameValuePairExceedsMaxSize:
      return i18nString9(UIStrings9.nameValuePairExceedsMaxSize);
    case Network.CookieBlockedReason.ThirdPartyPhaseout:
      return i18nString9(UIStrings9.thirdPartyPhaseout);
  }
  return "";
};
var setCookieBlockedReasonToUiString = function(blockedReason) {
  switch (blockedReason) {
    case Network.SetCookieBlockedReason.SecureOnly:
      return i18nString9(UIStrings9.blockedReasonSecureOnly);
    case Network.SetCookieBlockedReason.SameSiteStrict:
      return i18nString9(UIStrings9.blockedReasonSameSiteStrictLax, { PH1: "SameSite=Strict" });
    case Network.SetCookieBlockedReason.SameSiteLax:
      return i18nString9(UIStrings9.blockedReasonSameSiteStrictLax, { PH1: "SameSite=Lax" });
    case Network.SetCookieBlockedReason.SameSiteUnspecifiedTreatedAsLax:
      return i18nString9(UIStrings9.blockedReasonSameSiteUnspecifiedTreatedAsLax);
    case Network.SetCookieBlockedReason.SameSiteNoneInsecure:
      return i18nString9(UIStrings9.blockedReasonSameSiteNoneInsecure);
    case Network.SetCookieBlockedReason.UserPreferences:
      return i18nString9(UIStrings9.thisSetcookieWasBlockedDueToUser);
    case Network.SetCookieBlockedReason.SyntaxError:
      return i18nString9(UIStrings9.thisSetcookieHadInvalidSyntax);
    case Network.SetCookieBlockedReason.SchemeNotSupported:
      return i18nString9(UIStrings9.theSchemeOfThisConnectionIsNot);
    case Network.SetCookieBlockedReason.OverwriteSecure:
      return i18nString9(UIStrings9.blockedReasonOverwriteSecure);
    case Network.SetCookieBlockedReason.InvalidDomain:
      return i18nString9(UIStrings9.blockedReasonInvalidDomain);
    case Network.SetCookieBlockedReason.InvalidPrefix:
      return i18nString9(UIStrings9.blockedReasonInvalidPrefix);
    case Network.SetCookieBlockedReason.UnknownError:
      return i18nString9(UIStrings9.anUnknownErrorWasEncounteredWhenTrying);
    case Network.SetCookieBlockedReason.SchemefulSameSiteStrict:
      return i18nString9(UIStrings9.thisSetcookieWasBlockedBecauseItHadTheSamesiteStrictLax, { PH1: "SameSite=Strict" });
    case Network.SetCookieBlockedReason.SchemefulSameSiteLax:
      return i18nString9(UIStrings9.thisSetcookieWasBlockedBecauseItHadTheSamesiteStrictLax, { PH1: "SameSite=Lax" });
    case Network.SetCookieBlockedReason.SchemefulSameSiteUnspecifiedTreatedAsLax:
      return i18nString9(UIStrings9.thisSetcookieDidntSpecifyASamesite);
    case Network.SetCookieBlockedReason.SamePartyFromCrossPartyContext:
      return i18nString9(UIStrings9.thisSetcookieWasBlockedBecauseItHadTheSameparty);
    case Network.SetCookieBlockedReason.SamePartyConflictsWithOtherAttributes:
      return i18nString9(UIStrings9.thisSetcookieWasBlockedBecauseItHadTheSamepartyAttribute);
    case Network.SetCookieBlockedReason.NameValuePairExceedsMaxSize:
      return i18nString9(UIStrings9.thisSetcookieWasBlockedBecauseTheNameValuePairExceedsMaxSize);
    case Network.SetCookieBlockedReason.DisallowedCharacter:
      return i18nString9(UIStrings9.thisSetcookieHadADisallowedCharacter);
    case Network.SetCookieBlockedReason.ThirdPartyPhaseout:
      return i18nString9(UIStrings9.thisSetcookieWasBlockedDueThirdPartyPhaseout);
  }
  return "";
};
var cookieBlockedReasonToAttribute = function(blockedReason) {
  switch (blockedReason) {
    case Network.CookieBlockedReason.SecureOnly:
      return Attribute.SECURE;
    case Network.CookieBlockedReason.NotOnPath:
      return Attribute.PATH;
    case Network.CookieBlockedReason.DomainMismatch:
      return Attribute.DOMAIN;
    case Network.CookieBlockedReason.SameSiteStrict:
    case Network.CookieBlockedReason.SameSiteLax:
    case Network.CookieBlockedReason.SameSiteUnspecifiedTreatedAsLax:
    case Network.CookieBlockedReason.SameSiteNoneInsecure:
    case Network.CookieBlockedReason.SchemefulSameSiteStrict:
    case Network.CookieBlockedReason.SchemefulSameSiteLax:
    case Network.CookieBlockedReason.SchemefulSameSiteUnspecifiedTreatedAsLax:
      return Attribute.SAME_SITE;
    case Network.CookieBlockedReason.SamePartyFromCrossPartyContext:
    case Network.CookieBlockedReason.NameValuePairExceedsMaxSize:
    case Network.CookieBlockedReason.UserPreferences:
    case Network.CookieBlockedReason.ThirdPartyPhaseout:
    case Network.CookieBlockedReason.UnknownError:
      return null;
  }
  return null;
};
var setCookieBlockedReasonToAttribute = function(blockedReason) {
  switch (blockedReason) {
    case Network.SetCookieBlockedReason.SecureOnly:
    case Network.SetCookieBlockedReason.OverwriteSecure:
      return Attribute.SECURE;
    case Network.SetCookieBlockedReason.SameSiteStrict:
    case Network.SetCookieBlockedReason.SameSiteLax:
    case Network.SetCookieBlockedReason.SameSiteUnspecifiedTreatedAsLax:
    case Network.SetCookieBlockedReason.SameSiteNoneInsecure:
    case Network.SetCookieBlockedReason.SchemefulSameSiteStrict:
    case Network.SetCookieBlockedReason.SchemefulSameSiteLax:
    case Network.SetCookieBlockedReason.SchemefulSameSiteUnspecifiedTreatedAsLax:
      return Attribute.SAME_SITE;
    case Network.SetCookieBlockedReason.InvalidDomain:
      return Attribute.DOMAIN;
    case Network.SetCookieBlockedReason.InvalidPrefix:
      return Attribute.NAME;
    case Network.SetCookieBlockedReason.SamePartyConflictsWithOtherAttributes:
    case Network.SetCookieBlockedReason.SamePartyFromCrossPartyContext:
    case Network.SetCookieBlockedReason.NameValuePairExceedsMaxSize:
    case Network.SetCookieBlockedReason.UserPreferences:
    case Network.SetCookieBlockedReason.ThirdPartyPhaseout:
    case Network.SetCookieBlockedReason.SyntaxError:
    case Network.SetCookieBlockedReason.SchemeNotSupported:
    case Network.SetCookieBlockedReason.UnknownError:
    case Network.SetCookieBlockedReason.DisallowedCharacter:
      return null;
  }
  return null;
};

// gen/front_end/core/sdk/AccessibilityModel.js
var AccessibilityModel_exports = {};
__export(AccessibilityModel_exports, {
  AccessibilityModel: () => AccessibilityModel,
  AccessibilityNode: () => AccessibilityNode,
  CoreAxPropertyName: () => CoreAxPropertyName,
  Events: () => Events17
});
var CoreAxPropertyName = /* @__PURE__ */ ((CoreAxPropertyName2) => {
  CoreAxPropertyName2["NAME"] = "name";
  CoreAxPropertyName2["DESCRIPTION"] = "description";
  CoreAxPropertyName2["VALUE"] = "value";
  CoreAxPropertyName2["ROLE"] = "role";
  return CoreAxPropertyName2;
})(CoreAxPropertyName || {});
var AccessibilityNode = class {
  #accessibilityModelInternal;
  #idInternal;
  #backendDOMNodeIdInternal;
  #deferredDOMNodeInternal;
  #ignoredInternal;
  #ignoredReasonsInternal;
  #roleInternal;
  #nameInternal;
  #descriptionInternal;
  #valueInternal;
  #propertiesInternal;
  #parentId;
  #frameId;
  #childIds;
  constructor(accessibilityModel, payload) {
    this.#accessibilityModelInternal = accessibilityModel;
    this.#idInternal = payload.nodeId;
    accessibilityModel.setAXNodeForAXId(this.#idInternal, this);
    if (payload.backendDOMNodeId) {
      accessibilityModel.setAXNodeForBackendDOMNodeId(payload.backendDOMNodeId, this);
      this.#backendDOMNodeIdInternal = payload.backendDOMNodeId;
      this.#deferredDOMNodeInternal = new DeferredDOMNode(accessibilityModel.target(), payload.backendDOMNodeId);
    } else {
      this.#backendDOMNodeIdInternal = null;
      this.#deferredDOMNodeInternal = null;
    }
    this.#ignoredInternal = payload.ignored;
    if (this.#ignoredInternal && "ignoredReasons" in payload) {
      this.#ignoredReasonsInternal = payload.ignoredReasons;
    }
    this.#roleInternal = payload.role || null;
    this.#nameInternal = payload.name || null;
    this.#descriptionInternal = payload.description || null;
    this.#valueInternal = payload.value || null;
    this.#propertiesInternal = payload.properties || null;
    this.#childIds = [...new Set(payload.childIds)];
    this.#parentId = payload.parentId || null;
    if (payload.frameId && !payload.parentId) {
      this.#frameId = payload.frameId;
      accessibilityModel.setRootAXNodeForFrameId(payload.frameId, this);
    } else {
      this.#frameId = null;
    }
  }
  id() {
    return this.#idInternal;
  }
  accessibilityModel() {
    return this.#accessibilityModelInternal;
  }
  ignored() {
    return this.#ignoredInternal;
  }
  ignoredReasons() {
    return this.#ignoredReasonsInternal || null;
  }
  role() {
    return this.#roleInternal || null;
  }
  coreProperties() {
    const properties = [];
    if (this.#nameInternal) {
      properties.push({ name: "name", value: this.#nameInternal });
    }
    if (this.#descriptionInternal) {
      properties.push({ name: "description", value: this.#descriptionInternal });
    }
    if (this.#valueInternal) {
      properties.push({ name: "value", value: this.#valueInternal });
    }
    return properties;
  }
  name() {
    return this.#nameInternal || null;
  }
  description() {
    return this.#descriptionInternal || null;
  }
  value() {
    return this.#valueInternal || null;
  }
  properties() {
    return this.#propertiesInternal || null;
  }
  parentNode() {
    if (this.#parentId) {
      return this.#accessibilityModelInternal.axNodeForId(this.#parentId);
    }
    return null;
  }
  isDOMNode() {
    return Boolean(this.#backendDOMNodeIdInternal);
  }
  backendDOMNodeId() {
    return this.#backendDOMNodeIdInternal;
  }
  deferredDOMNode() {
    return this.#deferredDOMNodeInternal;
  }
  highlightDOMNode() {
    const deferredNode = this.deferredDOMNode();
    if (!deferredNode) {
      return;
    }
    deferredNode.highlight();
  }
  children() {
    if (!this.#childIds) {
      return [];
    }
    const children = [];
    for (const childId of this.#childIds) {
      const child = this.#accessibilityModelInternal.axNodeForId(childId);
      if (child) {
        children.push(child);
      }
    }
    return children;
  }
  numChildren() {
    if (!this.#childIds) {
      return 0;
    }
    return this.#childIds.length;
  }
  hasOnlyUnloadedChildren() {
    if (!this.#childIds || !this.#childIds.length) {
      return false;
    }
    return this.#childIds.every((id) => this.#accessibilityModelInternal.axNodeForId(id) === null);
  }
  hasUnloadedChildren() {
    if (!this.#childIds || !this.#childIds.length) {
      return false;
    }
    return this.#childIds.some((id) => this.#accessibilityModelInternal.axNodeForId(id) === null);
  }
  // Only the root node gets a frameId, so nodes have to walk up the tree to find their frameId.
  getFrameId() {
    return this.#frameId || this.parentNode()?.getFrameId() || null;
  }
};
var Events17 = /* @__PURE__ */ ((Events210) => {
  Events210["TREE_UPDATED"] = "TreeUpdated";
  return Events210;
})(Events17 || {});
var AccessibilityModel = class extends SDKModel {
  agent;
  #axIdToAXNode;
  #backendDOMNodeIdToAXNode;
  #frameIdToAXNode;
  #pendingChildRequests;
  #root;
  constructor(target) {
    super(target);
    target.registerAccessibilityDispatcher(this);
    this.agent = target.accessibilityAgent();
    void this.resumeModel();
    this.#axIdToAXNode = /* @__PURE__ */ new Map();
    this.#backendDOMNodeIdToAXNode = /* @__PURE__ */ new Map();
    this.#frameIdToAXNode = /* @__PURE__ */ new Map();
    this.#pendingChildRequests = /* @__PURE__ */ new Map();
    this.#root = null;
  }
  clear() {
    this.#root = null;
    this.#axIdToAXNode.clear();
    this.#backendDOMNodeIdToAXNode.clear();
    this.#frameIdToAXNode.clear();
  }
  async resumeModel() {
    await this.agent.invoke_enable();
  }
  async suspendModel() {
    await this.agent.invoke_disable();
  }
  async requestPartialAXTree(node) {
    const { nodes } = await this.agent.invoke_getPartialAXTree({ nodeId: node.id, fetchRelatives: true });
    if (!nodes) {
      return;
    }
    const axNodes = [];
    for (const payload of nodes) {
      axNodes.push(new AccessibilityNode(this, payload));
    }
  }
  loadComplete({ root }) {
    this.clear();
    this.#root = new AccessibilityNode(this, root);
    this.dispatchEventToListeners("TreeUpdated", { root: this.#root });
  }
  nodesUpdated({ nodes }) {
    this.createNodesFromPayload(nodes);
    this.dispatchEventToListeners("TreeUpdated", {});
    return;
  }
  createNodesFromPayload(payloadNodes) {
    const accessibilityNodes = payloadNodes.map((node) => {
      const sdkNode = new AccessibilityNode(this, node);
      return sdkNode;
    });
    return accessibilityNodes;
  }
  async requestRootNode(frameId) {
    if (frameId && this.#frameIdToAXNode.has(frameId)) {
      return this.#frameIdToAXNode.get(frameId);
    }
    if (!frameId && this.#root) {
      return this.#root;
    }
    const { node } = await this.agent.invoke_getRootAXNode({ frameId });
    if (!node) {
      return;
    }
    return this.createNodesFromPayload([node])[0];
  }
  async requestAXChildren(nodeId, frameId) {
    const parent = this.#axIdToAXNode.get(nodeId);
    if (!parent) {
      throw Error("Cannot request children before parent");
    }
    if (!parent.hasUnloadedChildren()) {
      return parent.children();
    }
    const request = this.#pendingChildRequests.get(nodeId);
    if (request) {
      await request;
    } else {
      const request2 = this.agent.invoke_getChildAXNodes({ id: nodeId, frameId });
      this.#pendingChildRequests.set(nodeId, request2);
      const result = await request2;
      if (!result.getError()) {
        this.createNodesFromPayload(result.nodes);
        this.#pendingChildRequests.delete(nodeId);
      }
    }
    return parent.children();
  }
  async requestAndLoadSubTreeToNode(node) {
    const result = [];
    let ancestor = this.axNodeForDOMNode(node);
    while (ancestor) {
      result.push(ancestor);
      const parent = ancestor.parentNode();
      if (!parent) {
        return result;
      }
      ancestor = parent;
    }
    const { nodes } = await this.agent.invoke_getAXNodeAndAncestors({ backendNodeId: node.backendNodeId() });
    if (!nodes) {
      return null;
    }
    const ancestors = this.createNodesFromPayload(nodes);
    return ancestors;
  }
  axNodeForId(axId) {
    return this.#axIdToAXNode.get(axId) || null;
  }
  setRootAXNodeForFrameId(frameId, axNode) {
    this.#frameIdToAXNode.set(frameId, axNode);
  }
  axNodeForFrameId(frameId) {
    return this.#frameIdToAXNode.get(frameId) ?? null;
  }
  setAXNodeForAXId(axId, axNode) {
    this.#axIdToAXNode.set(axId, axNode);
  }
  axNodeForDOMNode(domNode) {
    if (!domNode) {
      return null;
    }
    return this.#backendDOMNodeIdToAXNode.get(domNode.backendNodeId()) ?? null;
  }
  setAXNodeForBackendDOMNodeId(backendDOMNodeId, axNode) {
    this.#backendDOMNodeIdToAXNode.set(backendDOMNodeId, axNode);
  }
  getAgent() {
    return this.agent;
  }
};
SDKModel.register(AccessibilityModel, { capabilities: Capability.DOM, autostart: false });

// gen/front_end/core/sdk/AnimationModel.js
var AnimationModel_exports = {};
__export(AnimationModel_exports, {
  AnimationDOMNode: () => AnimationDOMNode,
  AnimationDispatcher: () => AnimationDispatcher,
  AnimationEffect: () => AnimationEffect,
  AnimationGroup: () => AnimationGroup,
  AnimationImpl: () => AnimationImpl,
  AnimationModel: () => AnimationModel,
  Events: () => Events18,
  KeyframeStyle: () => KeyframeStyle,
  KeyframesRule: () => KeyframesRule,
  ScreenshotCapture: () => ScreenshotCapture
});
import * as Common26 from "./../common/common.js";

// gen/front_end/core/sdk/ScreenCaptureModel.js
var ScreenCaptureModel_exports = {};
__export(ScreenCaptureModel_exports, {
  ScreenCaptureModel: () => ScreenCaptureModel,
  ScreenshotMode: () => ScreenshotMode
});
var ScreenshotMode = /* @__PURE__ */ ((ScreenshotMode2) => {
  ScreenshotMode2["FROM_VIEWPORT"] = "fromViewport";
  ScreenshotMode2["FROM_CLIP"] = "fromClip";
  ScreenshotMode2["FULLPAGE"] = "fullpage";
  return ScreenshotMode2;
})(ScreenshotMode || {});
var ScreenCaptureModel = class extends SDKModel {
  #agent;
  #onScreencastFrame;
  #onScreencastVisibilityChanged;
  constructor(target) {
    super(target);
    this.#agent = target.pageAgent();
    this.#onScreencastFrame = null;
    this.#onScreencastVisibilityChanged = null;
    target.registerPageDispatcher(this);
  }
  startScreencast(format, quality, maxWidth, maxHeight, everyNthFrame, onFrame, onVisibilityChanged) {
    this.#onScreencastFrame = onFrame;
    this.#onScreencastVisibilityChanged = onVisibilityChanged;
    void this.#agent.invoke_startScreencast({ format, quality, maxWidth, maxHeight, everyNthFrame });
  }
  stopScreencast() {
    this.#onScreencastFrame = null;
    this.#onScreencastVisibilityChanged = null;
    void this.#agent.invoke_stopScreencast();
  }
  async captureScreenshot(format, quality, mode, clip) {
    const properties = {
      format,
      quality,
      fromSurface: true
    };
    switch (mode) {
      case "fromClip":
        properties.captureBeyondViewport = true;
        properties.clip = clip;
        break;
      case "fullpage":
        properties.captureBeyondViewport = true;
        break;
      case "fromViewport":
        properties.captureBeyondViewport = false;
        break;
      default:
        throw new Error("Unexpected or unspecified screnshotMode");
    }
    await OverlayModel.muteHighlight();
    const result = await this.#agent.invoke_captureScreenshot(properties);
    await OverlayModel.unmuteHighlight();
    return result.data;
  }
  async fetchLayoutMetrics() {
    const response = await this.#agent.invoke_getLayoutMetrics();
    if (response.getError()) {
      return null;
    }
    return {
      viewportX: response.cssVisualViewport.pageX,
      viewportY: response.cssVisualViewport.pageY,
      viewportScale: response.cssVisualViewport.scale,
      contentWidth: response.cssContentSize.width,
      contentHeight: response.cssContentSize.height
    };
  }
  screencastFrame({ data, metadata, sessionId }) {
    void this.#agent.invoke_screencastFrameAck({ sessionId });
    if (this.#onScreencastFrame) {
      this.#onScreencastFrame.call(null, data, metadata);
    }
  }
  screencastVisibilityChanged({ visible }) {
    if (this.#onScreencastVisibilityChanged) {
      this.#onScreencastVisibilityChanged.call(null, visible);
    }
  }
  backForwardCacheNotUsed(_params) {
  }
  domContentEventFired(_params) {
  }
  loadEventFired(_params) {
  }
  lifecycleEvent(_params) {
  }
  navigatedWithinDocument(_params) {
  }
  frameAttached(_params) {
  }
  frameNavigated(_params) {
  }
  documentOpened(_params) {
  }
  frameDetached(_params) {
  }
  frameStartedLoading(_params) {
  }
  frameStoppedLoading(_params) {
  }
  frameRequestedNavigation(_params) {
  }
  frameSubtreeWillBeDetached(_params) {
  }
  frameScheduledNavigation(_params) {
  }
  frameClearedScheduledNavigation(_params) {
  }
  frameResized() {
  }
  javascriptDialogOpening(_params) {
  }
  javascriptDialogClosed(_params) {
  }
  interstitialShown() {
  }
  interstitialHidden() {
  }
  windowOpen(_params) {
  }
  fileChooserOpened(_params) {
  }
  compilationCacheProduced(_params) {
  }
  downloadWillBegin(_params) {
  }
  downloadProgress() {
  }
  prefetchStatusUpdated(_params) {
  }
  prerenderStatusUpdated(_params) {
  }
};
SDKModel.register(ScreenCaptureModel, { capabilities: Capability.SCREEN_CAPTURE, autostart: false });

// gen/front_end/core/sdk/AnimationModel.js
var DEVTOOLS_ANIMATIONS_WORLD_NAME = "devtools_animations";
var REPORT_SCROLL_POSITION_BINDING_NAME = "__devtools_report_scroll_position__";
var getScrollListenerNameInPage = (id) => `__devtools_scroll_listener_${id}__`;
async function resolveToObjectInWorld(domNode, worldName) {
  const resourceTreeModel = domNode.domModel().target().model(ResourceTreeModel);
  const pageAgent = domNode.domModel().target().pageAgent();
  for (const frame of resourceTreeModel.frames()) {
    const { executionContextId } = await pageAgent.invoke_createIsolatedWorld({ frameId: frame.id, worldName });
    const object = await domNode.resolveToObject(void 0, executionContextId);
    if (object) {
      return object;
    }
  }
  return null;
}
var AnimationDOMNode = class _AnimationDOMNode {
  #domNode;
  #scrollListenersById;
  #scrollBindingListener;
  static lastAddedListenerId = 0;
  constructor(domNode) {
    this.#domNode = domNode;
    this.#scrollListenersById = /* @__PURE__ */ new Map();
  }
  async #addReportScrollPositionBinding() {
    if (this.#scrollBindingListener) {
      return;
    }
    this.#scrollBindingListener = (ev) => {
      const { name, payload } = ev.data;
      if (name !== REPORT_SCROLL_POSITION_BINDING_NAME) {
        return;
      }
      const { scrollTop, scrollLeft, id } = JSON.parse(payload);
      const scrollListener = this.#scrollListenersById.get(id);
      if (!scrollListener) {
        return;
      }
      scrollListener({ scrollTop, scrollLeft });
    };
    const runtimeModel = this.#domNode.domModel().target().model(RuntimeModel);
    await runtimeModel.addBinding({
      name: REPORT_SCROLL_POSITION_BINDING_NAME,
      executionContextName: DEVTOOLS_ANIMATIONS_WORLD_NAME
    });
    runtimeModel.addEventListener(Events10.BindingCalled, this.#scrollBindingListener);
  }
  async #removeReportScrollPositionBinding() {
    if (!this.#scrollBindingListener) {
      return;
    }
    const runtimeModel = this.#domNode.domModel().target().model(RuntimeModel);
    await runtimeModel.removeBinding({
      name: REPORT_SCROLL_POSITION_BINDING_NAME
    });
    runtimeModel.removeEventListener(Events10.BindingCalled, this.#scrollBindingListener);
    this.#scrollBindingListener = void 0;
  }
  async addScrollEventListener(onScroll) {
    _AnimationDOMNode.lastAddedListenerId++;
    const id = _AnimationDOMNode.lastAddedListenerId;
    this.#scrollListenersById.set(id, onScroll);
    if (!this.#scrollBindingListener) {
      await this.#addReportScrollPositionBinding();
    }
    const object = await resolveToObjectInWorld(this.#domNode, DEVTOOLS_ANIMATIONS_WORLD_NAME);
    if (!object) {
      return null;
    }
    await object.callFunction(scrollListenerInPage, [
      id,
      REPORT_SCROLL_POSITION_BINDING_NAME,
      getScrollListenerNameInPage(id)
    ].map((arg) => RemoteObject.toCallArgument(arg)));
    object.release();
    return id;
    function scrollListenerInPage(id2, reportScrollPositionBindingName, scrollListenerNameInPage) {
      if ("scrollingElement" in this && !this.scrollingElement) {
        return;
      }
      const scrollingElement = "scrollingElement" in this ? this.scrollingElement : this;
      this[scrollListenerNameInPage] = () => {
        globalThis[reportScrollPositionBindingName](
          JSON.stringify({ scrollTop: scrollingElement.scrollTop, scrollLeft: scrollingElement.scrollLeft, id: id2 })
        );
      };
      this.addEventListener("scroll", this[scrollListenerNameInPage], true);
    }
  }
  async removeScrollEventListener(id) {
    const object = await resolveToObjectInWorld(this.#domNode, DEVTOOLS_ANIMATIONS_WORLD_NAME);
    if (!object) {
      return;
    }
    await object.callFunction(
      removeScrollListenerInPage,
      [getScrollListenerNameInPage(id)].map((arg) => RemoteObject.toCallArgument(arg))
    );
    object.release();
    this.#scrollListenersById.delete(id);
    if (this.#scrollListenersById.size === 0) {
      await this.#removeReportScrollPositionBinding();
    }
    function removeScrollListenerInPage(scrollListenerNameInPage) {
      this.removeEventListener("scroll", this[scrollListenerNameInPage]);
      delete this[scrollListenerNameInPage];
    }
  }
  async scrollTop() {
    return this.#domNode.callFunction(scrollTopInPage).then((res) => res?.value ?? null);
    function scrollTopInPage() {
      if ("scrollingElement" in this) {
        if (!this.scrollingElement) {
          return 0;
        }
        return this.scrollingElement.scrollTop;
      }
      return this.scrollTop;
    }
  }
  async scrollLeft() {
    return this.#domNode.callFunction(scrollLeftInPage).then((res) => res?.value ?? null);
    function scrollLeftInPage() {
      if ("scrollingElement" in this) {
        if (!this.scrollingElement) {
          return 0;
        }
        return this.scrollingElement.scrollLeft;
      }
      return this.scrollLeft;
    }
  }
  async setScrollTop(offset) {
    await this.#domNode.callFunction(setScrollTopInPage, [offset]);
    function setScrollTopInPage(offsetInPage) {
      if ("scrollingElement" in this) {
        if (!this.scrollingElement) {
          return;
        }
        this.scrollingElement.scrollTop = offsetInPage;
      } else {
        this.scrollTop = offsetInPage;
      }
    }
  }
  async setScrollLeft(offset) {
    await this.#domNode.callFunction(setScrollLeftInPage, [offset]);
    function setScrollLeftInPage(offsetInPage) {
      if ("scrollingElement" in this) {
        if (!this.scrollingElement) {
          return;
        }
        this.scrollingElement.scrollLeft = offsetInPage;
      } else {
        this.scrollLeft = offsetInPage;
      }
    }
  }
  async verticalScrollRange() {
    return this.#domNode.callFunction(verticalScrollRangeInPage).then((res) => res?.value ?? null);
    function verticalScrollRangeInPage() {
      if ("scrollingElement" in this) {
        if (!this.scrollingElement) {
          return 0;
        }
        return this.scrollingElement.scrollHeight - this.scrollingElement.clientHeight;
      }
      return this.scrollHeight - this.clientHeight;
    }
  }
  async horizontalScrollRange() {
    return this.#domNode.callFunction(horizontalScrollRangeInPage).then((res) => res?.value ?? null);
    function horizontalScrollRangeInPage() {
      if ("scrollingElement" in this) {
        if (!this.scrollingElement) {
          return 0;
        }
        return this.scrollingElement.scrollWidth - this.scrollingElement.clientWidth;
      }
      return this.scrollWidth - this.clientWidth;
    }
  }
};
function shouldGroupAnimations(firstAnimation, anim) {
  const firstAnimationTimeline = firstAnimation.viewOrScrollTimeline();
  const animationTimeline = anim.viewOrScrollTimeline();
  if (firstAnimationTimeline) {
    return Boolean(
      animationTimeline && firstAnimationTimeline.sourceNodeId === animationTimeline.sourceNodeId && firstAnimationTimeline.axis === animationTimeline.axis
    );
  }
  return !animationTimeline && firstAnimation.startTime() === anim.startTime();
}
var AnimationModel = class extends SDKModel {
  runtimeModel;
  agent;
  #animationsById;
  animationGroups;
  #pendingAnimations;
  playbackRate;
  #screenshotCapture;
  #flushPendingAnimations;
  constructor(target) {
    super(target);
    this.runtimeModel = target.model(RuntimeModel);
    this.agent = target.animationAgent();
    target.registerAnimationDispatcher(new AnimationDispatcher(this));
    this.#animationsById = /* @__PURE__ */ new Map();
    this.animationGroups = /* @__PURE__ */ new Map();
    this.#pendingAnimations = /* @__PURE__ */ new Set();
    this.playbackRate = 1;
    if (!target.suspended()) {
      void this.agent.invoke_enable();
    }
    const resourceTreeModel = target.model(ResourceTreeModel);
    resourceTreeModel.addEventListener(Events4.PrimaryPageChanged, this.reset, this);
    const screenCaptureModel = target.model(ScreenCaptureModel);
    if (screenCaptureModel) {
      this.#screenshotCapture = new ScreenshotCapture(this, screenCaptureModel);
    }
    this.#flushPendingAnimations = Common26.Debouncer.debounce(() => {
      while (this.#pendingAnimations.size) {
        this.matchExistingGroups(this.createGroupFromPendingAnimations());
      }
    }, 100);
  }
  reset() {
    this.#animationsById.clear();
    this.animationGroups.clear();
    this.#pendingAnimations.clear();
    this.dispatchEventToListeners(
      "ModelReset"
      /* ModelReset */
    );
  }
  async devicePixelRatio() {
    const evaluateResult = await this.target().runtimeAgent().invoke_evaluate({ expression: "window.devicePixelRatio" });
    if (evaluateResult?.result.type === "number") {
      return evaluateResult?.result.value ?? 1;
    }
    return 1;
  }
  async getAnimationGroupForAnimation(name, nodeId) {
    for (const animationGroup of this.animationGroups.values()) {
      for (const animation of animationGroup.animations()) {
        if (animation.name() === name) {
          const animationNode = await animation.source().node();
          if (animationNode?.id === nodeId) {
            return animationGroup;
          }
        }
      }
    }
    return null;
  }
  animationCanceled(id) {
    this.#pendingAnimations.delete(id);
  }
  async animationUpdated(payload) {
    let foundAnimationGroup;
    let foundAnimation;
    for (const animationGroup of this.animationGroups.values()) {
      foundAnimation = animationGroup.animations().find((animation) => animation.id() === payload.id);
      if (foundAnimation) {
        foundAnimationGroup = animationGroup;
        break;
      }
    }
    if (!foundAnimation || !foundAnimationGroup) {
      return;
    }
    await foundAnimation.setPayload(payload);
    this.dispatchEventToListeners("AnimationGroupUpdated", foundAnimationGroup);
  }
  async animationStarted(payload) {
    if (!payload.source || !payload.source.backendNodeId) {
      return;
    }
    const animation = await AnimationImpl.parsePayload(this, payload);
    const keyframesRule = animation.source().keyframesRule();
    if (animation.type() === "WebAnimation" && keyframesRule && keyframesRule.keyframes().length === 0) {
      this.#pendingAnimations.delete(animation.id());
    } else {
      this.#animationsById.set(animation.id(), animation);
      this.#pendingAnimations.add(animation.id());
    }
    this.#flushPendingAnimations();
  }
  matchExistingGroups(incomingGroup) {
    let matchedGroup = null;
    for (const group of this.animationGroups.values()) {
      if (group.matches(incomingGroup)) {
        matchedGroup = group;
        group.rebaseTo(incomingGroup);
        break;
      }
      if (group.shouldInclude(incomingGroup)) {
        matchedGroup = group;
        group.appendAnimations(incomingGroup.animations());
        break;
      }
    }
    if (!matchedGroup) {
      this.animationGroups.set(incomingGroup.id(), incomingGroup);
      if (this.#screenshotCapture) {
        this.#screenshotCapture.captureScreenshots(incomingGroup.finiteDuration(), incomingGroup.screenshotsInternal);
      }
      this.dispatchEventToListeners("AnimationGroupStarted", incomingGroup);
    } else {
      this.dispatchEventToListeners("AnimationGroupUpdated", matchedGroup);
    }
    return Boolean(matchedGroup);
  }
  createGroupFromPendingAnimations() {
    console.assert(this.#pendingAnimations.size > 0);
    const firstAnimationId = this.#pendingAnimations.values().next().value;
    this.#pendingAnimations.delete(firstAnimationId);
    const firstAnimation = this.#animationsById.get(firstAnimationId);
    if (!firstAnimation) {
      throw new Error("Unable to locate first animation");
    }
    const groupedAnimations = [firstAnimation];
    const remainingAnimations = /* @__PURE__ */ new Set();
    for (const id of this.#pendingAnimations) {
      const anim = this.#animationsById.get(id);
      if (shouldGroupAnimations(firstAnimation, anim)) {
        groupedAnimations.push(anim);
      } else {
        remainingAnimations.add(id);
      }
    }
    this.#pendingAnimations = remainingAnimations;
    groupedAnimations.sort((anim1, anim2) => anim1.startTime() - anim2.startTime());
    return new AnimationGroup(this, firstAnimationId, groupedAnimations);
  }
  setPlaybackRate(playbackRate) {
    this.playbackRate = playbackRate;
    void this.agent.invoke_setPlaybackRate({ playbackRate });
  }
  releaseAnimations(animations) {
    void this.agent.invoke_releaseAnimations({ animations });
  }
  async suspendModel() {
    await this.agent.invoke_disable().then(() => this.reset());
  }
  async resumeModel() {
    await this.agent.invoke_enable();
  }
};
var Events18 = /* @__PURE__ */ ((Events210) => {
  Events210["AnimationGroupStarted"] = "AnimationGroupStarted";
  Events210["AnimationGroupUpdated"] = "AnimationGroupUpdated";
  Events210["ModelReset"] = "ModelReset";
  return Events210;
})(Events18 || {});
var AnimationImpl = class _AnimationImpl {
  #animationModel;
  #payloadInternal;
  // Assertion is safe because only way to create `AnimationImpl` is to use `parsePayload` which calls `setPayload` and sets the value.
  #sourceInternal;
  // Assertion is safe because only way to create `AnimationImpl` is to use `parsePayload` which calls `setPayload` and sets the value.
  #playStateInternal;
  constructor(animationModel) {
    this.#animationModel = animationModel;
  }
  static async parsePayload(animationModel, payload) {
    const animation = new _AnimationImpl(animationModel);
    await animation.setPayload(payload);
    return animation;
  }
  async setPayload(payload) {
    if (payload.viewOrScrollTimeline) {
      const devicePixelRatio = await this.#animationModel.devicePixelRatio();
      if (payload.viewOrScrollTimeline.startOffset) {
        payload.viewOrScrollTimeline.startOffset /= devicePixelRatio;
      }
      if (payload.viewOrScrollTimeline.endOffset) {
        payload.viewOrScrollTimeline.endOffset /= devicePixelRatio;
      }
    }
    this.#payloadInternal = payload;
    if (this.#sourceInternal && payload.source) {
      this.#sourceInternal.setPayload(payload.source);
    } else if (!this.#sourceInternal && payload.source) {
      this.#sourceInternal = new AnimationEffect(this.#animationModel, payload.source);
    }
  }
  // `startTime` and `duration` is represented as the
  // percentage of the view timeline range that starts at `startOffset`px
  // from the scroll container and ends at `endOffset`px of the scroll container.
  // This takes a percentage of the timeline range and returns the absolute
  // pixels values as a scroll offset of the scroll container.
  percentageToPixels(percentage, viewOrScrollTimeline) {
    const { startOffset, endOffset } = viewOrScrollTimeline;
    if (startOffset === void 0 || endOffset === void 0) {
      throw new Error("startOffset or endOffset does not exist in viewOrScrollTimeline");
    }
    return (endOffset - startOffset) * (percentage / 100);
  }
  viewOrScrollTimeline() {
    return this.#payloadInternal.viewOrScrollTimeline;
  }
  id() {
    return this.#payloadInternal.id;
  }
  name() {
    return this.#payloadInternal.name;
  }
  paused() {
    return this.#payloadInternal.pausedState;
  }
  playState() {
    return this.#playStateInternal || this.#payloadInternal.playState;
  }
  setPlayState(playState) {
    this.#playStateInternal = playState;
  }
  playbackRate() {
    return this.#payloadInternal.playbackRate;
  }
  // For scroll driven animations, it returns the pixel offset in the scroll container
  // For time animations, it returns milliseconds.
  startTime() {
    const viewOrScrollTimeline = this.viewOrScrollTimeline();
    if (viewOrScrollTimeline) {
      return this.percentageToPixels(
        this.playbackRate() > 0 ? this.#payloadInternal.startTime : 100 - this.#payloadInternal.startTime,
        viewOrScrollTimeline
      ) + (this.viewOrScrollTimeline()?.startOffset ?? 0);
    }
    return this.#payloadInternal.startTime;
  }
  // For scroll driven animations, it returns the duration in pixels (i.e. after how many pixels of scroll the animation is going to end)
  // For time animations, it returns milliseconds.
  iterationDuration() {
    const viewOrScrollTimeline = this.viewOrScrollTimeline();
    if (viewOrScrollTimeline) {
      return this.percentageToPixels(this.source().duration(), viewOrScrollTimeline);
    }
    return this.source().duration();
  }
  // For scroll driven animations, it returns the duration in pixels (i.e. after how many pixels of scroll the animation is going to end)
  // For time animations, it returns milliseconds.
  endTime() {
    if (!this.source().iterations) {
      return Infinity;
    }
    if (this.viewOrScrollTimeline()) {
      return this.startTime() + this.iterationDuration() * this.source().iterations();
    }
    return this.startTime() + this.source().delay() + this.source().duration() * this.source().iterations() + this.source().endDelay();
  }
  // For scroll driven animations, it returns the duration in pixels (i.e. after how many pixels of scroll the animation is going to end)
  // For time animations, it returns milliseconds.
  finiteDuration() {
    const iterations = Math.min(this.source().iterations(), 3);
    if (this.viewOrScrollTimeline()) {
      return this.iterationDuration() * iterations;
    }
    return this.source().delay() + this.source().duration() * iterations;
  }
  // For scroll driven animations, it returns the duration in pixels (i.e. after how many pixels of scroll the animation is going to end)
  // For time animations, it returns milliseconds.
  currentTime() {
    const viewOrScrollTimeline = this.viewOrScrollTimeline();
    if (viewOrScrollTimeline) {
      return this.percentageToPixels(this.#payloadInternal.currentTime, viewOrScrollTimeline);
    }
    return this.#payloadInternal.currentTime;
  }
  source() {
    return this.#sourceInternal;
  }
  type() {
    return this.#payloadInternal.type;
  }
  overlaps(animation) {
    if (!this.source().iterations() || !animation.source().iterations()) {
      return true;
    }
    const firstAnimation = this.startTime() < animation.startTime() ? this : animation;
    const secondAnimation = firstAnimation === this ? animation : this;
    return firstAnimation.endTime() >= secondAnimation.startTime();
  }
  // Utility method for returning `delay` for time based animations
  // and `startTime` in pixels for scroll driven animations. It is used to
  // find the exact starting time of the first keyframe for both cases.
  delayOrStartTime() {
    if (this.viewOrScrollTimeline()) {
      return this.startTime();
    }
    return this.source().delay();
  }
  setTiming(duration, delay) {
    void this.#sourceInternal.node().then((node) => {
      if (!node) {
        throw new Error("Unable to find node");
      }
      this.updateNodeStyle(duration, delay, node);
    });
    this.#sourceInternal.durationInternal = duration;
    this.#sourceInternal.delayInternal = delay;
    void this.#animationModel.agent.invoke_setTiming({ animationId: this.id(), duration, delay });
  }
  updateNodeStyle(duration, delay, node) {
    let animationPrefix;
    if (this.type() === Animation.AnimationType.CSSTransition) {
      animationPrefix = "transition-";
    } else if (this.type() === Animation.AnimationType.CSSAnimation) {
      animationPrefix = "animation-";
    } else {
      return;
    }
    if (!node.id) {
      throw new Error("Node has no id");
    }
    const cssModel = node.domModel().cssModel();
    cssModel.setEffectivePropertyValueForNode(node.id, animationPrefix + "duration", duration + "ms");
    cssModel.setEffectivePropertyValueForNode(node.id, animationPrefix + "delay", delay + "ms");
  }
  async remoteObjectPromise() {
    const payload = await this.#animationModel.agent.invoke_resolveAnimation({ animationId: this.id() });
    if (!payload) {
      return null;
    }
    return this.#animationModel.runtimeModel.createRemoteObject(payload.remoteObject);
  }
  cssId() {
    return this.#payloadInternal.cssId || "";
  }
};
var AnimationEffect = class {
  #animationModel;
  #payload;
  // Assertion is safe because `setPayload` call in `constructor` sets the value.
  delayInternal;
  // Assertion is safe because `setPayload` call in `constructor` sets the value.
  durationInternal;
  // Assertion is safe because `setPayload` call in `constructor` sets the value.
  #keyframesRuleInternal;
  #deferredNodeInternal;
  constructor(animationModel, payload) {
    this.#animationModel = animationModel;
    this.setPayload(payload);
  }
  setPayload(payload) {
    this.#payload = payload;
    if (!this.#keyframesRuleInternal && payload.keyframesRule) {
      this.#keyframesRuleInternal = new KeyframesRule(payload.keyframesRule);
    } else if (this.#keyframesRuleInternal && payload.keyframesRule) {
      this.#keyframesRuleInternal.setPayload(payload.keyframesRule);
    }
    this.delayInternal = payload.delay;
    this.durationInternal = payload.duration;
  }
  delay() {
    return this.delayInternal;
  }
  endDelay() {
    return this.#payload.endDelay;
  }
  iterations() {
    if (!this.delay() && !this.endDelay() && !this.duration()) {
      return 0;
    }
    return this.#payload.iterations || Infinity;
  }
  duration() {
    return this.durationInternal;
  }
  direction() {
    return this.#payload.direction;
  }
  fill() {
    return this.#payload.fill;
  }
  node() {
    if (!this.#deferredNodeInternal) {
      this.#deferredNodeInternal = new DeferredDOMNode(this.#animationModel.target(), this.backendNodeId());
    }
    return this.#deferredNodeInternal.resolvePromise();
  }
  deferredNode() {
    return new DeferredDOMNode(this.#animationModel.target(), this.backendNodeId());
  }
  backendNodeId() {
    return this.#payload.backendNodeId;
  }
  keyframesRule() {
    return this.#keyframesRuleInternal || null;
  }
  easing() {
    return this.#payload.easing;
  }
};
var KeyframesRule = class {
  #payload;
  // Assertion is safe because `setPayload` call in `constructor` sets the value.;
  #keyframesInternal;
  // Assertion is safe because `setPayload` call in `constructor` sets the value.;
  constructor(payload) {
    this.setPayload(payload);
  }
  setPayload(payload) {
    this.#payload = payload;
    if (!this.#keyframesInternal) {
      this.#keyframesInternal = this.#payload.keyframes.map((keyframeStyle) => new KeyframeStyle(keyframeStyle));
    } else {
      this.#payload.keyframes.forEach((keyframeStyle, index) => {
        this.#keyframesInternal[index]?.setPayload(keyframeStyle);
      });
    }
  }
  name() {
    return this.#payload.name;
  }
  keyframes() {
    return this.#keyframesInternal;
  }
};
var KeyframeStyle = class {
  #payload;
  // Assertion is safe because `setPayload` call in `constructor` sets the value.
  #offsetInternal;
  // Assertion is safe because `setPayload` call in `constructor` sets the value.
  constructor(payload) {
    this.setPayload(payload);
  }
  setPayload(payload) {
    this.#payload = payload;
    this.#offsetInternal = payload.offset;
  }
  offset() {
    return this.#offsetInternal;
  }
  setOffset(offset) {
    this.#offsetInternal = offset * 100 + "%";
  }
  offsetAsNumber() {
    return parseFloat(this.#offsetInternal) / 100;
  }
  easing() {
    return this.#payload.easing;
  }
};
var AnimationGroup = class {
  #animationModel;
  #idInternal;
  #scrollNodeInternal;
  #animationsInternal;
  #pausedInternal;
  screenshotsInternal;
  #screenshotImages;
  constructor(animationModel, id, animations) {
    this.#animationModel = animationModel;
    this.#idInternal = id;
    this.#animationsInternal = animations;
    this.#pausedInternal = false;
    this.screenshotsInternal = [];
    this.#screenshotImages = [];
  }
  isScrollDriven() {
    return Boolean(this.#animationsInternal[0]?.viewOrScrollTimeline());
  }
  id() {
    return this.#idInternal;
  }
  animations() {
    return this.#animationsInternal;
  }
  release() {
    this.#animationModel.animationGroups.delete(this.id());
    this.#animationModel.releaseAnimations(this.animationIds());
  }
  animationIds() {
    function extractId(animation) {
      return animation.id();
    }
    return this.#animationsInternal.map(extractId);
  }
  startTime() {
    return this.#animationsInternal[0].startTime();
  }
  // For scroll driven animations, it returns the duration in pixels (i.e. after how many pixels of scroll the animation is going to end)
  // For time animations, it returns milliseconds.
  groupDuration() {
    let duration = 0;
    for (const anim of this.#animationsInternal) {
      duration = Math.max(duration, anim.delayOrStartTime() + anim.iterationDuration());
    }
    return duration;
  }
  // For scroll driven animations, it returns the duration in pixels (i.e. after how many pixels of scroll the animation is going to end)
  // For time animations, it returns milliseconds.
  finiteDuration() {
    let maxDuration = 0;
    for (let i = 0; i < this.#animationsInternal.length; ++i) {
      maxDuration = Math.max(maxDuration, this.#animationsInternal[i].finiteDuration());
    }
    return maxDuration;
  }
  scrollOrientation() {
    const timeline = this.#animationsInternal[0]?.viewOrScrollTimeline();
    if (!timeline) {
      return null;
    }
    return timeline.axis;
  }
  async scrollNode() {
    if (this.#scrollNodeInternal) {
      return this.#scrollNodeInternal;
    }
    if (!this.isScrollDriven()) {
      return null;
    }
    const sourceNodeId = this.#animationsInternal[0]?.viewOrScrollTimeline()?.sourceNodeId;
    if (!sourceNodeId) {
      return null;
    }
    const deferredScrollNode = new DeferredDOMNode(this.#animationModel.target(), sourceNodeId);
    const scrollNode = await deferredScrollNode.resolvePromise();
    if (!scrollNode) {
      return null;
    }
    this.#scrollNodeInternal = new AnimationDOMNode(scrollNode);
    return this.#scrollNodeInternal;
  }
  seekTo(currentTime) {
    void this.#animationModel.agent.invoke_seekAnimations({ animations: this.animationIds(), currentTime });
  }
  paused() {
    return this.#pausedInternal;
  }
  togglePause(paused) {
    if (paused === this.#pausedInternal) {
      return;
    }
    this.#pausedInternal = paused;
    void this.#animationModel.agent.invoke_setPaused({ animations: this.animationIds(), paused });
  }
  currentTimePromise() {
    let longestAnim = null;
    for (const anim of this.#animationsInternal) {
      if (!longestAnim || anim.endTime() > longestAnim.endTime()) {
        longestAnim = anim;
      }
    }
    if (!longestAnim) {
      throw new Error("No longest animation found");
    }
    return this.#animationModel.agent.invoke_getCurrentTime({ id: longestAnim.id() }).then(({ currentTime }) => currentTime || 0);
  }
  matches(group) {
    function extractId(anim) {
      const timelineId = (anim.viewOrScrollTimeline()?.sourceNodeId ?? "") + (anim.viewOrScrollTimeline()?.axis ?? "");
      const regularId = anim.type() === Animation.AnimationType.WebAnimation ? anim.type() + anim.id() : anim.cssId();
      return regularId + timelineId;
    }
    if (this.#animationsInternal.length !== group.#animationsInternal.length) {
      return false;
    }
    const left = this.#animationsInternal.map(extractId).sort();
    const right = group.#animationsInternal.map(extractId).sort();
    for (let i = 0; i < left.length; i++) {
      if (left[i] !== right[i]) {
        return false;
      }
    }
    return true;
  }
  shouldInclude(group) {
    const [firstIncomingAnimation] = group.#animationsInternal;
    const [firstAnimation] = this.#animationsInternal;
    return shouldGroupAnimations(firstAnimation, firstIncomingAnimation);
  }
  appendAnimations(animations) {
    this.#animationsInternal.push(...animations);
  }
  rebaseTo(group) {
    this.#animationModel.releaseAnimations(this.animationIds());
    this.#animationsInternal = group.#animationsInternal;
    this.#scrollNodeInternal = void 0;
  }
  screenshots() {
    for (let i = 0; i < this.screenshotsInternal.length; ++i) {
      const image = new Image();
      image.src = "data:image/jpeg;base64," + this.screenshotsInternal[i];
      this.#screenshotImages.push(image);
    }
    this.screenshotsInternal = [];
    return this.#screenshotImages;
  }
};
var AnimationDispatcher = class {
  #animationModel;
  constructor(animationModel) {
    this.#animationModel = animationModel;
  }
  animationCreated(_event) {
  }
  animationCanceled({ id }) {
    this.#animationModel.animationCanceled(id);
  }
  animationStarted({ animation }) {
    void this.#animationModel.animationStarted(animation);
  }
  animationUpdated({ animation }) {
    void this.#animationModel.animationUpdated(animation);
  }
};
var ScreenshotCapture = class {
  #requests;
  #screenCaptureModel;
  #animationModel;
  #stopTimer;
  #endTime;
  #capturing;
  constructor(animationModel, screenCaptureModel) {
    this.#requests = [];
    this.#screenCaptureModel = screenCaptureModel;
    this.#animationModel = animationModel;
    this.#animationModel.addEventListener("ModelReset", this.stopScreencast, this);
  }
  captureScreenshots(duration, screenshots) {
    const screencastDuration = Math.min(duration / this.#animationModel.playbackRate, 3e3);
    const endTime = screencastDuration + window.performance.now();
    this.#requests.push({ endTime, screenshots });
    if (!this.#endTime || endTime > this.#endTime) {
      clearTimeout(this.#stopTimer);
      this.#stopTimer = window.setTimeout(this.stopScreencast.bind(this), screencastDuration);
      this.#endTime = endTime;
    }
    if (this.#capturing) {
      return;
    }
    this.#capturing = true;
    this.#screenCaptureModel.startScreencast(
      Page.StartScreencastRequestFormat.Jpeg,
      80,
      void 0,
      300,
      2,
      this.screencastFrame.bind(this),
      (_visible) => {
      }
    );
  }
  screencastFrame(base64Data, _metadata) {
    function isAnimating(request) {
      return request.endTime >= now;
    }
    if (!this.#capturing) {
      return;
    }
    const now = window.performance.now();
    this.#requests = this.#requests.filter(isAnimating);
    for (const request of this.#requests) {
      request.screenshots.push(base64Data);
    }
  }
  stopScreencast() {
    if (!this.#capturing) {
      return;
    }
    this.#stopTimer = void 0;
    this.#endTime = void 0;
    this.#requests = [];
    this.#capturing = false;
    this.#screenCaptureModel.stopScreencast();
  }
};
SDKModel.register(AnimationModel, { capabilities: Capability.DOM, autostart: true });

// gen/front_end/core/sdk/AutofillModel.js
var AutofillModel_exports = {};
__export(AutofillModel_exports, {
  AutofillModel: () => AutofillModel,
  Events: () => Events19
});
import * as Common27 from "./../common/common.js";
import * as Root8 from "./../root/root.js";
import * as Host8 from "./../host/host.js";
var AutofillModel = class extends SDKModel {
  agent;
  #enabled;
  #showTestAddressesInAutofillMenu;
  constructor(target) {
    super(target);
    this.agent = target.autofillAgent();
    this.#showTestAddressesInAutofillMenu = Common27.Settings.Settings.instance().createSetting("show-test-addresses-in-autofill-menu-on-event", false);
    target.registerAutofillDispatcher(this);
    this.enable();
  }
  setTestAddresses() {
    void this.agent.invoke_setAddresses(
      {
        addresses: this.#showTestAddressesInAutofillMenu.get() ? [
          {
            fields: [
              { name: "ADDRESS_HOME_COUNTRY", value: "US" },
              { name: "NAME_FULL", value: "Jon Stewart Doe" },
              { name: "NAME_FIRST", value: "Jon" },
              { name: "NAME_MIDDLE", value: "Stewart" },
              { name: "NAME_LAST", value: "Doe" },
              { name: "COMPANY_NAME", value: "Fake Company" },
              { name: "ADDRESS_HOME_LINE1", value: "1600 Fake Street" },
              { name: "ADDRESS_HOME_LINE2", value: "Apartment 1" },
              { name: "ADDRESS_HOME_ZIP", value: "94043" },
              { name: "ADDRESS_HOME_CITY", value: "Mountain View" },
              { name: "ADDRESS_HOME_STATE", value: "CA" },
              { name: "EMAIL_ADDRESS", value: "test@example.us" },
              { name: "PHONE_HOME_WHOLE_NUMBER", value: "+16019521325" }
            ]
          },
          {
            fields: [
              { name: "ADDRESS_HOME_COUNTRY", value: "BR" },
              { name: "NAME_FULL", value: "Jo\xE3o Souza Silva" },
              { name: "NAME_FIRST", value: "Jo\xE3o" },
              { name: "NAME_LAST", value: "Souza Silva" },
              { name: "NAME_LAST_FIRST", value: "Souza" },
              { name: "NAME_LAST_SECOND", value: "Silva" },
              { name: "COMPANY_NAME", value: "Empresa Falsa" },
              { name: "ADDRESS_HOME_STREET_ADDRESS", value: "Rua Inexistente, 2000\nAndar 2, Apartamento 1" },
              { name: "ADDRESS_HOME_STREET_LOCATION", value: "Rua Inexistente, 2000" },
              { name: "ADDRESS_HOME_STREET_NAME", value: "Rua Inexistente" },
              { name: "ADDRESS_HOME_HOUSE_NUMBER", value: "2000" },
              { name: "ADDRESS_HOME_SUBPREMISE", value: "Andar 2, Apartamento 1" },
              { name: "ADDRESS_HOME_APT_NUM", value: "1" },
              { name: "ADDRESS_HOME_FLOOR", value: "2" },
              { name: "ADDRESS_HOME_APT", value: "Apartamento 1" },
              { name: "ADDRESS_HOME_APT_TYPE", value: "Apartamento" },
              { name: "ADDRESS_HOME_APT_NUM", value: "1" },
              { name: "ADDRESS_HOME_DEPENDENT_LOCALITY", value: "Santa Efig\xEAnia" },
              { name: "ADDRESS_HOME_LANDMARK", value: "Pr\xF3ximo \xE0 esta\xE7\xE3o Santa Efig\xEAnia" },
              { name: "ADDRESS_HOME_OVERFLOW", value: "Andar 2, Apartamento 1" },
              { name: "ADDRESS_HOME_ZIP", value: "30260-080" },
              { name: "ADDRESS_HOME_CITY", value: "Belo Horizonte" },
              { name: "ADDRESS_HOME_STATE", value: "MG" },
              { name: "EMAIL_ADDRESS", value: "teste@exemplo.us" },
              { name: "PHONE_HOME_WHOLE_NUMBER", value: "+553121286800" }
            ]
          },
          {
            fields: [
              { name: "ADDRESS_HOME_COUNTRY", value: "MX" },
              { name: "NAME_FULL", value: "Juan Francisco Garc\xEDa Flores" },
              { name: "NAME_FIRST", value: "Juan Francisco" },
              { name: "NAME_LAST", value: "Garc\xEDa Flores" },
              { name: "NAME_LAST_FIRST", value: "Garc\xEDa" },
              { name: "NAME_LAST_SECOND", value: "Flores" },
              { name: "COMPANY_NAME", value: "Empresa Falsa" },
              {
                name: "ADDRESS_HOME_STREET_ADDRESS",
                value: "C. Falsa 445\nPiso 2, Apartamento 1\nEntre calle Volc\xE1n y calle Montes Blancos, cerca de la estaci\xF3n de metro"
              },
              { name: "ADDRESS_HOME_STREET_LOCATION", value: "C. Falsa 445" },
              { name: "ADDRESS_HOME_STREET_NAME", value: "C. Falsa" },
              { name: "ADDRESS_HOME_HOUSE_NUMBER", value: "445" },
              { name: "ADDRESS_HOME_SUBPREMISE", value: "Piso 2, Apartamento 1" },
              { name: "ADDRESS_HOME_FLOOR", value: "2" },
              { name: "ADDRESS_HOME_APT", value: "Apartamento 1" },
              { name: "ADDRESS_HOME_APT_TYPE", value: "Apartamento" },
              { name: "ADDRESS_HOME_APT_NUM", value: "1" },
              { name: "ADDRESS_HOME_DEPENDENT_LOCALITY", value: "Lomas de Chapultepec" },
              {
                name: "ADDRESS_HOME_OVERFLOW",
                value: "Entre calle Volc\xE1n y calle Montes Celestes, cerca de la estaci\xF3n de metro"
              },
              {
                name: "ADDRESS_HOME_BETWEEN_STREETS_OR_LANDMARK",
                value: "Entre calle Volc\xE1n y calle Montes Blancos, cerca de la estaci\xF3n de metro"
              },
              { name: "ADDRESS_HOME_LANDMARK", value: "Cerca de la estaci\xF3n de metro" },
              { name: "ADDRESS_HOME_BETWEEN_STREETS", value: "Entre calle Volc\xE1n y calle Montes Blancos" },
              { name: "ADDRESS_HOME_BETWEEN_STREETS_1", value: "calle Volc\xE1n" },
              { name: "ADDRESS_HOME_BETWEEN_STREETS_2", value: "calle Montes Blancos" },
              { name: "ADDRESS_HOME_ADMIN_LEVEL2", value: "Miguel Hidalgo" },
              { name: "ADDRESS_HOME_ZIP", value: "11001" },
              { name: "ADDRESS_HOME_CITY", value: "Ciudad de M\xE9xico" },
              { name: "ADDRESS_HOME_STATE", value: "Distrito Federal" },
              { name: "EMAIL_ADDRESS", value: "ejemplo@ejemplo.mx" },
              { name: "PHONE_HOME_WHOLE_NUMBER", value: "+525553428400" }
            ]
          },
          {
            fields: [
              { name: "ADDRESS_HOME_COUNTRY", value: "DE" },
              { name: "NAME_FULL", value: "Gottfried Wilhelm Leibniz" },
              { name: "NAME_FIRST", value: "Gottfried" },
              { name: "NAME_MIDDLE", value: "Wilhelm" },
              { name: "NAME_LAST", value: "Leibniz" },
              { name: "COMPANY_NAME", value: "Erfundenes Unternehmen" },
              { name: "ADDRESS_HOME_LINE1", value: "Erfundene Stra\xDFe 33" },
              { name: "ADDRESS_HOME_LINE2", value: "Wohnung 1" },
              { name: "ADDRESS_HOME_ZIP", value: "80732" },
              { name: "ADDRESS_HOME_CITY", value: "M\xFCnchen" },
              { name: "EMAIL_ADDRESS", value: "test@beispiel.de" },
              { name: "PHONE_HOME_WHOLE_NUMBER", value: "+4930303986300" }
            ]
          }
        ] : []
      }
    );
  }
  enable() {
    if (!Root8.Runtime.experiments.isEnabled(Root8.Runtime.ExperimentName.AUTOFILL_VIEW) || this.#enabled || Host8.InspectorFrontendHost.isUnderTest()) {
      return;
    }
    void this.agent.invoke_enable();
    this.setTestAddresses();
    this.#enabled = true;
  }
  disable() {
    if (!this.#enabled || Host8.InspectorFrontendHost.isUnderTest()) {
      return;
    }
    this.#enabled = false;
    void this.agent.invoke_disable();
  }
  addressFormFilled(addressFormFilledEvent) {
    this.dispatchEventToListeners("AddressFormFilled", { autofillModel: this, event: addressFormFilledEvent });
  }
};
SDKModel.register(AutofillModel, { capabilities: Capability.DOM, autostart: true });
var Events19 = /* @__PURE__ */ ((Events210) => {
  Events210["ADDRESS_FORM_FILLED"] = "AddressFormFilled";
  return Events210;
})(Events19 || {});

// gen/front_end/core/sdk/CategorizedBreakpoint.js
var CategorizedBreakpoint_exports = {};
__export(CategorizedBreakpoint_exports, {
  CategorizedBreakpoint: () => CategorizedBreakpoint,
  Category: () => Category
});
var Category = /* @__PURE__ */ ((Category2) => {
  Category2["ANIMATION"] = "animation";
  Category2["AUCTION_WORKLET"] = "auction-worklet";
  Category2["CANVAS"] = "canvas";
  Category2["CLIPBOARD"] = "clipboard";
  Category2["CONTROL"] = "control";
  Category2["DEVICE"] = "device";
  Category2["DOM_MUTATION"] = "dom-mutation";
  Category2["DRAG_DROP"] = "drag-drop";
  Category2["GEOLOCATION"] = "geolocation";
  Category2["KEYBOARD"] = "keyboard";
  Category2["LOAD"] = "load";
  Category2["MEDIA"] = "media";
  Category2["MOUSE"] = "mouse";
  Category2["NOTIFICATION"] = "notification";
  Category2["PARSE"] = "parse";
  Category2["PICTURE_IN_PICTURE"] = "picture-in-picture";
  Category2["POINTER"] = "pointer";
  Category2["SCRIPT"] = "script";
  Category2["SHARED_STORAGE_WORKLET"] = "shared-storage-worklet";
  Category2["TIMER"] = "timer";
  Category2["TOUCH"] = "touch";
  Category2["TRUSTED_TYPE_VIOLATION"] = "trusted-type-violation";
  Category2["WEB_AUDIO"] = "web-audio";
  Category2["WINDOW"] = "window";
  Category2["WORKER"] = "worker";
  Category2["XHR"] = "xhr";
  return Category2;
})(Category || {});
var CategorizedBreakpoint = class {
  /**
   * The name of this breakpoint as passed to 'setInstrumentationBreakpoint',
   * 'setEventListenerBreakpoint' and 'setBreakOnCSPViolation'.
   *
   * Note that the backend adds a 'listener:' and 'instrumentation:' prefix
   * to this name in the 'Debugger.paused' CDP event.
   */
  name;
  #category;
  enabledInternal;
  constructor(category, name) {
    this.#category = category;
    this.name = name;
    this.enabledInternal = false;
  }
  category() {
    return this.#category;
  }
  enabled() {
    return this.enabledInternal;
  }
  setEnabled(enabled) {
    this.enabledInternal = enabled;
  }
};

// gen/front_end/core/sdk/ChildTargetManager.js
var ChildTargetManager_exports = {};
__export(ChildTargetManager_exports, {
  ChildTargetManager: () => ChildTargetManager,
  Events: () => Events20
});
import * as i18n23 from "./../i18n/i18n.js";
import * as Common29 from "./../common/common.js";
import * as Host10 from "./../host/host.js";

// gen/front_end/core/sdk/Connections.js
var Connections_exports = {};
__export(Connections_exports, {
  MainConnection: () => MainConnection,
  ParallelConnection: () => ParallelConnection,
  StubConnection: () => StubConnection,
  WebSocketConnection: () => WebSocketConnection,
  initMainConnection: () => initMainConnection
});
import * as Common28 from "./../common/common.js";
import * as Host9 from "./../host/host.js";
import * as ProtocolClient2 from "./../protocol_client/protocol_client.js";
import * as Root9 from "./../root/root.js";
var MainConnection = class {
  onMessage;
  #onDisconnect;
  #messageBuffer;
  #messageSize;
  #eventListeners;
  constructor() {
    this.onMessage = null;
    this.#onDisconnect = null;
    this.#messageBuffer = "";
    this.#messageSize = 0;
    this.#eventListeners = [
      Host9.InspectorFrontendHost.InspectorFrontendHostInstance.events.addEventListener(
        Host9.InspectorFrontendHostAPI.Events.DispatchMessage,
        this.dispatchMessage,
        this
      ),
      Host9.InspectorFrontendHost.InspectorFrontendHostInstance.events.addEventListener(
        Host9.InspectorFrontendHostAPI.Events.DispatchMessageChunk,
        this.dispatchMessageChunk,
        this
      )
    ];
  }
  setOnMessage(onMessage) {
    this.onMessage = onMessage;
  }
  setOnDisconnect(onDisconnect) {
    this.#onDisconnect = onDisconnect;
  }
  sendRawMessage(message) {
    if (this.onMessage) {
      Host9.InspectorFrontendHost.InspectorFrontendHostInstance.sendMessageToBackend(message);
    }
  }
  dispatchMessage(event) {
    if (this.onMessage) {
      this.onMessage.call(null, event.data);
    }
  }
  dispatchMessageChunk(event) {
    const { messageChunk, messageSize } = event.data;
    if (messageSize) {
      this.#messageBuffer = "";
      this.#messageSize = messageSize;
    }
    this.#messageBuffer += messageChunk;
    if (this.#messageBuffer.length === this.#messageSize && this.onMessage) {
      this.onMessage.call(null, this.#messageBuffer);
      this.#messageBuffer = "";
      this.#messageSize = 0;
    }
  }
  async disconnect() {
    const onDisconnect = this.#onDisconnect;
    Common28.EventTarget.removeEventListeners(this.#eventListeners);
    this.#onDisconnect = null;
    this.onMessage = null;
    if (onDisconnect) {
      onDisconnect.call(null, "force disconnect");
    }
  }
};
var WebSocketConnection = class {
  #socket;
  onMessage;
  #onDisconnect;
  #onWebSocketDisconnect;
  #connected;
  #messages;
  constructor(url, onWebSocketDisconnect) {
    this.#socket = new WebSocket(url);
    this.#socket.onerror = this.onError.bind(this);
    this.#socket.onopen = this.onOpen.bind(this);
    this.#socket.onmessage = (messageEvent) => {
      if (this.onMessage) {
        this.onMessage.call(null, messageEvent.data);
      }
    };
    this.#socket.onclose = this.onClose.bind(this);
    this.onMessage = null;
    this.#onDisconnect = null;
    this.#onWebSocketDisconnect = onWebSocketDisconnect;
    this.#connected = false;
    this.#messages = [];
  }
  setOnMessage(onMessage) {
    this.onMessage = onMessage;
  }
  setOnDisconnect(onDisconnect) {
    this.#onDisconnect = onDisconnect;
  }
  onError() {
    if (this.#onWebSocketDisconnect) {
      this.#onWebSocketDisconnect.call(null);
    }
    if (this.#onDisconnect) {
      this.#onDisconnect.call(null, "connection failed");
    }
    this.close();
  }
  onOpen() {
    this.#connected = true;
    if (this.#socket) {
      this.#socket.onerror = console.error;
      for (const message of this.#messages) {
        this.#socket.send(message);
      }
    }
    this.#messages = [];
  }
  onClose() {
    if (this.#onWebSocketDisconnect) {
      this.#onWebSocketDisconnect.call(null);
    }
    if (this.#onDisconnect) {
      this.#onDisconnect.call(null, "websocket closed");
    }
    this.close();
  }
  close(callback) {
    if (this.#socket) {
      this.#socket.onerror = null;
      this.#socket.onopen = null;
      this.#socket.onclose = callback || null;
      this.#socket.onmessage = null;
      this.#socket.close();
      this.#socket = null;
    }
    this.#onWebSocketDisconnect = null;
  }
  sendRawMessage(message) {
    if (this.#connected && this.#socket) {
      this.#socket.send(message);
    } else {
      this.#messages.push(message);
    }
  }
  disconnect() {
    return new Promise((fulfill) => {
      this.close(() => {
        if (this.#onDisconnect) {
          this.#onDisconnect.call(null, "force disconnect");
        }
        fulfill();
      });
    });
  }
};
var StubConnection = class {
  onMessage;
  #onDisconnect;
  constructor() {
    this.onMessage = null;
    this.#onDisconnect = null;
  }
  setOnMessage(onMessage) {
    this.onMessage = onMessage;
  }
  setOnDisconnect(onDisconnect) {
    this.#onDisconnect = onDisconnect;
  }
  sendRawMessage(message) {
    window.setTimeout(this.respondWithError.bind(this, message), 0);
  }
  respondWithError(message) {
    const messageObject = JSON.parse(message);
    const error = {
      message: "This is a stub connection, can't dispatch message.",
      code: ProtocolClient2.InspectorBackend.DevToolsStubErrorCode,
      data: messageObject
    };
    if (this.onMessage) {
      this.onMessage.call(null, { id: messageObject.id, error });
    }
  }
  async disconnect() {
    if (this.#onDisconnect) {
      this.#onDisconnect.call(null, "force disconnect");
    }
    this.#onDisconnect = null;
    this.onMessage = null;
  }
};
var ParallelConnection = class {
  #connection;
  #sessionId;
  onMessage;
  #onDisconnect;
  constructor(connection, sessionId) {
    this.#connection = connection;
    this.#sessionId = sessionId;
    this.onMessage = null;
    this.#onDisconnect = null;
  }
  setOnMessage(onMessage) {
    this.onMessage = onMessage;
  }
  setOnDisconnect(onDisconnect) {
    this.#onDisconnect = onDisconnect;
  }
  getOnDisconnect() {
    return this.#onDisconnect;
  }
  sendRawMessage(message) {
    const messageObject = JSON.parse(message);
    if (!messageObject.sessionId) {
      messageObject.sessionId = this.#sessionId;
    }
    this.#connection.sendRawMessage(JSON.stringify(messageObject));
  }
  getSessionId() {
    return this.#sessionId;
  }
  async disconnect() {
    if (this.#onDisconnect) {
      this.#onDisconnect.call(null, "force disconnect");
    }
    this.#onDisconnect = null;
    this.onMessage = null;
  }
};
async function initMainConnection(createRootTarget, websocketConnectionLost) {
  ProtocolClient2.InspectorBackend.Connection.setFactory(createMainConnection.bind(null, websocketConnectionLost));
  await createRootTarget();
  Host9.InspectorFrontendHost.InspectorFrontendHostInstance.connectionReady();
}
function createMainConnection(websocketConnectionLost) {
  const wsParam = Root9.Runtime.Runtime.queryParam("ws");
  const wssParam = Root9.Runtime.Runtime.queryParam("wss");
  if (wsParam || wssParam) {
    const ws = wsParam ? `ws://${wsParam}` : `wss://${wssParam}`;
    return new WebSocketConnection(ws, websocketConnectionLost);
  }
  if (Host9.InspectorFrontendHost.InspectorFrontendHostInstance.isHostedMode()) {
    return new StubConnection();
  }
  return new MainConnection();
}

// gen/front_end/core/sdk/ChildTargetManager.js
var UIStrings10 = {
  /**
   * @description Text that refers to the main target. The main target is the primary webpage that
   * DevTools is connected to. This text is used in various places in the UI as a label/name to inform
   * the user which target/webpage they are currently connected to, as DevTools may connect to multiple
   * targets at the same time in some scenarios.
   */
  main: "Main"
};
var str_10 = i18n23.i18n.registerUIStrings("core/sdk/ChildTargetManager.ts", UIStrings10);
var i18nString10 = i18n23.i18n.getLocalizedString.bind(void 0, str_10);
var ChildTargetManager = class _ChildTargetManager extends SDKModel {
  #targetManager;
  #parentTarget;
  #targetAgent;
  #targetInfosInternal = /* @__PURE__ */ new Map();
  #childTargetsBySessionId = /* @__PURE__ */ new Map();
  #childTargetsById = /* @__PURE__ */ new Map();
  #parallelConnections = /* @__PURE__ */ new Map();
  #parentTargetId = null;
  constructor(parentTarget) {
    super(parentTarget);
    this.#targetManager = parentTarget.targetManager();
    this.#parentTarget = parentTarget;
    this.#targetAgent = parentTarget.targetAgent();
    parentTarget.registerTargetDispatcher(this);
    const browserTarget = this.#targetManager.browserTarget();
    if (browserTarget) {
      if (browserTarget !== parentTarget) {
        void browserTarget.targetAgent().invoke_autoAttachRelated(
          { targetId: parentTarget.id(), waitForDebuggerOnStart: true }
        );
      }
    } else {
      void this.#targetAgent.invoke_setAutoAttach({ autoAttach: true, waitForDebuggerOnStart: true, flatten: true });
    }
    if (parentTarget.parentTarget()?.type() !== Type2.FRAME && !Host10.InspectorFrontendHost.isUnderTest()) {
      void this.#targetAgent.invoke_setDiscoverTargets({ discover: true });
      void this.#targetAgent.invoke_setRemoteLocations({ locations: [{ host: "localhost", port: 9229 }] });
    }
  }
  static install(attachCallback) {
    _ChildTargetManager.attachCallback = attachCallback;
    SDKModel.register(_ChildTargetManager, { capabilities: Capability.TARGET, autostart: true });
  }
  childTargets() {
    return Array.from(this.#childTargetsBySessionId.values());
  }
  async suspendModel() {
    await this.#targetAgent.invoke_setAutoAttach({ autoAttach: true, waitForDebuggerOnStart: false, flatten: true });
  }
  async resumeModel() {
    await this.#targetAgent.invoke_setAutoAttach({ autoAttach: true, waitForDebuggerOnStart: true, flatten: true });
  }
  dispose() {
    for (const sessionId of this.#childTargetsBySessionId.keys()) {
      this.detachedFromTarget({ sessionId, targetId: void 0 });
    }
  }
  targetCreated({ targetInfo }) {
    this.#targetInfosInternal.set(targetInfo.targetId, targetInfo);
    this.fireAvailableTargetsChanged();
    this.dispatchEventToListeners("TargetCreated", targetInfo);
  }
  targetInfoChanged({ targetInfo }) {
    this.#targetInfosInternal.set(targetInfo.targetId, targetInfo);
    const target = this.#childTargetsById.get(targetInfo.targetId);
    if (target) {
      if (target.targetInfo()?.subtype === "prerender" && !targetInfo.subtype) {
        const resourceTreeModel = target.model(ResourceTreeModel);
        target.updateTargetInfo(targetInfo);
        if (resourceTreeModel && resourceTreeModel.mainFrame) {
          resourceTreeModel.primaryPageChanged(resourceTreeModel.mainFrame, PrimaryPageChangeType.ACTIVATION);
        }
        target.setName(i18nString10(UIStrings10.main));
      } else {
        target.updateTargetInfo(targetInfo);
      }
    }
    this.fireAvailableTargetsChanged();
    this.dispatchEventToListeners("TargetInfoChanged", targetInfo);
  }
  targetDestroyed({ targetId }) {
    this.#targetInfosInternal.delete(targetId);
    this.fireAvailableTargetsChanged();
    this.dispatchEventToListeners("TargetDestroyed", targetId);
  }
  targetCrashed({ targetId }) {
    this.#targetInfosInternal.delete(targetId);
    const target = this.#childTargetsById.get(targetId);
    if (target) {
      target.dispose("targetCrashed event from CDP");
    }
    this.fireAvailableTargetsChanged();
    this.dispatchEventToListeners("TargetDestroyed", targetId);
  }
  fireAvailableTargetsChanged() {
    TargetManager.instance().dispatchEventToListeners(
      Events.AVAILABLE_TARGETS_CHANGED,
      [...this.#targetInfosInternal.values()]
    );
  }
  async getParentTargetId() {
    if (!this.#parentTargetId) {
      this.#parentTargetId = (await this.#parentTarget.targetAgent().invoke_getTargetInfo({})).targetInfo.targetId;
    }
    return this.#parentTargetId;
  }
  async getTargetInfo() {
    return (await this.#parentTarget.targetAgent().invoke_getTargetInfo({})).targetInfo;
  }
  async attachedToTarget({ sessionId, targetInfo, waitingForDebugger }) {
    if (this.#parentTargetId === targetInfo.targetId) {
      return;
    }
    let type = Type2.BROWSER;
    let targetName = "";
    if (targetInfo.type === "worker" && targetInfo.title && targetInfo.title !== targetInfo.url) {
      targetName = targetInfo.title;
    } else if (!["page", "iframe", "webview"].includes(targetInfo.type)) {
      const KNOWN_FRAME_PATTERNS = [
        "^chrome://print/$",
        "^chrome://file-manager/",
        "^chrome://feedback/",
        "^chrome://.*\\.top-chrome/$",
        "^chrome://view-cert/$",
        "^devtools://"
      ];
      if (KNOWN_FRAME_PATTERNS.some((p) => targetInfo.url.match(p))) {
        type = Type2.FRAME;
      } else {
        const parsedURL = Common29.ParsedURL.ParsedURL.fromString(targetInfo.url);
        targetName = parsedURL ? parsedURL.lastPathComponentWithFragment() : "#" + ++_ChildTargetManager.lastAnonymousTargetId;
      }
    }
    if (targetInfo.type === "iframe" || targetInfo.type === "webview") {
      type = Type2.FRAME;
    } else if (targetInfo.type === "background_page" || targetInfo.type === "app" || targetInfo.type === "popup_page") {
      type = Type2.FRAME;
    } else if (targetInfo.type === "page") {
      type = Type2.FRAME;
    } else if (targetInfo.type === "worker") {
      type = Type2.Worker;
    } else if (targetInfo.type === "worklet") {
      type = Type2.WORKLET;
    } else if (targetInfo.type === "shared_worker") {
      type = Type2.SHARED_WORKER;
    } else if (targetInfo.type === "shared_storage_worklet") {
      type = Type2.SHARED_STORAGE_WORKLET;
    } else if (targetInfo.type === "service_worker") {
      type = Type2.ServiceWorker;
    } else if (targetInfo.type === "auction_worklet") {
      type = Type2.AUCTION_WORKLET;
    }
    const target = this.#targetManager.createTarget(
      targetInfo.targetId,
      targetName,
      type,
      this.#parentTarget,
      sessionId,
      void 0,
      void 0,
      targetInfo
    );
    this.#childTargetsBySessionId.set(sessionId, target);
    this.#childTargetsById.set(target.id(), target);
    if (_ChildTargetManager.attachCallback) {
      await _ChildTargetManager.attachCallback({ target, waitingForDebugger });
    }
    if (waitingForDebugger) {
      void target.runtimeAgent().invoke_runIfWaitingForDebugger();
    }
  }
  detachedFromTarget({ sessionId }) {
    if (this.#parallelConnections.has(sessionId)) {
      this.#parallelConnections.delete(sessionId);
    } else {
      const target = this.#childTargetsBySessionId.get(sessionId);
      if (target) {
        target.dispose("target terminated");
        this.#childTargetsBySessionId.delete(sessionId);
        this.#childTargetsById.delete(target.id());
      }
    }
  }
  receivedMessageFromTarget({}) {
  }
  async createParallelConnection(onMessage) {
    const targetId = await this.getParentTargetId();
    const { connection, sessionId } = await this.createParallelConnectionAndSessionForTarget(this.#parentTarget, targetId);
    connection.setOnMessage(onMessage);
    this.#parallelConnections.set(sessionId, connection);
    return { connection, sessionId };
  }
  async createParallelConnectionAndSessionForTarget(target, targetId) {
    const targetAgent = target.targetAgent();
    const targetRouter = target.router();
    const sessionId = (await targetAgent.invoke_attachToTarget({ targetId, flatten: true })).sessionId;
    const connection = new ParallelConnection(targetRouter.connection(), sessionId);
    targetRouter.registerSession(target, sessionId, connection);
    connection.setOnDisconnect(() => {
      targetRouter.unregisterSession(sessionId);
      void targetAgent.invoke_detachFromTarget({ sessionId });
    });
    return { connection, sessionId };
  }
  targetInfos() {
    return Array.from(this.#targetInfosInternal.values());
  }
  static lastAnonymousTargetId = 0;
  static attachCallback;
};
var Events20 = /* @__PURE__ */ ((Events210) => {
  Events210["TARGET_CREATED"] = "TargetCreated";
  Events210["TARGET_DESTROYED"] = "TargetDestroyed";
  Events210["TARGET_INFO_CHANGED"] = "TargetInfoChanged";
  return Events210;
})(Events20 || {});

// gen/front_end/core/sdk/CompilerSourceMappingContentProvider.js
var CompilerSourceMappingContentProvider_exports = {};
__export(CompilerSourceMappingContentProvider_exports, {
  CompilerSourceMappingContentProvider: () => CompilerSourceMappingContentProvider
});
import * as TextUtils23 from "./../../models/text_utils/text_utils.js";
import * as i18n25 from "./../i18n/i18n.js";
var UIStrings11 = {
  /**
   *@description Error message when failing to fetch a resource referenced in a source map
   *@example {https://example.com/sourcemap.map} PH1
   *@example {An error occurred} PH2
   */
  couldNotLoadContentForSS: "Could not load content for {PH1} ({PH2})"
};
var str_11 = i18n25.i18n.registerUIStrings("core/sdk/CompilerSourceMappingContentProvider.ts", UIStrings11);
var i18nString11 = i18n25.i18n.getLocalizedString.bind(void 0, str_11);
var CompilerSourceMappingContentProvider = class {
  #sourceURL;
  #contentTypeInternal;
  #initiator;
  constructor(sourceURL, contentType, initiator) {
    this.#sourceURL = sourceURL;
    this.#contentTypeInternal = contentType;
    this.#initiator = initiator;
  }
  contentURL() {
    return this.#sourceURL;
  }
  contentType() {
    return this.#contentTypeInternal;
  }
  async requestContent() {
    const contentData = await this.requestContentData();
    return TextUtils23.ContentData.ContentData.asDeferredContent(contentData);
  }
  async requestContentData() {
    try {
      const { content } = await PageResourceLoader.instance().loadResource(this.#sourceURL, this.#initiator);
      return new TextUtils23.ContentData.ContentData(
        content,
        /* isBase64=*/
        false,
        this.#contentTypeInternal.canonicalMimeType()
      );
    } catch (e) {
      const error = i18nString11(UIStrings11.couldNotLoadContentForSS, { PH1: this.#sourceURL, PH2: e.message });
      console.error(error);
      return { error };
    }
  }
  async searchInContent(query, caseSensitive, isRegex) {
    const contentData = await this.requestContentData();
    return TextUtils23.TextUtils.performSearchInContentData(contentData, query, caseSensitive, isRegex);
  }
};

// gen/front_end/core/sdk/ConsoleModel.js
var ConsoleModel_exports = {};
__export(ConsoleModel_exports, {
  ConsoleMessage: () => ConsoleMessage,
  ConsoleModel: () => ConsoleModel,
  Events: () => Events23,
  FrontendMessageType: () => FrontendMessageType,
  MessageSourceDisplayName: () => MessageSourceDisplayName
});
import * as Common30 from "./../common/common.js";
import * as Host12 from "./../host/host.js";
import * as i18n29 from "./../i18n/i18n.js";
import * as Platform20 from "./../platform/platform.js";

// gen/front_end/core/sdk/ConsoleModelTypes.js
var FrontendMessageType = /* @__PURE__ */ ((FrontendMessageType2) => {
  FrontendMessageType2["Result"] = "result";
  FrontendMessageType2["Command"] = "command";
  FrontendMessageType2["System"] = "system";
  FrontendMessageType2["QueryObjectResult"] = "queryObjectResult";
  return FrontendMessageType2;
})(FrontendMessageType || {});

// gen/front_end/core/sdk/CPUProfilerModel.js
var CPUProfilerModel_exports = {};
__export(CPUProfilerModel_exports, {
  CPUProfilerModel: () => CPUProfilerModel,
  Events: () => Events21
});
import * as i18n27 from "./../i18n/i18n.js";
var UIStrings12 = {
  /**
   *@description Name of a profile. Placeholder is either a user-supplied name or a number automatically assigned to the profile.
   *@example {2} PH1
   */
  profileD: "Profile {PH1}"
};
var str_12 = i18n27.i18n.registerUIStrings("core/sdk/CPUProfilerModel.ts", UIStrings12);
var i18nString12 = i18n27.i18n.getLocalizedString.bind(void 0, str_12);
var CPUProfilerModel = class extends SDKModel {
  #isRecording;
  #nextAnonymousConsoleProfileNumber;
  #anonymousConsoleProfileIdToTitle;
  #profilerAgent;
  #preciseCoverageDeltaUpdateCallback;
  #debuggerModelInternal;
  registeredConsoleProfileMessages = [];
  constructor(target) {
    super(target);
    this.#isRecording = false;
    this.#nextAnonymousConsoleProfileNumber = 1;
    this.#anonymousConsoleProfileIdToTitle = /* @__PURE__ */ new Map();
    this.#profilerAgent = target.profilerAgent();
    this.#preciseCoverageDeltaUpdateCallback = null;
    target.registerProfilerDispatcher(this);
    void this.#profilerAgent.invoke_enable();
    this.#debuggerModelInternal = target.model(DebuggerModel);
  }
  runtimeModel() {
    return this.#debuggerModelInternal.runtimeModel();
  }
  debuggerModel() {
    return this.#debuggerModelInternal;
  }
  consoleProfileStarted({ id, location, title }) {
    if (!title) {
      title = i18nString12(UIStrings12.profileD, { PH1: this.#nextAnonymousConsoleProfileNumber++ });
      this.#anonymousConsoleProfileIdToTitle.set(id, title);
    }
    const eventData = this.createEventDataFrom(id, location, title);
    this.dispatchEventToListeners("ConsoleProfileStarted", eventData);
  }
  consoleProfileFinished({ id, location, profile, title }) {
    if (!title) {
      title = this.#anonymousConsoleProfileIdToTitle.get(id);
      this.#anonymousConsoleProfileIdToTitle.delete(id);
    }
    const eventData = {
      ...this.createEventDataFrom(id, location, title),
      cpuProfile: profile
    };
    this.registeredConsoleProfileMessages.push(eventData);
    this.dispatchEventToListeners("ConsoleProfileFinished", eventData);
  }
  createEventDataFrom(id, scriptLocation, title) {
    const debuggerLocation = Location.fromPayload(this.#debuggerModelInternal, scriptLocation);
    const globalId = this.target().id() + "." + id;
    return {
      id: globalId,
      scriptLocation: debuggerLocation,
      title: title || "",
      cpuProfilerModel: this
    };
  }
  isRecordingProfile() {
    return this.#isRecording;
  }
  startRecording() {
    this.#isRecording = true;
    const intervalUs = 100;
    void this.#profilerAgent.invoke_setSamplingInterval({ interval: intervalUs });
    return this.#profilerAgent.invoke_start();
  }
  stopRecording() {
    this.#isRecording = false;
    return this.#profilerAgent.invoke_stop().then((response) => response.profile || null);
  }
  startPreciseCoverage(jsCoveragePerBlock, preciseCoverageDeltaUpdateCallback) {
    const callCount = false;
    this.#preciseCoverageDeltaUpdateCallback = preciseCoverageDeltaUpdateCallback;
    const allowUpdatesTriggeredByBackend = true;
    return this.#profilerAgent.invoke_startPreciseCoverage(
      { callCount, detailed: jsCoveragePerBlock, allowTriggeredUpdates: allowUpdatesTriggeredByBackend }
    );
  }
  async takePreciseCoverage() {
    const r = await this.#profilerAgent.invoke_takePreciseCoverage();
    const timestamp = r && r.timestamp || 0;
    const coverage = r && r.result || [];
    return { timestamp, coverage };
  }
  stopPreciseCoverage() {
    this.#preciseCoverageDeltaUpdateCallback = null;
    return this.#profilerAgent.invoke_stopPreciseCoverage();
  }
  preciseCoverageDeltaUpdate({ timestamp, occasion, result }) {
    if (this.#preciseCoverageDeltaUpdateCallback) {
      void this.#preciseCoverageDeltaUpdateCallback(timestamp, occasion, result);
    }
  }
};
var Events21 = /* @__PURE__ */ ((Events210) => {
  Events210["CONSOLE_PROFILE_STARTED"] = "ConsoleProfileStarted";
  Events210["CONSOLE_PROFILE_FINISHED"] = "ConsoleProfileFinished";
  return Events210;
})(Events21 || {});
SDKModel.register(CPUProfilerModel, { capabilities: Capability.JS, autostart: true });

// gen/front_end/core/sdk/LogModel.js
var LogModel_exports = {};
__export(LogModel_exports, {
  Events: () => Events22,
  LogModel: () => LogModel
});
import * as Host11 from "./../host/host.js";
var LogModel = class extends SDKModel {
  #logAgent;
  constructor(target) {
    super(target);
    target.registerLogDispatcher(this);
    this.#logAgent = target.logAgent();
    void this.#logAgent.invoke_enable();
    if (!Host11.InspectorFrontendHost.isUnderTest()) {
      void this.#logAgent.invoke_startViolationsReport({
        config: [
          { name: Log.ViolationSettingName.LongTask, threshold: 200 },
          { name: Log.ViolationSettingName.LongLayout, threshold: 30 },
          { name: Log.ViolationSettingName.BlockedEvent, threshold: 100 },
          { name: Log.ViolationSettingName.BlockedParser, threshold: -1 },
          { name: Log.ViolationSettingName.Handler, threshold: 150 },
          { name: Log.ViolationSettingName.RecurringHandler, threshold: 50 },
          { name: Log.ViolationSettingName.DiscouragedAPIUse, threshold: -1 }
        ]
      });
    }
  }
  entryAdded({ entry }) {
    this.dispatchEventToListeners("EntryAdded", { logModel: this, entry });
  }
  requestClear() {
    void this.#logAgent.invoke_clear();
  }
};
var Events22 = /* @__PURE__ */ ((Events210) => {
  Events210["ENTRY_ADDED"] = "EntryAdded";
  return Events210;
})(Events22 || {});
SDKModel.register(LogModel, { capabilities: Capability.LOG, autostart: true });

// gen/front_end/core/sdk/ConsoleModel.js
var UIStrings13 = {
  /**
   *@description Text shown when the main frame (page) of the website was navigated to a different URL.
   *@example {https://example.com} PH1
   */
  navigatedToS: "Navigated to {PH1}",
  /**
   *@description Text shown when the main frame (page) of the website was navigated to a different URL
   * and the page was restored from back/forward cache (https://web.dev/bfcache/).
   *@example {https://example.com} PH1
   */
  bfcacheNavigation: "Navigation to {PH1} was restored from back/forward cache (see https://web.dev/bfcache/)",
  /**
   *@description Text shown in the console when a performance profile (with the given name) was started.
   *@example {title} PH1
   */
  profileSStarted: "Profile ''{PH1}'' started.",
  /**
   *@description Text shown in the console when a performance profile (with the given name) was stopped.
   *@example {name} PH1
   */
  profileSFinished: "Profile ''{PH1}'' finished.",
  /**
   *@description Error message shown in the console after the user tries to save a JavaScript value to a temporary variable.
   */
  failedToSaveToTempVariable: "Failed to save to temp variable."
};
var str_13 = i18n29.i18n.registerUIStrings("core/sdk/ConsoleModel.ts", UIStrings13);
var i18nString13 = i18n29.i18n.getLocalizedString.bind(void 0, str_13);
var ConsoleModel = class _ConsoleModel extends SDKModel {
  #messagesInternal;
  #messagesByTimestamp;
  #messageByExceptionId;
  #warningsInternal;
  #errorsInternal;
  #violationsInternal;
  #pageLoadSequenceNumber;
  #targetListeners;
  constructor(target) {
    super(target);
    this.#messagesInternal = [];
    this.#messagesByTimestamp = new Platform20.MapUtilities.Multimap();
    this.#messageByExceptionId = /* @__PURE__ */ new Map();
    this.#warningsInternal = 0;
    this.#errorsInternal = 0;
    this.#violationsInternal = 0;
    this.#pageLoadSequenceNumber = 0;
    this.#targetListeners = /* @__PURE__ */ new WeakMap();
    const resourceTreeModel = target.model(ResourceTreeModel);
    if (!resourceTreeModel || resourceTreeModel.cachedResourcesLoaded()) {
      this.initTarget(target);
      return;
    }
    const eventListener = resourceTreeModel.addEventListener(Events4.CachedResourcesLoaded, () => {
      Common30.EventTarget.removeEventListeners([eventListener]);
      this.initTarget(target);
    });
  }
  initTarget(target) {
    const eventListeners = [];
    const cpuProfilerModel = target.model(CPUProfilerModel);
    if (cpuProfilerModel) {
      eventListeners.push(cpuProfilerModel.addEventListener(
        Events21.CONSOLE_PROFILE_STARTED,
        this.consoleProfileStarted.bind(this, cpuProfilerModel)
      ));
      eventListeners.push(cpuProfilerModel.addEventListener(
        Events21.CONSOLE_PROFILE_FINISHED,
        this.consoleProfileFinished.bind(this, cpuProfilerModel)
      ));
    }
    const resourceTreeModel = target.model(ResourceTreeModel);
    if (resourceTreeModel && target.parentTarget()?.type() !== Type2.FRAME) {
      eventListeners.push(resourceTreeModel.addEventListener(
        Events4.PrimaryPageChanged,
        this.primaryPageChanged,
        this
      ));
    }
    const runtimeModel = target.model(RuntimeModel);
    if (runtimeModel) {
      eventListeners.push(runtimeModel.addEventListener(
        Events10.ExceptionThrown,
        this.exceptionThrown.bind(this, runtimeModel)
      ));
      eventListeners.push(runtimeModel.addEventListener(
        Events10.ExceptionRevoked,
        this.exceptionRevoked.bind(this, runtimeModel)
      ));
      eventListeners.push(runtimeModel.addEventListener(
        Events10.ConsoleAPICalled,
        this.consoleAPICalled.bind(this, runtimeModel)
      ));
      if (target.parentTarget()?.type() !== Type2.FRAME) {
        eventListeners.push(runtimeModel.debuggerModel().addEventListener(
          Events11.GlobalObjectCleared,
          this.clearIfNecessary,
          this
        ));
      }
      eventListeners.push(runtimeModel.addEventListener(
        Events10.QueryObjectRequested,
        this.queryObjectRequested.bind(this, runtimeModel)
      ));
    }
    this.#targetListeners.set(target, eventListeners);
  }
  targetRemoved(target) {
    const runtimeModel = target.model(RuntimeModel);
    if (runtimeModel) {
      this.#messageByExceptionId.delete(runtimeModel);
    }
    Common30.EventTarget.removeEventListeners(this.#targetListeners.get(target) || []);
  }
  async evaluateCommandInConsole(executionContext, originatingMessage, expression, useCommandLineAPI) {
    const result = await executionContext.evaluate(
      {
        expression,
        objectGroup: "console",
        includeCommandLineAPI: useCommandLineAPI,
        silent: false,
        returnByValue: false,
        generatePreview: true,
        replMode: true,
        allowUnsafeEvalBlockedByCSP: false
      },
      Common30.Settings.Settings.instance().moduleSetting("console-user-activation-eval").get(),
      /* awaitPromise */
      false
    );
    Host12.userMetrics.actionTaken(Host12.UserMetrics.Action.ConsoleEvaluated);
    if ("error" in result) {
      return;
    }
    await Common30.Console.Console.instance().showPromise();
    this.dispatchEventToListeners(
      "CommandEvaluated",
      { result: result.object, commandMessage: originatingMessage, exceptionDetails: result.exceptionDetails }
    );
  }
  addCommandMessage(executionContext, text) {
    const commandMessage = new ConsoleMessage(
      executionContext.runtimeModel,
      Log.LogEntrySource.Javascript,
      null,
      text,
      { type: FrontendMessageType.Command }
    );
    commandMessage.setExecutionContextId(executionContext.id);
    this.addMessage(commandMessage);
    return commandMessage;
  }
  addMessage(msg) {
    msg.setPageLoadSequenceNumber(this.#pageLoadSequenceNumber);
    if (msg.source === Common30.Console.FrontendMessageSource.ConsoleAPI && msg.type === Runtime.ConsoleAPICalledEventType.Clear) {
      this.clearIfNecessary();
    }
    this.#messagesInternal.push(msg);
    this.#messagesByTimestamp.set(msg.timestamp, msg);
    const runtimeModel = msg.runtimeModel();
    const exceptionId = msg.getExceptionId();
    if (exceptionId && runtimeModel) {
      let modelMap = this.#messageByExceptionId.get(runtimeModel);
      if (!modelMap) {
        modelMap = /* @__PURE__ */ new Map();
        this.#messageByExceptionId.set(runtimeModel, modelMap);
      }
      modelMap.set(exceptionId, msg);
    }
    this.incrementErrorWarningCount(msg);
    this.dispatchEventToListeners("MessageAdded", msg);
  }
  exceptionThrown(runtimeModel, event) {
    const exceptionWithTimestamp = event.data;
    const affectedResources = extractExceptionMetaData(exceptionWithTimestamp.details.exceptionMetaData);
    const consoleMessage = ConsoleMessage.fromException(
      runtimeModel,
      exceptionWithTimestamp.details,
      void 0,
      exceptionWithTimestamp.timestamp,
      void 0,
      affectedResources
    );
    consoleMessage.setExceptionId(exceptionWithTimestamp.details.exceptionId);
    this.addMessage(consoleMessage);
  }
  exceptionRevoked(runtimeModel, event) {
    const exceptionId = event.data;
    const modelMap = this.#messageByExceptionId.get(runtimeModel);
    const exceptionMessage = modelMap ? modelMap.get(exceptionId) : null;
    if (!exceptionMessage) {
      return;
    }
    this.#errorsInternal--;
    exceptionMessage.level = Log.LogEntryLevel.Verbose;
    this.dispatchEventToListeners("MessageUpdated", exceptionMessage);
  }
  consoleAPICalled(runtimeModel, event) {
    const call = event.data;
    let level = Log.LogEntryLevel.Info;
    if (call.type === Runtime.ConsoleAPICalledEventType.Debug) {
      level = Log.LogEntryLevel.Verbose;
    } else if (call.type === Runtime.ConsoleAPICalledEventType.Error || call.type === Runtime.ConsoleAPICalledEventType.Assert) {
      level = Log.LogEntryLevel.Error;
    } else if (call.type === Runtime.ConsoleAPICalledEventType.Warning) {
      level = Log.LogEntryLevel.Warning;
    } else if (call.type === Runtime.ConsoleAPICalledEventType.Info || call.type === Runtime.ConsoleAPICalledEventType.Log) {
      level = Log.LogEntryLevel.Info;
    }
    let message = "";
    if (call.args.length && call.args[0].unserializableValue) {
      message = call.args[0].unserializableValue;
    } else if (call.args.length && (typeof call.args[0].value !== "object" && typeof call.args[0].value !== "undefined" || call.args[0].value === null)) {
      message = String(call.args[0].value);
    } else if (call.args.length && call.args[0].description) {
      message = call.args[0].description;
    }
    const callFrame = call.stackTrace && call.stackTrace.callFrames.length ? call.stackTrace.callFrames[0] : null;
    const details = {
      type: call.type,
      url: callFrame?.url,
      line: callFrame?.lineNumber,
      column: callFrame?.columnNumber,
      parameters: call.args,
      stackTrace: call.stackTrace,
      timestamp: call.timestamp,
      executionContextId: call.executionContextId,
      context: call.context
    };
    const consoleMessage = new ConsoleMessage(
      runtimeModel,
      Common30.Console.FrontendMessageSource.ConsoleAPI,
      level,
      message,
      details
    );
    for (const msg of this.#messagesByTimestamp.get(consoleMessage.timestamp).values()) {
      if (consoleMessage.isEqual(msg)) {
        return;
      }
    }
    this.addMessage(consoleMessage);
  }
  queryObjectRequested(runtimeModel, event) {
    const { objects, executionContextId } = event.data;
    const details = {
      type: FrontendMessageType.QueryObjectResult,
      parameters: [objects],
      executionContextId
    };
    const consoleMessage = new ConsoleMessage(
      runtimeModel,
      Common30.Console.FrontendMessageSource.ConsoleAPI,
      Log.LogEntryLevel.Info,
      "",
      details
    );
    this.addMessage(consoleMessage);
  }
  clearIfNecessary() {
    if (!Common30.Settings.Settings.instance().moduleSetting("preserve-console-log").get()) {
      this.clear();
    }
    ++this.#pageLoadSequenceNumber;
  }
  primaryPageChanged(event) {
    if (Common30.Settings.Settings.instance().moduleSetting("preserve-console-log").get()) {
      const { frame } = event.data;
      if (frame.backForwardCacheDetails.restoredFromCache) {
        Common30.Console.Console.instance().log(i18nString13(UIStrings13.bfcacheNavigation, { PH1: frame.url }));
      } else {
        Common30.Console.Console.instance().log(i18nString13(UIStrings13.navigatedToS, { PH1: frame.url }));
      }
    }
  }
  consoleProfileStarted(cpuProfilerModel, event) {
    const { data } = event;
    this.addConsoleProfileMessage(
      cpuProfilerModel,
      Runtime.ConsoleAPICalledEventType.Profile,
      data.scriptLocation,
      i18nString13(UIStrings13.profileSStarted, { PH1: data.title })
    );
  }
  consoleProfileFinished(cpuProfilerModel, event) {
    const { data } = event;
    this.addConsoleProfileMessage(
      cpuProfilerModel,
      Runtime.ConsoleAPICalledEventType.ProfileEnd,
      data.scriptLocation,
      i18nString13(UIStrings13.profileSFinished, { PH1: data.title })
    );
  }
  addConsoleProfileMessage(cpuProfilerModel, type, scriptLocation, messageText) {
    const script = scriptLocation.script();
    const callFrames = [{
      functionName: "",
      scriptId: scriptLocation.scriptId,
      url: script ? script.contentURL() : "",
      lineNumber: scriptLocation.lineNumber,
      columnNumber: scriptLocation.columnNumber || 0
    }];
    this.addMessage(new ConsoleMessage(
      cpuProfilerModel.runtimeModel(),
      Common30.Console.FrontendMessageSource.ConsoleAPI,
      Log.LogEntryLevel.Info,
      messageText,
      { type, stackTrace: { callFrames } }
    ));
  }
  incrementErrorWarningCount(msg) {
    if (msg.source === Log.LogEntrySource.Violation) {
      this.#violationsInternal++;
      return;
    }
    switch (msg.level) {
      case Log.LogEntryLevel.Warning:
        this.#warningsInternal++;
        break;
      case Log.LogEntryLevel.Error:
        this.#errorsInternal++;
        break;
    }
  }
  messages() {
    return this.#messagesInternal;
  }
  // messages[] are not ordered by timestamp.
  static allMessagesUnordered() {
    const messages = [];
    for (const target of TargetManager.instance().targets()) {
      const targetMessages = target.model(_ConsoleModel)?.messages() || [];
      messages.push(...targetMessages);
    }
    return messages;
  }
  static requestClearMessages() {
    for (const logModel of TargetManager.instance().models(LogModel)) {
      logModel.requestClear();
    }
    for (const runtimeModel of TargetManager.instance().models(RuntimeModel)) {
      runtimeModel.discardConsoleEntries();
    }
    for (const target of TargetManager.instance().targets()) {
      target.model(_ConsoleModel)?.clear();
    }
  }
  clear() {
    this.#messagesInternal = [];
    this.#messagesByTimestamp.clear();
    this.#messageByExceptionId.clear();
    this.#errorsInternal = 0;
    this.#warningsInternal = 0;
    this.#violationsInternal = 0;
    this.dispatchEventToListeners(
      "ConsoleCleared"
      /* ConsoleCleared */
    );
  }
  errors() {
    return this.#errorsInternal;
  }
  static allErrors() {
    let errors = 0;
    for (const target of TargetManager.instance().targets()) {
      errors += target.model(_ConsoleModel)?.errors() || 0;
    }
    return errors;
  }
  warnings() {
    return this.#warningsInternal;
  }
  static allWarnings() {
    let warnings = 0;
    for (const target of TargetManager.instance().targets()) {
      warnings += target.model(_ConsoleModel)?.warnings() || 0;
    }
    return warnings;
  }
  violations() {
    return this.#violationsInternal;
  }
  static allViolations() {
    let violations = 0;
    for (const target of TargetManager.instance().targets()) {
      violations += target.model(_ConsoleModel)?.violations() || 0;
    }
    return violations;
  }
  async saveToTempVariable(currentExecutionContext, remoteObject) {
    if (!remoteObject || !currentExecutionContext) {
      failedToSave(null);
      return;
    }
    const executionContext = currentExecutionContext;
    const result = await executionContext.globalObject(
      /* objectGroup */
      "",
      /* generatePreview */
      false
    );
    if ("error" in result || Boolean(result.exceptionDetails) || !result.object) {
      failedToSave("object" in result && result.object || null);
      return;
    }
    const globalObject = result.object;
    const callFunctionResult = await globalObject.callFunction(saveVariable, [RemoteObject.toCallArgument(remoteObject)]);
    globalObject.release();
    if (callFunctionResult.wasThrown || !callFunctionResult.object || callFunctionResult.object.type !== "string") {
      failedToSave(callFunctionResult.object || null);
    } else {
      const text = callFunctionResult.object.value;
      const message = this.addCommandMessage(executionContext, text);
      void this.evaluateCommandInConsole(
        executionContext,
        message,
        text,
        /* useCommandLineAPI */
        false
      );
    }
    if (callFunctionResult.object) {
      callFunctionResult.object.release();
    }
    function saveVariable(value) {
      const prefix = "temp";
      let index = 1;
      while (prefix + index in this) {
        ++index;
      }
      const name = prefix + index;
      this[name] = value;
      return name;
    }
    function failedToSave(result2) {
      let message = i18nString13(UIStrings13.failedToSaveToTempVariable);
      if (result2) {
        message = message + " " + result2.description;
      }
      Common30.Console.Console.instance().error(message);
    }
  }
};
var Events23 = /* @__PURE__ */ ((Events210) => {
  Events210["ConsoleCleared"] = "ConsoleCleared";
  Events210["MessageAdded"] = "MessageAdded";
  Events210["MessageUpdated"] = "MessageUpdated";
  Events210["CommandEvaluated"] = "CommandEvaluated";
  return Events210;
})(Events23 || {});
function extractExceptionMetaData(metaData) {
  if (!metaData) {
    return void 0;
  }
  return { requestId: metaData.requestId || void 0, issueId: metaData.issueId || void 0 };
}
function areAffectedResourcesEquivalent(a, b) {
  return a?.requestId === b?.requestId;
}
function areStackTracesEquivalent(stackTrace1, stackTrace2) {
  if (!stackTrace1 !== !stackTrace2) {
    return false;
  }
  if (!stackTrace1 || !stackTrace2) {
    return true;
  }
  const callFrames1 = stackTrace1.callFrames;
  const callFrames2 = stackTrace2.callFrames;
  if (callFrames1.length !== callFrames2.length) {
    return false;
  }
  for (let i = 0, n = callFrames1.length; i < n; ++i) {
    if (callFrames1[i].scriptId !== callFrames2[i].scriptId || callFrames1[i].functionName !== callFrames2[i].functionName || callFrames1[i].lineNumber !== callFrames2[i].lineNumber || callFrames1[i].columnNumber !== callFrames2[i].columnNumber) {
      return false;
    }
  }
  return areStackTracesEquivalent(stackTrace1.parent, stackTrace2.parent);
}
var ConsoleMessage = class _ConsoleMessage {
  #runtimeModelInternal;
  source;
  level;
  messageText;
  type;
  url;
  line;
  column;
  parameters;
  stackTrace;
  timestamp;
  #executionContextId;
  scriptId;
  workerId;
  context;
  #originatingConsoleMessage = null;
  #pageLoadSequenceNumber = void 0;
  #exceptionId = void 0;
  #affectedResources;
  category;
  /**
   * The parent frame of the `console.log` call of logpoints or conditional breakpoints
   * if they called `console.*` explicitly. The parent frame is where V8 paused
   * and consequently where the logpoint is set.
   *
   * Is `null` for page console.logs, commands, command results, etc.
   */
  stackFrameWithBreakpoint = null;
  #originatingBreakpointType = null;
  constructor(runtimeModel, source, level, messageText, details) {
    this.#runtimeModelInternal = runtimeModel;
    this.source = source;
    this.level = level;
    this.messageText = messageText;
    this.type = details?.type || Runtime.ConsoleAPICalledEventType.Log;
    this.url = details?.url;
    this.line = details?.line || 0;
    this.column = details?.column || 0;
    this.parameters = details?.parameters;
    this.stackTrace = details?.stackTrace;
    this.timestamp = details?.timestamp || Date.now();
    this.#executionContextId = details?.executionContextId || 0;
    this.scriptId = details?.scriptId;
    this.workerId = details?.workerId;
    this.#affectedResources = details?.affectedResources;
    this.category = details?.category;
    if (!this.#executionContextId && this.#runtimeModelInternal) {
      if (this.scriptId) {
        this.#executionContextId = this.#runtimeModelInternal.executionContextIdForScriptId(this.scriptId);
      } else if (this.stackTrace) {
        this.#executionContextId = this.#runtimeModelInternal.executionContextForStackTrace(this.stackTrace);
      }
    }
    if (details?.context) {
      const match = details?.context.match(/[^#]*/);
      this.context = match?.[0];
    }
    if (this.stackTrace) {
      const { callFrame, type } = _ConsoleMessage.#stackFrameWithBreakpoint(this.stackTrace);
      this.stackFrameWithBreakpoint = callFrame;
      this.#originatingBreakpointType = type;
    }
  }
  getAffectedResources() {
    return this.#affectedResources;
  }
  setPageLoadSequenceNumber(pageLoadSequenceNumber) {
    this.#pageLoadSequenceNumber = pageLoadSequenceNumber;
  }
  static fromException(runtimeModel, exceptionDetails, messageType, timestamp, forceUrl, affectedResources) {
    const details = {
      type: messageType,
      url: forceUrl || exceptionDetails.url,
      line: exceptionDetails.lineNumber,
      column: exceptionDetails.columnNumber,
      parameters: exceptionDetails.exception ? [RemoteObject.fromLocalObject(exceptionDetails.text), exceptionDetails.exception] : void 0,
      stackTrace: exceptionDetails.stackTrace,
      timestamp,
      executionContextId: exceptionDetails.executionContextId,
      scriptId: exceptionDetails.scriptId,
      affectedResources
    };
    return new _ConsoleMessage(
      runtimeModel,
      Log.LogEntrySource.Javascript,
      Log.LogEntryLevel.Error,
      RuntimeModel.simpleTextFromException(exceptionDetails),
      details
    );
  }
  runtimeModel() {
    return this.#runtimeModelInternal;
  }
  target() {
    return this.#runtimeModelInternal ? this.#runtimeModelInternal.target() : null;
  }
  setOriginatingMessage(originatingMessage) {
    this.#originatingConsoleMessage = originatingMessage;
    this.#executionContextId = originatingMessage.#executionContextId;
  }
  originatingMessage() {
    return this.#originatingConsoleMessage;
  }
  setExecutionContextId(executionContextId) {
    this.#executionContextId = executionContextId;
  }
  getExecutionContextId() {
    return this.#executionContextId;
  }
  getExceptionId() {
    return this.#exceptionId;
  }
  setExceptionId(exceptionId) {
    this.#exceptionId = exceptionId;
  }
  isGroupMessage() {
    return this.type === Runtime.ConsoleAPICalledEventType.StartGroup || this.type === Runtime.ConsoleAPICalledEventType.StartGroupCollapsed || this.type === Runtime.ConsoleAPICalledEventType.EndGroup;
  }
  isGroupStartMessage() {
    return this.type === Runtime.ConsoleAPICalledEventType.StartGroup || this.type === Runtime.ConsoleAPICalledEventType.StartGroupCollapsed;
  }
  isErrorOrWarning() {
    return this.level === Log.LogEntryLevel.Warning || this.level === Log.LogEntryLevel.Error;
  }
  isGroupable() {
    const isUngroupableError = this.level === Log.LogEntryLevel.Error && (this.source === Log.LogEntrySource.Javascript || this.source === Log.LogEntrySource.Network);
    return this.source !== Common30.Console.FrontendMessageSource.ConsoleAPI && this.type !== FrontendMessageType.Command && this.type !== FrontendMessageType.Result && this.type !== FrontendMessageType.System && !isUngroupableError;
  }
  groupCategoryKey() {
    return [this.source, this.level, this.type, this.#pageLoadSequenceNumber].join(":");
  }
  isEqual(msg) {
    if (!msg) {
      return false;
    }
    if (this.parameters) {
      if (!msg.parameters || this.parameters.length !== msg.parameters.length) {
        return false;
      }
      for (let i = 0; i < msg.parameters.length; ++i) {
        const msgParam = msg.parameters[i];
        const param = this.parameters[i];
        if (typeof msgParam === "string" || typeof param === "string") {
          return false;
        }
        if (msgParam.type === "object" && msgParam.subtype !== "error") {
          if (!msgParam.objectId || msgParam.objectId !== param.objectId || msg.timestamp !== this.timestamp) {
            return false;
          }
        }
        if (param.type !== msgParam.type || param.value !== msgParam.value || param.description !== msgParam.description) {
          return false;
        }
      }
    }
    return this.runtimeModel() === msg.runtimeModel() && this.source === msg.source && this.type === msg.type && this.level === msg.level && this.line === msg.line && this.url === msg.url && this.scriptId === msg.scriptId && this.messageText === msg.messageText && this.#executionContextId === msg.#executionContextId && areAffectedResourcesEquivalent(this.#affectedResources, msg.#affectedResources) && areStackTracesEquivalent(this.stackTrace, msg.stackTrace);
  }
  get originatesFromLogpoint() {
    return this.#originatingBreakpointType === BreakpointType.LOGPOINT;
  }
  /** @returns true, iff this was a console.* call in a conditional breakpoint */
  get originatesFromConditionalBreakpoint() {
    return this.#originatingBreakpointType === BreakpointType.CONDITIONAL_BREAKPOINT;
  }
  static #stackFrameWithBreakpoint({ callFrames }) {
    const markerSourceUrls = [COND_BREAKPOINT_SOURCE_URL, LOGPOINT_SOURCE_URL];
    const lastBreakpointFrameIndex = callFrames.findLastIndex(({ url }) => markerSourceUrls.includes(url));
    if (lastBreakpointFrameIndex === -1 || lastBreakpointFrameIndex === callFrames.length - 1) {
      return { callFrame: null, type: null };
    }
    const type = callFrames[lastBreakpointFrameIndex].url === LOGPOINT_SOURCE_URL ? BreakpointType.LOGPOINT : BreakpointType.CONDITIONAL_BREAKPOINT;
    return { callFrame: callFrames[lastBreakpointFrameIndex + 1], type };
  }
};
SDKModel.register(ConsoleModel, { capabilities: Capability.JS, autostart: true });
var MessageSourceDisplayName = /* @__PURE__ */ new Map([
  [Log.LogEntrySource.XML, "xml"],
  [Log.LogEntrySource.Javascript, "javascript"],
  [Log.LogEntrySource.Network, "network"],
  [Common30.Console.FrontendMessageSource.ConsoleAPI, "console-api"],
  [Log.LogEntrySource.Storage, "storage"],
  [Log.LogEntrySource.Appcache, "appcache"],
  [Log.LogEntrySource.Rendering, "rendering"],
  [Common30.Console.FrontendMessageSource.CSS, "css"],
  [Log.LogEntrySource.Security, "security"],
  [Log.LogEntrySource.Deprecation, "deprecation"],
  [Log.LogEntrySource.Worker, "worker"],
  [Log.LogEntrySource.Violation, "violation"],
  [Log.LogEntrySource.Intervention, "intervention"],
  [Log.LogEntrySource.Recommendation, "recommendation"],
  [Log.LogEntrySource.Other, "other"],
  [Common30.Console.FrontendMessageSource.ISSUE_PANEL, "issue-panel"]
]);

// gen/front_end/core/sdk/CPUProfileDataModel.js
var CPUProfileDataModel_exports = {};
__export(CPUProfileDataModel_exports, {
  CPUProfileDataModel: () => CPUProfileDataModel2
});
import * as CPUProfile2 from "./../../models/cpu_profile/cpu_profile.js";
var CPUProfileDataModel2 = class extends CPUProfile2.CPUProfileDataModel.CPUProfileDataModel {
};

// gen/front_end/core/sdk/CPUThrottlingManager.js
var CPUThrottlingManager_exports = {};
__export(CPUThrottlingManager_exports, {
  CPUThrottlingManager: () => CPUThrottlingManager,
  CPUThrottlingRates: () => CPUThrottlingRates,
  Events: () => Events24,
  throttlingManager: () => throttlingManager
});
import * as Common32 from "./../common/common.js";

// gen/front_end/core/sdk/EmulationModel.js
var EmulationModel_exports = {};
__export(EmulationModel_exports, {
  DeviceOrientation: () => DeviceOrientation,
  EmulationModel: () => EmulationModel,
  Location: () => Location2
});
import * as Common31 from "./../common/common.js";
var EmulationModel = class extends SDKModel {
  #emulationAgent;
  #deviceOrientationAgent;
  #cssModel;
  #overlayModelInternal;
  #mediaConfiguration;
  #cpuPressureEnabled;
  #touchEnabled;
  #touchMobile;
  #touchEmulationAllowed;
  #customTouchEnabled;
  #touchConfiguration;
  constructor(target) {
    super(target);
    this.#emulationAgent = target.emulationAgent();
    this.#deviceOrientationAgent = target.deviceOrientationAgent();
    this.#cssModel = target.model(CSSModel);
    this.#overlayModelInternal = target.model(OverlayModel);
    if (this.#overlayModelInternal) {
      this.#overlayModelInternal.addEventListener(Events13.INSPECT_MODE_WILL_BE_TOGGLED, () => {
        void this.updateTouch();
      }, this);
    }
    const disableJavascriptSetting = Common31.Settings.Settings.instance().moduleSetting("java-script-disabled");
    disableJavascriptSetting.addChangeListener(
      async () => await this.#emulationAgent.invoke_setScriptExecutionDisabled({ value: disableJavascriptSetting.get() })
    );
    if (disableJavascriptSetting.get()) {
      void this.#emulationAgent.invoke_setScriptExecutionDisabled({ value: true });
    }
    const touchSetting = Common31.Settings.Settings.instance().moduleSetting("emulation.touch");
    touchSetting.addChangeListener(() => {
      const settingValue = touchSetting.get();
      void this.overrideEmulateTouch(settingValue === "force");
    });
    const idleDetectionSetting = Common31.Settings.Settings.instance().moduleSetting("emulation.idle-detection");
    idleDetectionSetting.addChangeListener(async () => {
      const settingValue = idleDetectionSetting.get();
      if (settingValue === "none") {
        await this.clearIdleOverride();
        return;
      }
      const emulationParams = JSON.parse(settingValue);
      await this.setIdleOverride(emulationParams);
    });
    const cpuPressureDetectionSetting = Common31.Settings.Settings.instance().moduleSetting("emulation.cpu-pressure");
    cpuPressureDetectionSetting.addChangeListener(async () => {
      const settingValue = cpuPressureDetectionSetting.get();
      if (settingValue === "none") {
        await this.setPressureSourceOverrideEnabled(false);
        this.#cpuPressureEnabled = false;
        return;
      }
      if (!this.#cpuPressureEnabled) {
        this.#cpuPressureEnabled = true;
        await this.setPressureSourceOverrideEnabled(true);
      }
      await this.setPressureStateOverride(settingValue);
    });
    const mediaTypeSetting = Common31.Settings.Settings.instance().moduleSetting("emulated-css-media");
    const mediaFeatureColorGamutSetting = Common31.Settings.Settings.instance().moduleSetting("emulated-css-media-feature-color-gamut");
    const mediaFeaturePrefersColorSchemeSetting = Common31.Settings.Settings.instance().moduleSetting("emulated-css-media-feature-prefers-color-scheme");
    const mediaFeatureForcedColorsSetting = Common31.Settings.Settings.instance().moduleSetting("emulated-css-media-feature-forced-colors");
    const mediaFeaturePrefersContrastSetting = Common31.Settings.Settings.instance().moduleSetting("emulated-css-media-feature-prefers-contrast");
    const mediaFeaturePrefersReducedDataSetting = Common31.Settings.Settings.instance().moduleSetting("emulated-css-media-feature-prefers-reduced-data");
    const mediaFeaturePrefersReducedTransparencySetting = Common31.Settings.Settings.instance().moduleSetting(
      "emulated-css-media-feature-prefers-reduced-transparency"
    );
    const mediaFeaturePrefersReducedMotionSetting = Common31.Settings.Settings.instance().moduleSetting("emulated-css-media-feature-prefers-reduced-motion");
    this.#mediaConfiguration = /* @__PURE__ */ new Map([
      ["type", mediaTypeSetting.get()],
      ["color-gamut", mediaFeatureColorGamutSetting.get()],
      ["prefers-color-scheme", mediaFeaturePrefersColorSchemeSetting.get()],
      ["forced-colors", mediaFeatureForcedColorsSetting.get()],
      ["prefers-contrast", mediaFeaturePrefersContrastSetting.get()],
      ["prefers-reduced-data", mediaFeaturePrefersReducedDataSetting.get()],
      ["prefers-reduced-motion", mediaFeaturePrefersReducedMotionSetting.get()],
      ["prefers-reduced-transparency", mediaFeaturePrefersReducedTransparencySetting.get()]
    ]);
    mediaTypeSetting.addChangeListener(() => {
      this.#mediaConfiguration.set("type", mediaTypeSetting.get());
      void this.updateCssMedia();
    });
    mediaFeatureColorGamutSetting.addChangeListener(() => {
      this.#mediaConfiguration.set("color-gamut", mediaFeatureColorGamutSetting.get());
      void this.updateCssMedia();
    });
    mediaFeaturePrefersColorSchemeSetting.addChangeListener(() => {
      this.#mediaConfiguration.set("prefers-color-scheme", mediaFeaturePrefersColorSchemeSetting.get());
      void this.updateCssMedia();
    });
    mediaFeatureForcedColorsSetting.addChangeListener(() => {
      this.#mediaConfiguration.set("forced-colors", mediaFeatureForcedColorsSetting.get());
      void this.updateCssMedia();
    });
    mediaFeaturePrefersContrastSetting.addChangeListener(() => {
      this.#mediaConfiguration.set("prefers-contrast", mediaFeaturePrefersContrastSetting.get());
      void this.updateCssMedia();
    });
    mediaFeaturePrefersReducedDataSetting.addChangeListener(() => {
      this.#mediaConfiguration.set("prefers-reduced-data", mediaFeaturePrefersReducedDataSetting.get());
      void this.updateCssMedia();
    });
    mediaFeaturePrefersReducedMotionSetting.addChangeListener(() => {
      this.#mediaConfiguration.set("prefers-reduced-motion", mediaFeaturePrefersReducedMotionSetting.get());
      void this.updateCssMedia();
    });
    mediaFeaturePrefersReducedTransparencySetting.addChangeListener(() => {
      this.#mediaConfiguration.set("prefers-reduced-transparency", mediaFeaturePrefersReducedTransparencySetting.get());
      void this.updateCssMedia();
    });
    void this.updateCssMedia();
    const autoDarkModeSetting = Common31.Settings.Settings.instance().moduleSetting("emulate-auto-dark-mode");
    autoDarkModeSetting.addChangeListener(() => {
      const enabled = autoDarkModeSetting.get();
      mediaFeaturePrefersColorSchemeSetting.setDisabled(enabled);
      mediaFeaturePrefersColorSchemeSetting.set(enabled ? "dark" : "");
      void this.emulateAutoDarkMode(enabled);
    });
    if (autoDarkModeSetting.get()) {
      mediaFeaturePrefersColorSchemeSetting.setDisabled(true);
      mediaFeaturePrefersColorSchemeSetting.set("dark");
      void this.emulateAutoDarkMode(true);
    }
    const visionDeficiencySetting = Common31.Settings.Settings.instance().moduleSetting("emulated-vision-deficiency");
    visionDeficiencySetting.addChangeListener(() => this.emulateVisionDeficiency(visionDeficiencySetting.get()));
    if (visionDeficiencySetting.get()) {
      void this.emulateVisionDeficiency(visionDeficiencySetting.get());
    }
    const localFontsDisabledSetting = Common31.Settings.Settings.instance().moduleSetting("local-fonts-disabled");
    localFontsDisabledSetting.addChangeListener(() => this.setLocalFontsDisabled(localFontsDisabledSetting.get()));
    if (localFontsDisabledSetting.get()) {
      this.setLocalFontsDisabled(localFontsDisabledSetting.get());
    }
    const avifFormatDisabledSetting = Common31.Settings.Settings.instance().moduleSetting("avif-format-disabled");
    const webpFormatDisabledSetting = Common31.Settings.Settings.instance().moduleSetting("webp-format-disabled");
    const updateDisabledImageFormats = () => {
      const types = [];
      if (avifFormatDisabledSetting.get()) {
        types.push(Emulation.DisabledImageType.Avif);
      }
      if (webpFormatDisabledSetting.get()) {
        types.push(Emulation.DisabledImageType.Webp);
      }
      this.setDisabledImageTypes(types);
    };
    avifFormatDisabledSetting.addChangeListener(updateDisabledImageFormats);
    webpFormatDisabledSetting.addChangeListener(updateDisabledImageFormats);
    if (avifFormatDisabledSetting.get() || webpFormatDisabledSetting.get()) {
      updateDisabledImageFormats();
    }
    this.#cpuPressureEnabled = false;
    this.#touchEmulationAllowed = true;
    this.#touchEnabled = false;
    this.#touchMobile = false;
    this.#customTouchEnabled = false;
    this.#touchConfiguration = {
      enabled: false,
      configuration: Emulation.SetEmitTouchEventsForMouseRequestConfiguration.Mobile
    };
  }
  setTouchEmulationAllowed(touchEmulationAllowed) {
    this.#touchEmulationAllowed = touchEmulationAllowed;
  }
  supportsDeviceEmulation() {
    return this.target().hasAllCapabilities(Capability.DEVICE_EMULATION);
  }
  async resetPageScaleFactor() {
    await this.#emulationAgent.invoke_resetPageScaleFactor();
  }
  async emulateDevice(metrics) {
    if (metrics) {
      await this.#emulationAgent.invoke_setDeviceMetricsOverride(metrics);
    } else {
      await this.#emulationAgent.invoke_clearDeviceMetricsOverride();
    }
  }
  overlayModel() {
    return this.#overlayModelInternal;
  }
  async setPressureSourceOverrideEnabled(enabled) {
    await this.#emulationAgent.invoke_setPressureSourceOverrideEnabled(
      { source: Emulation.PressureSource.Cpu, enabled }
    );
  }
  async setPressureStateOverride(pressureState) {
    await this.#emulationAgent.invoke_setPressureStateOverride({
      source: Emulation.PressureSource.Cpu,
      state: pressureState
    });
  }
  async emulateLocation(location) {
    if (!location) {
      await Promise.all([
        this.#emulationAgent.invoke_clearGeolocationOverride(),
        this.#emulationAgent.invoke_setTimezoneOverride({ timezoneId: "" }),
        this.#emulationAgent.invoke_setLocaleOverride({ locale: "" }),
        this.#emulationAgent.invoke_setUserAgentOverride(
          { userAgent: MultitargetNetworkManager.instance().currentUserAgent() }
        )
      ]);
    } else if (location.unavailable) {
      await Promise.all([
        this.#emulationAgent.invoke_setGeolocationOverride({}),
        this.#emulationAgent.invoke_setTimezoneOverride({ timezoneId: "" }),
        this.#emulationAgent.invoke_setLocaleOverride({ locale: "" }),
        this.#emulationAgent.invoke_setUserAgentOverride(
          { userAgent: MultitargetNetworkManager.instance().currentUserAgent() }
        )
      ]);
    } else {
      let processEmulationResult2 = function(errorType, result) {
        const errorMessage = result.getError();
        if (errorMessage) {
          return Promise.reject({
            type: errorType,
            message: errorMessage
          });
        }
        return Promise.resolve();
      };
      var processEmulationResult = processEmulationResult2;
      await Promise.all([
        this.#emulationAgent.invoke_setGeolocationOverride({
          latitude: location.latitude,
          longitude: location.longitude,
          accuracy: Location2.defaultGeoMockAccuracy
        }).then((result) => processEmulationResult2("emulation-set-location", result)),
        this.#emulationAgent.invoke_setTimezoneOverride({
          timezoneId: location.timezoneId
        }).then((result) => processEmulationResult2("emulation-set-timezone", result)),
        this.#emulationAgent.invoke_setLocaleOverride({
          locale: location.locale
        }).then((result) => processEmulationResult2("emulation-set-locale", result)),
        this.#emulationAgent.invoke_setUserAgentOverride({
          userAgent: MultitargetNetworkManager.instance().currentUserAgent(),
          acceptLanguage: location.locale
        }).then((result) => processEmulationResult2("emulation-set-user-agent", result))
      ]);
    }
  }
  async emulateDeviceOrientation(deviceOrientation) {
    if (deviceOrientation) {
      await this.#deviceOrientationAgent.invoke_setDeviceOrientationOverride(
        { alpha: deviceOrientation.alpha, beta: deviceOrientation.beta, gamma: deviceOrientation.gamma }
      );
    } else {
      await this.#deviceOrientationAgent.invoke_clearDeviceOrientationOverride();
    }
  }
  async setIdleOverride(emulationParams) {
    await this.#emulationAgent.invoke_setIdleOverride(emulationParams);
  }
  async clearIdleOverride() {
    await this.#emulationAgent.invoke_clearIdleOverride();
  }
  async emulateCSSMedia(type, features) {
    await this.#emulationAgent.invoke_setEmulatedMedia({ media: type, features });
    if (this.#cssModel) {
      this.#cssModel.mediaQueryResultChanged();
    }
  }
  async emulateAutoDarkMode(enabled) {
    if (enabled) {
      this.#mediaConfiguration.set("prefers-color-scheme", "dark");
      await this.updateCssMedia();
    }
    await this.#emulationAgent.invoke_setAutoDarkModeOverride({ enabled: enabled || void 0 });
  }
  async emulateVisionDeficiency(type) {
    await this.#emulationAgent.invoke_setEmulatedVisionDeficiency({ type });
  }
  setLocalFontsDisabled(disabled) {
    if (!this.#cssModel) {
      return;
    }
    void this.#cssModel.setLocalFontsEnabled(!disabled);
  }
  setDisabledImageTypes(imageTypes) {
    void this.#emulationAgent.invoke_setDisabledImageTypes({ imageTypes });
  }
  async setCPUThrottlingRate(rate) {
    await this.#emulationAgent.invoke_setCPUThrottlingRate({ rate });
  }
  async setHardwareConcurrency(hardwareConcurrency) {
    if (hardwareConcurrency < 1) {
      throw new Error("hardwareConcurrency must be a positive value");
    }
    await this.#emulationAgent.invoke_setHardwareConcurrencyOverride({ hardwareConcurrency });
  }
  async emulateTouch(enabled, mobile) {
    this.#touchEnabled = enabled && this.#touchEmulationAllowed;
    this.#touchMobile = mobile && this.#touchEmulationAllowed;
    await this.updateTouch();
  }
  async overrideEmulateTouch(enabled) {
    this.#customTouchEnabled = enabled && this.#touchEmulationAllowed;
    await this.updateTouch();
  }
  async updateTouch() {
    let configuration = {
      enabled: this.#touchEnabled,
      configuration: this.#touchMobile ? Emulation.SetEmitTouchEventsForMouseRequestConfiguration.Mobile : Emulation.SetEmitTouchEventsForMouseRequestConfiguration.Desktop
    };
    if (this.#customTouchEnabled) {
      configuration = {
        enabled: true,
        configuration: Emulation.SetEmitTouchEventsForMouseRequestConfiguration.Mobile
      };
    }
    if (this.#overlayModelInternal && this.#overlayModelInternal.inspectModeEnabled()) {
      configuration = {
        enabled: false,
        configuration: Emulation.SetEmitTouchEventsForMouseRequestConfiguration.Mobile
      };
    }
    if (!this.#touchConfiguration.enabled && !configuration.enabled) {
      return;
    }
    if (this.#touchConfiguration.enabled && configuration.enabled && this.#touchConfiguration.configuration === configuration.configuration) {
      return;
    }
    this.#touchConfiguration = configuration;
    await this.#emulationAgent.invoke_setTouchEmulationEnabled({ enabled: configuration.enabled, maxTouchPoints: 1 });
    await this.#emulationAgent.invoke_setEmitTouchEventsForMouse(
      { enabled: configuration.enabled, configuration: configuration.configuration }
    );
  }
  async updateCssMedia() {
    const type = this.#mediaConfiguration.get("type") ?? "";
    const features = [
      {
        name: "color-gamut",
        value: this.#mediaConfiguration.get("color-gamut") ?? ""
      },
      {
        name: "prefers-color-scheme",
        value: this.#mediaConfiguration.get("prefers-color-scheme") ?? ""
      },
      {
        name: "forced-colors",
        value: this.#mediaConfiguration.get("forced-colors") ?? ""
      },
      {
        name: "prefers-contrast",
        value: this.#mediaConfiguration.get("prefers-contrast") ?? ""
      },
      {
        name: "prefers-reduced-data",
        value: this.#mediaConfiguration.get("prefers-reduced-data") ?? ""
      },
      {
        name: "prefers-reduced-motion",
        value: this.#mediaConfiguration.get("prefers-reduced-motion") ?? ""
      },
      {
        name: "prefers-reduced-transparency",
        value: this.#mediaConfiguration.get("prefers-reduced-transparency") ?? ""
      }
    ];
    return this.emulateCSSMedia(type, features);
  }
};
var Location2 = class _Location {
  latitude;
  longitude;
  timezoneId;
  locale;
  unavailable;
  constructor(latitude, longitude, timezoneId, locale, unavailable) {
    this.latitude = latitude;
    this.longitude = longitude;
    this.timezoneId = timezoneId;
    this.locale = locale;
    this.unavailable = unavailable;
  }
  static parseSetting(value) {
    if (value) {
      const [position, timezoneId, locale, unavailable] = value.split(":");
      const [latitude, longitude] = position.split("@");
      return new _Location(parseFloat(latitude), parseFloat(longitude), timezoneId, locale, Boolean(unavailable));
    }
    return new _Location(0, 0, "", "", false);
  }
  static parseUserInput(latitudeString, longitudeString, timezoneId, locale) {
    if (!latitudeString && !longitudeString) {
      return null;
    }
    const { valid: isLatitudeValid } = _Location.latitudeValidator(latitudeString);
    const { valid: isLongitudeValid } = _Location.longitudeValidator(longitudeString);
    if (!isLatitudeValid && !isLongitudeValid) {
      return null;
    }
    const latitude = isLatitudeValid ? parseFloat(latitudeString) : -1;
    const longitude = isLongitudeValid ? parseFloat(longitudeString) : -1;
    return new _Location(latitude, longitude, timezoneId, locale, false);
  }
  static latitudeValidator(value) {
    const numValue = parseFloat(value);
    const valid = /^([+-]?[\d]+(\.\d+)?|[+-]?\.\d+)$/.test(value) && numValue >= -90 && numValue <= 90;
    return { valid, errorMessage: void 0 };
  }
  static longitudeValidator(value) {
    const numValue = parseFloat(value);
    const valid = /^([+-]?[\d]+(\.\d+)?|[+-]?\.\d+)$/.test(value) && numValue >= -180 && numValue <= 180;
    return { valid, errorMessage: void 0 };
  }
  static timezoneIdValidator(value) {
    const valid = value === "" || /[a-zA-Z]/.test(value);
    return { valid, errorMessage: void 0 };
  }
  static localeValidator(value) {
    const valid = value === "" || /[a-zA-Z]{2}/.test(value);
    return { valid, errorMessage: void 0 };
  }
  toSetting() {
    return `${this.latitude}@${this.longitude}:${this.timezoneId}:${this.locale}:${this.unavailable || ""}`;
  }
  static defaultGeoMockAccuracy = 150;
};
var DeviceOrientation = class _DeviceOrientation {
  alpha;
  beta;
  gamma;
  constructor(alpha, beta, gamma) {
    this.alpha = alpha;
    this.beta = beta;
    this.gamma = gamma;
  }
  static parseSetting(value) {
    if (value) {
      const jsonObject = JSON.parse(value);
      return new _DeviceOrientation(jsonObject.alpha, jsonObject.beta, jsonObject.gamma);
    }
    return new _DeviceOrientation(0, 0, 0);
  }
  static parseUserInput(alphaString, betaString, gammaString) {
    if (!alphaString && !betaString && !gammaString) {
      return null;
    }
    const { valid: isAlphaValid } = _DeviceOrientation.alphaAngleValidator(alphaString);
    const { valid: isBetaValid } = _DeviceOrientation.betaAngleValidator(betaString);
    const { valid: isGammaValid } = _DeviceOrientation.gammaAngleValidator(gammaString);
    if (!isAlphaValid && !isBetaValid && !isGammaValid) {
      return null;
    }
    const alpha = isAlphaValid ? parseFloat(alphaString) : -1;
    const beta = isBetaValid ? parseFloat(betaString) : -1;
    const gamma = isGammaValid ? parseFloat(gammaString) : -1;
    return new _DeviceOrientation(alpha, beta, gamma);
  }
  static angleRangeValidator(value, interval) {
    const numValue = parseFloat(value);
    const valid = /^([+-]?[\d]+(\.\d+)?|[+-]?\.\d+)$/.test(value) && numValue >= interval.minimum && numValue < interval.maximum;
    return { valid, errorMessage: void 0 };
  }
  static alphaAngleValidator(value) {
    return _DeviceOrientation.angleRangeValidator(value, { minimum: 0, maximum: 360 });
  }
  static betaAngleValidator(value) {
    return _DeviceOrientation.angleRangeValidator(value, { minimum: -180, maximum: 180 });
  }
  static gammaAngleValidator(value) {
    return _DeviceOrientation.angleRangeValidator(value, { minimum: -90, maximum: 90 });
  }
  toSetting() {
    return JSON.stringify(this);
  }
};
SDKModel.register(EmulationModel, { capabilities: Capability.EMULATION, autostart: true });

// gen/front_end/core/sdk/CPUThrottlingManager.js
var throttlingManagerInstance;
var CPUThrottlingManager = class _CPUThrottlingManager extends Common32.ObjectWrapper.ObjectWrapper {
  #cpuThrottlingRateInternal;
  #hardwareConcurrencyInternal;
  #pendingMainTargetPromise;
  constructor() {
    super();
    this.#cpuThrottlingRateInternal = 1;
    TargetManager.instance().observeModels(EmulationModel, this);
  }
  static instance(opts = { forceNew: null }) {
    const { forceNew } = opts;
    if (!throttlingManagerInstance || forceNew) {
      throttlingManagerInstance = new _CPUThrottlingManager();
    }
    return throttlingManagerInstance;
  }
  cpuThrottlingRate() {
    return this.#cpuThrottlingRateInternal;
  }
  setCPUThrottlingRate(rate) {
    if (rate === this.#cpuThrottlingRateInternal) {
      return;
    }
    this.#cpuThrottlingRateInternal = rate;
    for (const emulationModel of TargetManager.instance().models(EmulationModel)) {
      void emulationModel.setCPUThrottlingRate(this.#cpuThrottlingRateInternal);
    }
    this.dispatchEventToListeners("RateChanged", this.#cpuThrottlingRateInternal);
  }
  setHardwareConcurrency(concurrency) {
    this.#hardwareConcurrencyInternal = concurrency;
    for (const emulationModel of TargetManager.instance().models(EmulationModel)) {
      void emulationModel.setHardwareConcurrency(concurrency);
    }
    this.dispatchEventToListeners("HardwareConcurrencyChanged", this.#hardwareConcurrencyInternal);
  }
  hasPrimaryPageTargetSet() {
    try {
      return TargetManager.instance().primaryPageTarget() !== null;
    } catch {
      return false;
    }
  }
  async getHardwareConcurrency() {
    const target = TargetManager.instance().primaryPageTarget();
    const existingCallback = this.#pendingMainTargetPromise;
    if (!target) {
      if (existingCallback) {
        return new Promise((r) => {
          this.#pendingMainTargetPromise = (result2) => {
            r(result2);
            existingCallback(result2);
          };
        });
      }
      return new Promise((r) => {
        this.#pendingMainTargetPromise = r;
      });
    }
    const evalResult = await target.runtimeAgent().invoke_evaluate(
      { expression: "navigator.hardwareConcurrency", returnByValue: true, silent: true, throwOnSideEffect: true }
    );
    const error = evalResult.getError();
    if (error) {
      throw new Error(error);
    }
    const { result, exceptionDetails } = evalResult;
    if (exceptionDetails) {
      throw new Error(exceptionDetails.text);
    }
    return result.value;
  }
  modelAdded(emulationModel) {
    if (this.#cpuThrottlingRateInternal !== 1) {
      void emulationModel.setCPUThrottlingRate(this.#cpuThrottlingRateInternal);
    }
    if (this.#hardwareConcurrencyInternal !== void 0) {
      void emulationModel.setHardwareConcurrency(this.#hardwareConcurrencyInternal);
    }
    if (this.#pendingMainTargetPromise) {
      const existingCallback = this.#pendingMainTargetPromise;
      this.#pendingMainTargetPromise = void 0;
      void this.getHardwareConcurrency().then(existingCallback);
    }
  }
  modelRemoved(_emulationModel) {
  }
};
var Events24 = /* @__PURE__ */ ((Events210) => {
  Events210["RATE_CHANGED"] = "RateChanged";
  Events210["HARDWARE_CONCURRENCY_CHANGED"] = "HardwareConcurrencyChanged";
  return Events210;
})(Events24 || {});
function throttlingManager() {
  return CPUThrottlingManager.instance();
}
var CPUThrottlingRates = /* @__PURE__ */ ((CPUThrottlingRates2) => {
  CPUThrottlingRates2[CPUThrottlingRates2["NO_THROTTLING"] = 1] = "NO_THROTTLING";
  CPUThrottlingRates2[CPUThrottlingRates2["MidTierMobile"] = 4] = "MidTierMobile";
  CPUThrottlingRates2[CPUThrottlingRates2["LowEndMobile"] = 6] = "LowEndMobile";
  CPUThrottlingRates2[CPUThrottlingRates2["EXTRA_SLOW"] = 20] = "EXTRA_SLOW";
  return CPUThrottlingRates2;
})(CPUThrottlingRates || {});

// gen/front_end/core/sdk/DOMDebuggerModel.js
var DOMDebuggerModel_exports = {};
__export(DOMDebuggerModel_exports, {
  CSPViolationBreakpoint: () => CSPViolationBreakpoint,
  DOMBreakpoint: () => DOMBreakpoint,
  DOMDebuggerManager: () => DOMDebuggerManager,
  DOMDebuggerModel: () => DOMDebuggerModel,
  DOMEventListenerBreakpoint: () => DOMEventListenerBreakpoint,
  EventListener: () => EventListener,
  Events: () => Events25
});
import * as Common33 from "./../common/common.js";
import * as Platform21 from "./../platform/platform.js";
var DOMDebuggerModel = class extends SDKModel {
  agent;
  #runtimeModelInternal;
  #domModel;
  #domBreakpointsInternal;
  #domBreakpointsSetting;
  suspended = false;
  constructor(target) {
    super(target);
    this.agent = target.domdebuggerAgent();
    this.#runtimeModelInternal = target.model(RuntimeModel);
    this.#domModel = target.model(DOMModel);
    this.#domModel.addEventListener(Events12.DocumentUpdated, this.documentUpdated, this);
    this.#domModel.addEventListener(Events12.NodeRemoved, this.nodeRemoved, this);
    this.#domBreakpointsInternal = [];
    this.#domBreakpointsSetting = Common33.Settings.Settings.instance().createLocalSetting("dom-breakpoints", []);
    if (this.#domModel.existingDocument()) {
      void this.documentUpdated();
    }
  }
  runtimeModel() {
    return this.#runtimeModelInternal;
  }
  async suspendModel() {
    this.suspended = true;
  }
  async resumeModel() {
    this.suspended = false;
  }
  async eventListeners(remoteObject) {
    console.assert(remoteObject.runtimeModel() === this.#runtimeModelInternal);
    if (!remoteObject.objectId) {
      return [];
    }
    const listeners = await this.agent.invoke_getEventListeners({ objectId: remoteObject.objectId });
    const eventListeners = [];
    for (const payload of listeners.listeners || []) {
      const location = this.#runtimeModelInternal.debuggerModel().createRawLocationByScriptId(
        payload.scriptId,
        payload.lineNumber,
        payload.columnNumber
      );
      if (!location) {
        continue;
      }
      eventListeners.push(new EventListener(
        this,
        remoteObject,
        payload.type,
        payload.useCapture,
        payload.passive,
        payload.once,
        payload.handler ? this.#runtimeModelInternal.createRemoteObject(payload.handler) : null,
        payload.originalHandler ? this.#runtimeModelInternal.createRemoteObject(payload.originalHandler) : null,
        location,
        null
      ));
    }
    return eventListeners;
  }
  retrieveDOMBreakpoints() {
    void this.#domModel.requestDocument();
  }
  domBreakpoints() {
    return this.#domBreakpointsInternal.slice();
  }
  hasDOMBreakpoint(node, type) {
    return this.#domBreakpointsInternal.some((breakpoint) => breakpoint.node === node && breakpoint.type === type);
  }
  setDOMBreakpoint(node, type) {
    for (const breakpoint2 of this.#domBreakpointsInternal) {
      if (breakpoint2.node === node && breakpoint2.type === type) {
        this.toggleDOMBreakpoint(breakpoint2, true);
        return breakpoint2;
      }
    }
    const breakpoint = new DOMBreakpoint(this, node, type, true);
    this.#domBreakpointsInternal.push(breakpoint);
    this.saveDOMBreakpoints();
    this.enableDOMBreakpoint(breakpoint);
    this.dispatchEventToListeners("DOMBreakpointAdded", breakpoint);
    return breakpoint;
  }
  removeDOMBreakpoint(node, type) {
    this.removeDOMBreakpoints((breakpoint) => breakpoint.node === node && breakpoint.type === type);
  }
  removeAllDOMBreakpoints() {
    this.removeDOMBreakpoints((_breakpoint) => true);
  }
  toggleDOMBreakpoint(breakpoint, enabled) {
    if (enabled === breakpoint.enabled) {
      return;
    }
    breakpoint.enabled = enabled;
    if (enabled) {
      this.enableDOMBreakpoint(breakpoint);
    } else {
      this.disableDOMBreakpoint(breakpoint);
    }
    this.dispatchEventToListeners("DOMBreakpointToggled", breakpoint);
  }
  enableDOMBreakpoint(breakpoint) {
    if (breakpoint.node.id) {
      void this.agent.invoke_setDOMBreakpoint({ nodeId: breakpoint.node.id, type: breakpoint.type });
      breakpoint.node.setMarker(Marker, true);
    }
  }
  disableDOMBreakpoint(breakpoint) {
    if (breakpoint.node.id) {
      void this.agent.invoke_removeDOMBreakpoint({ nodeId: breakpoint.node.id, type: breakpoint.type });
      breakpoint.node.setMarker(Marker, this.nodeHasBreakpoints(breakpoint.node) ? true : null);
    }
  }
  nodeHasBreakpoints(node) {
    for (const breakpoint of this.#domBreakpointsInternal) {
      if (breakpoint.node === node && breakpoint.enabled) {
        return true;
      }
    }
    return false;
  }
  resolveDOMBreakpointData(auxData) {
    const type = auxData["type"];
    const node = this.#domModel.nodeForId(auxData["nodeId"]);
    if (!type || !node) {
      return null;
    }
    let targetNode = null;
    let insertion = false;
    if (type === DOMDebugger.DOMBreakpointType.SubtreeModified) {
      insertion = auxData["insertion"] || false;
      targetNode = this.#domModel.nodeForId(auxData["targetNodeId"]);
    }
    return { type, node, targetNode, insertion };
  }
  currentURL() {
    const domDocument = this.#domModel.existingDocument();
    return domDocument ? domDocument.documentURL : Platform21.DevToolsPath.EmptyUrlString;
  }
  async documentUpdated() {
    if (this.suspended) {
      return;
    }
    const removed = this.#domBreakpointsInternal;
    this.#domBreakpointsInternal = [];
    this.dispatchEventToListeners("DOMBreakpointsRemoved", removed);
    const document2 = await this.#domModel.requestDocument();
    const currentURL = document2 ? document2.documentURL : Platform21.DevToolsPath.EmptyUrlString;
    for (const breakpoint of this.#domBreakpointsSetting.get()) {
      if (breakpoint.url === currentURL) {
        void this.#domModel.pushNodeByPathToFrontend(breakpoint.path).then(appendBreakpoint.bind(this, breakpoint));
      }
    }
    function appendBreakpoint(breakpoint, nodeId) {
      const node = nodeId ? this.#domModel.nodeForId(nodeId) : null;
      if (!node) {
        return;
      }
      const domBreakpoint = new DOMBreakpoint(this, node, breakpoint.type, breakpoint.enabled);
      this.#domBreakpointsInternal.push(domBreakpoint);
      if (breakpoint.enabled) {
        this.enableDOMBreakpoint(domBreakpoint);
      }
      this.dispatchEventToListeners("DOMBreakpointAdded", domBreakpoint);
    }
  }
  removeDOMBreakpoints(filter) {
    const removed = [];
    const left = [];
    for (const breakpoint of this.#domBreakpointsInternal) {
      if (filter(breakpoint)) {
        removed.push(breakpoint);
        if (breakpoint.enabled) {
          breakpoint.enabled = false;
          this.disableDOMBreakpoint(breakpoint);
        }
      } else {
        left.push(breakpoint);
      }
    }
    if (!removed.length) {
      return;
    }
    this.#domBreakpointsInternal = left;
    this.saveDOMBreakpoints();
    this.dispatchEventToListeners("DOMBreakpointsRemoved", removed);
  }
  nodeRemoved(event) {
    if (this.suspended) {
      return;
    }
    const { node } = event.data;
    const children = node.children() || [];
    this.removeDOMBreakpoints((breakpoint) => breakpoint.node === node || children.indexOf(breakpoint.node) !== -1);
  }
  saveDOMBreakpoints() {
    const currentURL = this.currentURL();
    const breakpoints = this.#domBreakpointsSetting.get().filter((breakpoint) => breakpoint.url !== currentURL);
    for (const breakpoint of this.#domBreakpointsInternal) {
      breakpoints.push(
        { url: currentURL, path: breakpoint.node.path(), type: breakpoint.type, enabled: breakpoint.enabled }
      );
    }
    this.#domBreakpointsSetting.set(breakpoints);
  }
};
var Events25 = /* @__PURE__ */ ((Events210) => {
  Events210["DOM_BREAKPOINT_ADDED"] = "DOMBreakpointAdded";
  Events210["DOM_BREAKPOINT_TOGGLED"] = "DOMBreakpointToggled";
  Events210["DOM_BREAKPOINTS_REMOVED"] = "DOMBreakpointsRemoved";
  return Events210;
})(Events25 || {});
var Marker = "breakpoint-marker";
var DOMBreakpoint = class {
  domDebuggerModel;
  node;
  type;
  enabled;
  constructor(domDebuggerModel, node, type, enabled) {
    this.domDebuggerModel = domDebuggerModel;
    this.node = node;
    this.type = type;
    this.enabled = enabled;
  }
};
var EventListener = class _EventListener {
  #domDebuggerModelInternal;
  #eventTarget;
  #typeInternal;
  #useCaptureInternal;
  #passiveInternal;
  #onceInternal;
  #handlerInternal;
  #originalHandlerInternal;
  #locationInternal;
  #sourceURLInternal;
  #customRemoveFunction;
  #originInternal;
  constructor(domDebuggerModel, eventTarget, type, useCapture, passive, once, handler, originalHandler, location, customRemoveFunction, origin) {
    this.#domDebuggerModelInternal = domDebuggerModel;
    this.#eventTarget = eventTarget;
    this.#typeInternal = type;
    this.#useCaptureInternal = useCapture;
    this.#passiveInternal = passive;
    this.#onceInternal = once;
    this.#handlerInternal = handler;
    this.#originalHandlerInternal = originalHandler || handler;
    this.#locationInternal = location;
    const script = location.script();
    this.#sourceURLInternal = script ? script.contentURL() : Platform21.DevToolsPath.EmptyUrlString;
    this.#customRemoveFunction = customRemoveFunction;
    this.#originInternal = origin || _EventListener.Origin.RAW;
  }
  domDebuggerModel() {
    return this.#domDebuggerModelInternal;
  }
  type() {
    return this.#typeInternal;
  }
  useCapture() {
    return this.#useCaptureInternal;
  }
  passive() {
    return this.#passiveInternal;
  }
  once() {
    return this.#onceInternal;
  }
  handler() {
    return this.#handlerInternal;
  }
  location() {
    return this.#locationInternal;
  }
  sourceURL() {
    return this.#sourceURLInternal;
  }
  originalHandler() {
    return this.#originalHandlerInternal;
  }
  canRemove() {
    return Boolean(this.#customRemoveFunction) || this.#originInternal !== _EventListener.Origin.FRAMEWORK_USER;
  }
  remove() {
    if (!this.canRemove()) {
      return Promise.resolve(void 0);
    }
    if (this.#originInternal !== _EventListener.Origin.FRAMEWORK_USER) {
      let removeListener2 = function(type, listener, useCapture) {
        this.removeEventListener(type, listener, useCapture);
        if (this["on" + type]) {
          this["on" + type] = void 0;
        }
      };
      var removeListener = removeListener2;
      return this.#eventTarget.callFunction(
        removeListener2,
        [
          RemoteObject.toCallArgument(this.#typeInternal),
          RemoteObject.toCallArgument(this.#originalHandlerInternal),
          RemoteObject.toCallArgument(this.#useCaptureInternal)
        ]
      ).then(() => void 0);
    }
    if (this.#customRemoveFunction) {
      let callCustomRemove2 = function(type, listener, useCapture, passive) {
        this.call(null, type, listener, useCapture, passive);
      };
      var callCustomRemove = callCustomRemove2;
      return this.#customRemoveFunction.callFunction(
        callCustomRemove2,
        [
          RemoteObject.toCallArgument(this.#typeInternal),
          RemoteObject.toCallArgument(this.#originalHandlerInternal),
          RemoteObject.toCallArgument(this.#useCaptureInternal),
          RemoteObject.toCallArgument(this.#passiveInternal)
        ]
      ).then(() => void 0);
    }
    return Promise.resolve(void 0);
  }
  canTogglePassive() {
    return this.#originInternal !== _EventListener.Origin.FRAMEWORK_USER;
  }
  togglePassive() {
    return this.#eventTarget.callFunction(
      callTogglePassive,
      [
        RemoteObject.toCallArgument(this.#typeInternal),
        RemoteObject.toCallArgument(this.#originalHandlerInternal),
        RemoteObject.toCallArgument(this.#useCaptureInternal),
        RemoteObject.toCallArgument(this.#passiveInternal)
      ]
    ).then(() => void 0);
    function callTogglePassive(type, listener, useCapture, passive) {
      this.removeEventListener(type, listener, { capture: useCapture });
      this.addEventListener(type, listener, { capture: useCapture, passive: !passive });
    }
  }
  origin() {
    return this.#originInternal;
  }
  markAsFramework() {
    this.#originInternal = _EventListener.Origin.FRAMEWORK;
  }
  isScrollBlockingType() {
    return this.#typeInternal === "touchstart" || this.#typeInternal === "touchmove" || this.#typeInternal === "mousewheel" || this.#typeInternal === "wheel";
  }
};
((EventListener2) => {
  let Origin;
  ((Origin2) => {
    Origin2["RAW"] = "Raw";
    Origin2["FRAMEWORK"] = "Framework";
    Origin2["FRAMEWORK_USER"] = "FrameworkUser";
  })(Origin = EventListener2.Origin || (EventListener2.Origin = {}));
})(EventListener || (EventListener = {}));
var CSPViolationBreakpoint = class extends CategorizedBreakpoint {
  #typeInternal;
  constructor(category, type) {
    super(category, type);
    this.#typeInternal = type;
  }
  type() {
    return this.#typeInternal;
  }
};
var DOMEventListenerBreakpoint = class extends CategorizedBreakpoint {
  eventTargetNames;
  constructor(eventName, eventTargetNames, category) {
    super(category, eventName);
    this.eventTargetNames = eventTargetNames;
  }
  setEnabled(enabled) {
    if (this.enabled() === enabled) {
      return;
    }
    super.setEnabled(enabled);
    for (const model of TargetManager.instance().models(DOMDebuggerModel)) {
      this.updateOnModel(model);
    }
  }
  updateOnModel(model) {
    for (const eventTargetName of this.eventTargetNames) {
      if (this.enabled()) {
        void model.agent.invoke_setEventListenerBreakpoint({ eventName: this.name, targetName: eventTargetName });
      } else {
        void model.agent.invoke_removeEventListenerBreakpoint({ eventName: this.name, targetName: eventTargetName });
      }
    }
  }
  static listener = "listener:";
};
var domDebuggerManagerInstance;
var DOMDebuggerManager = class _DOMDebuggerManager {
  #xhrBreakpointsSetting;
  #xhrBreakpointsInternal;
  #cspViolationsToBreakOn;
  #eventListenerBreakpointsInternal;
  constructor() {
    this.#xhrBreakpointsSetting = Common33.Settings.Settings.instance().createLocalSetting("xhr-breakpoints", []);
    this.#xhrBreakpointsInternal = /* @__PURE__ */ new Map();
    for (const breakpoint of this.#xhrBreakpointsSetting.get()) {
      this.#xhrBreakpointsInternal.set(breakpoint.url, breakpoint.enabled);
    }
    this.#cspViolationsToBreakOn = [];
    this.#cspViolationsToBreakOn.push(new CSPViolationBreakpoint(
      Category.TRUSTED_TYPE_VIOLATION,
      DOMDebugger.CSPViolationType.TrustedtypeSinkViolation
    ));
    this.#cspViolationsToBreakOn.push(new CSPViolationBreakpoint(
      Category.TRUSTED_TYPE_VIOLATION,
      DOMDebugger.CSPViolationType.TrustedtypePolicyViolation
    ));
    this.#eventListenerBreakpointsInternal = [];
    this.createEventListenerBreakpoints(
      Category.MEDIA,
      [
        "play",
        "pause",
        "playing",
        "canplay",
        "canplaythrough",
        "seeking",
        "seeked",
        "timeupdate",
        "ended",
        "ratechange",
        "durationchange",
        "volumechange",
        "loadstart",
        "progress",
        "suspend",
        "abort",
        "error",
        "emptied",
        "stalled",
        "loadedmetadata",
        "loadeddata",
        "waiting"
      ],
      ["audio", "video"]
    );
    this.createEventListenerBreakpoints(
      Category.PICTURE_IN_PICTURE,
      ["enterpictureinpicture", "leavepictureinpicture"],
      ["video"]
    );
    this.createEventListenerBreakpoints(Category.PICTURE_IN_PICTURE, ["resize"], ["PictureInPictureWindow"]);
    this.createEventListenerBreakpoints(Category.PICTURE_IN_PICTURE, ["enter"], ["documentPictureInPicture"]);
    this.createEventListenerBreakpoints(
      Category.CLIPBOARD,
      ["copy", "cut", "paste", "beforecopy", "beforecut", "beforepaste"],
      ["*"]
    );
    this.createEventListenerBreakpoints(
      Category.CONTROL,
      [
        "resize",
        "scroll",
        "scrollend",
        "scrollsnapchange",
        "scrollsnapchanging",
        "zoom",
        "focus",
        "blur",
        "select",
        "change",
        "submit",
        "reset"
      ],
      ["*"]
    );
    this.createEventListenerBreakpoints(Category.DEVICE, ["deviceorientation", "devicemotion"], ["*"]);
    this.createEventListenerBreakpoints(
      Category.DOM_MUTATION,
      [
        "DOMActivate",
        "DOMFocusIn",
        "DOMFocusOut",
        "DOMAttrModified",
        "DOMCharacterDataModified",
        "DOMNodeInserted",
        "DOMNodeInsertedIntoDocument",
        "DOMNodeRemoved",
        "DOMNodeRemovedFromDocument",
        "DOMSubtreeModified",
        "DOMContentLoaded"
      ],
      ["*"]
    );
    this.createEventListenerBreakpoints(
      Category.DRAG_DROP,
      ["drag", "dragstart", "dragend", "dragenter", "dragover", "dragleave", "drop"],
      ["*"]
    );
    this.createEventListenerBreakpoints(Category.KEYBOARD, ["keydown", "keyup", "keypress", "input"], ["*"]);
    this.createEventListenerBreakpoints(
      Category.LOAD,
      [
        "load",
        "beforeunload",
        "unload",
        "abort",
        "error",
        "hashchange",
        "popstate",
        "navigate",
        "navigatesuccess",
        "navigateerror",
        "currentchange",
        "navigateto",
        "navigatefrom",
        "finish",
        "dispose"
      ],
      ["*"]
    );
    this.createEventListenerBreakpoints(
      Category.MOUSE,
      [
        "auxclick",
        "click",
        "dblclick",
        "mousedown",
        "mouseup",
        "mouseover",
        "mousemove",
        "mouseout",
        "mouseenter",
        "mouseleave",
        "mousewheel",
        "wheel",
        "contextmenu"
      ],
      ["*"]
    );
    this.createEventListenerBreakpoints(
      Category.POINTER,
      [
        "pointerover",
        "pointerout",
        "pointerenter",
        "pointerleave",
        "pointerdown",
        "pointerup",
        "pointermove",
        "pointercancel",
        "gotpointercapture",
        "lostpointercapture",
        "pointerrawupdate"
      ],
      ["*"]
    );
    this.createEventListenerBreakpoints(Category.TOUCH, ["touchstart", "touchmove", "touchend", "touchcancel"], ["*"]);
    this.createEventListenerBreakpoints(Category.WORKER, ["message", "messageerror"], ["*"]);
    this.createEventListenerBreakpoints(
      Category.XHR,
      ["readystatechange", "load", "loadstart", "loadend", "abort", "error", "progress", "timeout"],
      ["xmlhttprequest", "xmlhttprequestupload"]
    );
    TargetManager.instance().observeModels(DOMDebuggerModel, this);
  }
  static instance(opts = { forceNew: null }) {
    const { forceNew } = opts;
    if (!domDebuggerManagerInstance || forceNew) {
      domDebuggerManagerInstance = new _DOMDebuggerManager();
    }
    return domDebuggerManagerInstance;
  }
  cspViolationBreakpoints() {
    return this.#cspViolationsToBreakOn.slice();
  }
  createEventListenerBreakpoints(category, eventNames, eventTargetNames) {
    for (const eventName of eventNames) {
      this.#eventListenerBreakpointsInternal.push(
        new DOMEventListenerBreakpoint(eventName, eventTargetNames, category)
      );
    }
  }
  resolveEventListenerBreakpoint({ eventName, targetName }) {
    const listenerPrefix = "listener:";
    if (eventName.startsWith(listenerPrefix)) {
      eventName = eventName.substring(listenerPrefix.length);
    } else {
      return null;
    }
    targetName = (targetName || "*").toLowerCase();
    let result = null;
    for (const breakpoint of this.#eventListenerBreakpointsInternal) {
      if (eventName && breakpoint.name === eventName && breakpoint.eventTargetNames.indexOf(targetName) !== -1) {
        result = breakpoint;
      }
      if (!result && eventName && breakpoint.name === eventName && breakpoint.eventTargetNames.indexOf("*") !== -1) {
        result = breakpoint;
      }
    }
    return result;
  }
  eventListenerBreakpoints() {
    return this.#eventListenerBreakpointsInternal.slice();
  }
  updateCSPViolationBreakpoints() {
    const violationTypes = this.#cspViolationsToBreakOn.filter((v) => v.enabled()).map((v) => v.type());
    for (const model of TargetManager.instance().models(DOMDebuggerModel)) {
      this.updateCSPViolationBreakpointsForModel(model, violationTypes);
    }
  }
  updateCSPViolationBreakpointsForModel(model, violationTypes) {
    void model.agent.invoke_setBreakOnCSPViolation({ violationTypes });
  }
  xhrBreakpoints() {
    return this.#xhrBreakpointsInternal;
  }
  saveXHRBreakpoints() {
    const breakpoints = [];
    for (const url of this.#xhrBreakpointsInternal.keys()) {
      breakpoints.push({ url, enabled: this.#xhrBreakpointsInternal.get(url) || false });
    }
    this.#xhrBreakpointsSetting.set(breakpoints);
  }
  addXHRBreakpoint(url, enabled) {
    this.#xhrBreakpointsInternal.set(url, enabled);
    if (enabled) {
      for (const model of TargetManager.instance().models(DOMDebuggerModel)) {
        void model.agent.invoke_setXHRBreakpoint({ url });
      }
    }
    this.saveXHRBreakpoints();
  }
  removeXHRBreakpoint(url) {
    const enabled = this.#xhrBreakpointsInternal.get(url);
    this.#xhrBreakpointsInternal.delete(url);
    if (enabled) {
      for (const model of TargetManager.instance().models(DOMDebuggerModel)) {
        void model.agent.invoke_removeXHRBreakpoint({ url });
      }
    }
    this.saveXHRBreakpoints();
  }
  toggleXHRBreakpoint(url, enabled) {
    this.#xhrBreakpointsInternal.set(url, enabled);
    for (const model of TargetManager.instance().models(DOMDebuggerModel)) {
      if (enabled) {
        void model.agent.invoke_setXHRBreakpoint({ url });
      } else {
        void model.agent.invoke_removeXHRBreakpoint({ url });
      }
    }
    this.saveXHRBreakpoints();
  }
  modelAdded(domDebuggerModel) {
    for (const url of this.#xhrBreakpointsInternal.keys()) {
      if (this.#xhrBreakpointsInternal.get(url)) {
        void domDebuggerModel.agent.invoke_setXHRBreakpoint({ url });
      }
    }
    for (const breakpoint of this.#eventListenerBreakpointsInternal) {
      if (breakpoint.enabled()) {
        breakpoint.updateOnModel(domDebuggerModel);
      }
    }
    const violationTypes = this.#cspViolationsToBreakOn.filter((v) => v.enabled()).map((v) => v.type());
    this.updateCSPViolationBreakpointsForModel(domDebuggerModel, violationTypes);
  }
  modelRemoved(_domDebuggerModel) {
  }
};
SDKModel.register(DOMDebuggerModel, { capabilities: Capability.DOM, autostart: false });

// gen/front_end/core/sdk/EnhancedTracesParser.js
var EnhancedTracesParser_exports = {};
__export(EnhancedTracesParser_exports, {
  EnhancedTracesParser: () => EnhancedTracesParser
});
import { UserVisibleError } from "./../platform/platform.js";
var EnhancedTracesParser = class {
  #scriptRundownEvents = [];
  #scriptToV8Context = /* @__PURE__ */ new Map();
  #scriptToScriptSource = /* @__PURE__ */ new Map();
  #largeScriptToScriptSource = /* @__PURE__ */ new Map();
  #scriptToSourceLength = /* @__PURE__ */ new Map();
  #targets = [];
  #executionContexts = [];
  #scripts = [];
  static enhancedTraceVersion = 1;
  constructor(traceEvents) {
    try {
      this.parseEnhancedTrace(traceEvents);
    } catch (e) {
      throw new UserVisibleError.UserVisibleError(e);
    }
  }
  parseEnhancedTrace(traceEvents) {
    for (const event of traceEvents) {
      if (this.isTargetRundownEvent(event)) {
        const data = event.args?.data;
        this.#scriptToV8Context.set(this.getScriptIsolateId(data.isolate, data.scriptId), data.v8context);
        if (!this.#targets.find((target) => target.targetId === data.frame)) {
          this.#targets.push({
            targetId: data.frame,
            type: data.frameType,
            isolate: data.isolate,
            pid: event.pid,
            url: data.url
          });
        }
        if (!this.#executionContexts.find((executionContext) => executionContext.v8Context === data.v8context)) {
          this.#executionContexts.push({
            id: -1,
            origin: data.origin,
            v8Context: data.v8context,
            auxData: {
              frameId: data.frame,
              isDefault: data.isDefault,
              type: data.contextType
            },
            isolate: data.isolate
          });
        }
      } else if (this.isScriptRundownEvent(event)) {
        this.#scriptRundownEvents.push(event);
        const data = event.args.data;
        if (!this.#scripts.find((script) => script.scriptId === data.scriptId && script.isolate === data.isolate)) {
          this.#scripts.push({
            scriptId: data.scriptId,
            isolate: data.isolate,
            executionContextId: data.executionContextId,
            startLine: data.startLine,
            startColumn: data.startColumn,
            endLine: data.endLine,
            endColumn: data.endColumn,
            hash: data.hash,
            isModule: data.isModule,
            url: data.url,
            hasSourceUrl: data.hasSourceUrl,
            sourceMapUrl: data.sourceMapUrl
          });
        }
      } else if (this.isScriptRundownSourceEvent(event)) {
        const data = event.args.data;
        const scriptIsolateId = this.getScriptIsolateId(data.isolate, data.scriptId);
        if ("splitIndex" in data && "splitCount" in data) {
          if (!this.#largeScriptToScriptSource.has(scriptIsolateId)) {
            this.#largeScriptToScriptSource.set(scriptIsolateId, new Array(data.splitCount).fill(""));
          }
          const splittedSource = this.#largeScriptToScriptSource.get(scriptIsolateId);
          if (splittedSource && data.sourceText) {
            splittedSource[data.splitIndex] = data.sourceText;
          }
        } else {
          if (data.sourceText) {
            this.#scriptToScriptSource.set(scriptIsolateId, data.sourceText);
          }
          if (data.length) {
            this.#scriptToSourceLength.set(scriptIsolateId, data.length);
          }
        }
      }
    }
  }
  data() {
    const v8ContextToExecutionContextId = /* @__PURE__ */ new Map();
    this.#scriptRundownEvents.forEach((scriptRundownEvent) => {
      const data2 = scriptRundownEvent.args.data;
      const v8Context = this.#scriptToV8Context.get(this.getScriptIsolateId(data2.isolate, data2.scriptId));
      if (v8Context) {
        v8ContextToExecutionContextId.set(v8Context, data2.executionContextId);
      }
    });
    this.#executionContexts.forEach((executionContext) => {
      if (executionContext.v8Context) {
        const id = v8ContextToExecutionContextId.get(executionContext.v8Context);
        if (id) {
          executionContext.id = id;
        }
      }
    });
    this.#scripts.forEach((script) => {
      const scriptIsolateId = this.getScriptIsolateId(script.isolate, script.scriptId);
      if (this.#scriptToScriptSource.has(scriptIsolateId)) {
        script.sourceText = this.#scriptToScriptSource.get(scriptIsolateId);
        script.length = this.#scriptToSourceLength.get(scriptIsolateId);
      } else if (this.#largeScriptToScriptSource.has(scriptIsolateId)) {
        const splittedSources = this.#largeScriptToScriptSource.get(scriptIsolateId);
        if (splittedSources) {
          script.sourceText = splittedSources.join("");
          script.length = script.sourceText.length;
        }
      }
      script.auxData = this.#executionContexts.find((context) => context.id === script.executionContextId && context.isolate === script.isolate)?.auxData;
    });
    const data = /* @__PURE__ */ new Map();
    for (const target of this.#targets) {
      data.set(target, this.groupContextsAndScriptsUnderTarget(target, this.#executionContexts, this.#scripts));
    }
    return data;
  }
  getScriptIsolateId(isolate, scriptId) {
    return scriptId + "@" + isolate;
  }
  isTraceEvent(event) {
    return "cat" in event && "pid" in event;
  }
  isTargetRundownEvent(event) {
    return this.isTraceEvent(event) && event.cat === "disabled-by-default-devtools.target-rundown";
  }
  isScriptRundownEvent(event) {
    return this.isTraceEvent(event) && event.cat === "disabled-by-default-devtools.v8-source-rundown";
  }
  isScriptRundownSourceEvent(event) {
    return this.isTraceEvent(event) && event.cat === "disabled-by-default-devtools.v8-source-rundown-sources";
  }
  groupContextsAndScriptsUnderTarget(target, executionContexts, scripts) {
    const filteredExecutionContexts = [];
    const filteredScripts = [];
    for (const executionContext of executionContexts) {
      if (executionContext.auxData?.frameId === target.targetId) {
        filteredExecutionContexts.push(executionContext);
      }
    }
    for (const script of scripts) {
      if (script.auxData === null) {
        console.error(script + " missing aux data");
      }
      if (script.auxData?.frameId === target.targetId) {
        filteredScripts.push(script);
      }
    }
    return [filteredExecutionContexts, filteredScripts];
  }
};

// gen/front_end/core/sdk/EventBreakpointsModel.js
var EventBreakpointsModel_exports = {};
__export(EventBreakpointsModel_exports, {
  EventBreakpointsManager: () => EventBreakpointsManager,
  EventBreakpointsModel: () => EventBreakpointsModel,
  InstrumentationNames: () => InstrumentationNames
});
var InstrumentationNames = /* @__PURE__ */ ((InstrumentationNames2) => {
  InstrumentationNames2["BEFORE_BIDDER_WORKLET_BIDDING_START"] = "beforeBidderWorkletBiddingStart";
  InstrumentationNames2["BEFORE_BIDDER_WORKLET_REPORTING_START"] = "beforeBidderWorkletReportingStart";
  InstrumentationNames2["BEFORE_SELLER_WORKLET_SCORING_START"] = "beforeSellerWorkletScoringStart";
  InstrumentationNames2["BEFORE_SELLER_WORKLET_REPORTING_START"] = "beforeSellerWorkletReportingStart";
  InstrumentationNames2["SET_TIMEOUT"] = "setTimeout";
  InstrumentationNames2["CLEAR_TIMEOUT"] = "clearTimeout";
  InstrumentationNames2["SET_TIMEOUT_CALLBACK"] = "setTimeout.callback";
  InstrumentationNames2["SET_INTERVAL"] = "setInterval";
  InstrumentationNames2["CLEAR_INTERVAL"] = "clearInterval";
  InstrumentationNames2["SET_INTERVAL_CALLBACK"] = "setInterval.callback";
  InstrumentationNames2["SCRIPT_FIRST_STATEMENT"] = "scriptFirstStatement";
  InstrumentationNames2["SCRIPT_BLOCKED_BY_CSP"] = "scriptBlockedByCSP";
  InstrumentationNames2["SHARED_STORAGE_WORKLET_SCRIPT_FIRST_STATEMENT"] = "sharedStorageWorkletScriptFirstStatement";
  InstrumentationNames2["REQUEST_ANIMATION_FRAME"] = "requestAnimationFrame";
  InstrumentationNames2["CANCEL_ANIMATION_FRAME"] = "cancelAnimationFrame";
  InstrumentationNames2["REQUEST_ANIMATION_FRAME_CALLBACK"] = "requestAnimationFrame.callback";
  InstrumentationNames2["WEBGL_ERROR_FIRED"] = "webglErrorFired";
  InstrumentationNames2["WEBGL_WARNING_FIRED"] = "webglWarningFired";
  InstrumentationNames2["ELEMENT_SET_INNER_HTML"] = "Element.setInnerHTML";
  InstrumentationNames2["CANVAS_CONTEXT_CREATED"] = "canvasContextCreated";
  InstrumentationNames2["GEOLOCATION_GET_CURRENT_POSITION"] = "Geolocation.getCurrentPosition";
  InstrumentationNames2["GEOLOCATION_WATCH_POSITION"] = "Geolocation.watchPosition";
  InstrumentationNames2["NOTIFCATION_REQUEST_PERMISSION"] = "Notification.requestPermission";
  InstrumentationNames2["DOM_WINDOW_CLOSE"] = "DOMWindow.close";
  InstrumentationNames2["DOCUMENT_WRITE"] = "Document.write";
  InstrumentationNames2["AUDIO_CONTEXT_CREATED"] = "audioContextCreated";
  InstrumentationNames2["AUDIO_CONTEXT_CLOSED"] = "audioContextClosed";
  InstrumentationNames2["AUDIO_CONTEXT_RESUMED"] = "audioContextResumed";
  InstrumentationNames2["AUDIO_CONTEXT_SUSPENDED"] = "audioContextSuspended";
  return InstrumentationNames2;
})(InstrumentationNames || {});
var EventBreakpointsModel = class extends SDKModel {
  agent;
  constructor(target) {
    super(target);
    this.agent = target.eventBreakpointsAgent();
  }
};
var EventListenerBreakpoint = class extends CategorizedBreakpoint {
  setEnabled(enabled) {
    if (this.enabled() === enabled) {
      return;
    }
    super.setEnabled(enabled);
    for (const model of TargetManager.instance().models(EventBreakpointsModel)) {
      this.updateOnModel(model);
    }
  }
  updateOnModel(model) {
    if (this.enabled()) {
      void model.agent.invoke_setInstrumentationBreakpoint({ eventName: this.name });
    } else {
      void model.agent.invoke_removeInstrumentationBreakpoint({ eventName: this.name });
    }
  }
  static instrumentationPrefix = "instrumentation:";
};
var eventBreakpointManagerInstance;
var EventBreakpointsManager = class _EventBreakpointsManager {
  #eventListenerBreakpointsInternal = [];
  constructor() {
    this.createInstrumentationBreakpoints(Category.AUCTION_WORKLET, [
      "beforeBidderWorkletBiddingStart",
      "beforeBidderWorkletReportingStart",
      "beforeSellerWorkletScoringStart",
      "beforeSellerWorkletReportingStart"
      /* BEFORE_SELLER_WORKLET_REPORTING_START */
    ]);
    this.createInstrumentationBreakpoints(Category.ANIMATION, [
      "requestAnimationFrame",
      "cancelAnimationFrame",
      "requestAnimationFrame.callback"
      /* REQUEST_ANIMATION_FRAME_CALLBACK */
    ]);
    this.createInstrumentationBreakpoints(Category.CANVAS, [
      "canvasContextCreated",
      "webglErrorFired",
      "webglWarningFired"
      /* WEBGL_WARNING_FIRED */
    ]);
    this.createInstrumentationBreakpoints(Category.GEOLOCATION, [
      "Geolocation.getCurrentPosition",
      "Geolocation.watchPosition"
      /* GEOLOCATION_WATCH_POSITION */
    ]);
    this.createInstrumentationBreakpoints(Category.NOTIFICATION, [
      "Notification.requestPermission"
      /* NOTIFCATION_REQUEST_PERMISSION */
    ]);
    this.createInstrumentationBreakpoints(Category.PARSE, [
      "Element.setInnerHTML",
      "Document.write"
      /* DOCUMENT_WRITE */
    ]);
    this.createInstrumentationBreakpoints(Category.SCRIPT, [
      "scriptFirstStatement",
      "scriptBlockedByCSP"
      /* SCRIPT_BLOCKED_BY_CSP */
    ]);
    this.createInstrumentationBreakpoints(Category.SHARED_STORAGE_WORKLET, [
      "sharedStorageWorkletScriptFirstStatement"
      /* SHARED_STORAGE_WORKLET_SCRIPT_FIRST_STATEMENT */
    ]);
    this.createInstrumentationBreakpoints(Category.TIMER, [
      "setTimeout",
      "clearTimeout",
      "setTimeout.callback",
      "setInterval",
      "clearInterval",
      "setInterval.callback"
      /* SET_INTERVAL_CALLBACK */
    ]);
    this.createInstrumentationBreakpoints(Category.WINDOW, [
      "DOMWindow.close"
      /* DOM_WINDOW_CLOSE */
    ]);
    this.createInstrumentationBreakpoints(Category.WEB_AUDIO, [
      "audioContextCreated",
      "audioContextClosed",
      "audioContextResumed",
      "audioContextSuspended"
      /* AUDIO_CONTEXT_SUSPENDED */
    ]);
    TargetManager.instance().observeModels(EventBreakpointsModel, this);
  }
  static instance(opts = { forceNew: null }) {
    const { forceNew } = opts;
    if (!eventBreakpointManagerInstance || forceNew) {
      eventBreakpointManagerInstance = new _EventBreakpointsManager();
    }
    return eventBreakpointManagerInstance;
  }
  createInstrumentationBreakpoints(category, instrumentationNames) {
    for (const instrumentationName of instrumentationNames) {
      this.#eventListenerBreakpointsInternal.push(new EventListenerBreakpoint(category, instrumentationName));
    }
  }
  eventListenerBreakpoints() {
    return this.#eventListenerBreakpointsInternal.slice();
  }
  resolveEventListenerBreakpoint({ eventName }) {
    if (!eventName.startsWith(EventListenerBreakpoint.instrumentationPrefix)) {
      return null;
    }
    const instrumentationName = eventName.substring(EventListenerBreakpoint.instrumentationPrefix.length);
    return this.#eventListenerBreakpointsInternal.find((b) => b.name === instrumentationName) || null;
  }
  modelAdded(eventBreakpointModel) {
    for (const breakpoint of this.#eventListenerBreakpointsInternal) {
      if (breakpoint.enabled()) {
        breakpoint.updateOnModel(eventBreakpointModel);
      }
    }
  }
  modelRemoved(_eventBreakpointModel) {
  }
};
SDKModel.register(EventBreakpointsModel, { capabilities: Capability.EVENT_BREAKPOINTS, autostart: false });

// gen/front_end/core/sdk/sdk.prebundle.js
var FrameAssociated = __toESM(require_FrameAssociated());

// gen/front_end/core/sdk/IsolateManager.js
var IsolateManager_exports = {};
__export(IsolateManager_exports, {
  Events: () => Events26,
  Isolate: () => Isolate,
  IsolateManager: () => IsolateManager,
  MemoryTrend: () => MemoryTrend,
  MemoryTrendWindowMs: () => MemoryTrendWindowMs
});
import * as Common34 from "./../common/common.js";
var isolateManagerInstance;
var IsolateManager = class _IsolateManager extends Common34.ObjectWrapper.ObjectWrapper {
  #isolatesInternal;
  #isolateIdByModel;
  #observers;
  #pollId;
  constructor() {
    super();
    this.#isolatesInternal = /* @__PURE__ */ new Map();
    this.#isolateIdByModel = /* @__PURE__ */ new Map();
    this.#observers = /* @__PURE__ */ new Set();
    TargetManager.instance().observeModels(RuntimeModel, this);
    this.#pollId = 0;
  }
  static instance({ forceNew } = { forceNew: false }) {
    if (!isolateManagerInstance || forceNew) {
      isolateManagerInstance = new _IsolateManager();
    }
    return isolateManagerInstance;
  }
  observeIsolates(observer) {
    if (this.#observers.has(observer)) {
      throw new Error("Observer can only be registered once");
    }
    if (!this.#observers.size) {
      void this.poll();
    }
    this.#observers.add(observer);
    for (const isolate of this.#isolatesInternal.values()) {
      observer.isolateAdded(isolate);
    }
  }
  unobserveIsolates(observer) {
    this.#observers.delete(observer);
    if (!this.#observers.size) {
      ++this.#pollId;
    }
  }
  modelAdded(model) {
    void this.modelAddedInternal(model);
  }
  async modelAddedInternal(model) {
    this.#isolateIdByModel.set(model, null);
    const isolateId = await model.isolateId();
    if (!this.#isolateIdByModel.has(model)) {
      return;
    }
    if (!isolateId) {
      this.#isolateIdByModel.delete(model);
      return;
    }
    this.#isolateIdByModel.set(model, isolateId);
    let isolate = this.#isolatesInternal.get(isolateId);
    if (!isolate) {
      isolate = new Isolate(isolateId);
      this.#isolatesInternal.set(isolateId, isolate);
    }
    isolate.modelsInternal.add(model);
    if (isolate.modelsInternal.size === 1) {
      for (const observer of this.#observers) {
        observer.isolateAdded(isolate);
      }
    } else {
      for (const observer of this.#observers) {
        observer.isolateChanged(isolate);
      }
    }
  }
  modelRemoved(model) {
    const isolateId = this.#isolateIdByModel.get(model);
    this.#isolateIdByModel.delete(model);
    if (!isolateId) {
      return;
    }
    const isolate = this.#isolatesInternal.get(isolateId);
    if (!isolate) {
      return;
    }
    isolate.modelsInternal.delete(model);
    if (isolate.modelsInternal.size) {
      for (const observer of this.#observers) {
        observer.isolateChanged(isolate);
      }
      return;
    }
    for (const observer of this.#observers) {
      observer.isolateRemoved(isolate);
    }
    this.#isolatesInternal.delete(isolateId);
  }
  isolateByModel(model) {
    return this.#isolatesInternal.get(this.#isolateIdByModel.get(model) || "") || null;
  }
  isolates() {
    return this.#isolatesInternal.values();
  }
  async poll() {
    const pollId = this.#pollId;
    while (pollId === this.#pollId) {
      await Promise.all(Array.from(this.isolates(), (isolate) => isolate.update()));
      await new Promise((r) => window.setTimeout(r, PollIntervalMs));
    }
  }
};
var Events26 = /* @__PURE__ */ ((Events210) => {
  Events210["MEMORY_CHANGED"] = "MemoryChanged";
  return Events210;
})(Events26 || {});
var MemoryTrendWindowMs = 12e4;
var PollIntervalMs = 2e3;
var Isolate = class {
  #idInternal;
  modelsInternal;
  #usedHeapSizeInternal;
  #memoryTrend;
  constructor(id) {
    this.#idInternal = id;
    this.modelsInternal = /* @__PURE__ */ new Set();
    this.#usedHeapSizeInternal = 0;
    const count = MemoryTrendWindowMs / PollIntervalMs;
    this.#memoryTrend = new MemoryTrend(count);
  }
  id() {
    return this.#idInternal;
  }
  models() {
    return this.modelsInternal;
  }
  runtimeModel() {
    return this.modelsInternal.values().next().value || null;
  }
  heapProfilerModel() {
    const runtimeModel = this.runtimeModel();
    return runtimeModel && runtimeModel.heapProfilerModel();
  }
  async update() {
    const model = this.runtimeModel();
    const usage = model && await model.heapUsage();
    if (!usage) {
      return;
    }
    this.#usedHeapSizeInternal = usage.usedSize;
    this.#memoryTrend.add(this.#usedHeapSizeInternal);
    IsolateManager.instance().dispatchEventToListeners("MemoryChanged", this);
  }
  samplesCount() {
    return this.#memoryTrend.count();
  }
  usedHeapSize() {
    return this.#usedHeapSizeInternal;
  }
  /**
   * bytes per millisecond
   */
  usedHeapSizeGrowRate() {
    return this.#memoryTrend.fitSlope();
  }
};
var MemoryTrend = class {
  #maxCount;
  #base;
  #index;
  #x;
  #y;
  #sx;
  #sy;
  #sxx;
  #sxy;
  constructor(maxCount) {
    this.#maxCount = maxCount | 0;
    this.reset();
  }
  reset() {
    this.#base = Date.now();
    this.#index = 0;
    this.#x = [];
    this.#y = [];
    this.#sx = 0;
    this.#sy = 0;
    this.#sxx = 0;
    this.#sxy = 0;
  }
  count() {
    return this.#x.length;
  }
  add(heapSize, timestamp) {
    const x = typeof timestamp === "number" ? timestamp : Date.now() - this.#base;
    const y = heapSize;
    if (this.#x.length === this.#maxCount) {
      const x0 = this.#x[this.#index];
      const y0 = this.#y[this.#index];
      this.#sx -= x0;
      this.#sy -= y0;
      this.#sxx -= x0 * x0;
      this.#sxy -= x0 * y0;
    }
    this.#sx += x;
    this.#sy += y;
    this.#sxx += x * x;
    this.#sxy += x * y;
    this.#x[this.#index] = x;
    this.#y[this.#index] = y;
    this.#index = (this.#index + 1) % this.#maxCount;
  }
  fitSlope() {
    const n = this.count();
    return n < 2 ? 0 : (this.#sxy - this.#sx * this.#sy / n) / (this.#sxx - this.#sx * this.#sx / n);
  }
};

// gen/front_end/core/sdk/IssuesModel.js
var IssuesModel_exports = {};
__export(IssuesModel_exports, {
  Events: () => Events27,
  IssuesModel: () => IssuesModel
});
var IssuesModel = class extends SDKModel {
  #disposed = false;
  #enabled = false;
  constructor(target) {
    super(target);
    void this.ensureEnabled();
  }
  async ensureEnabled() {
    if (this.#enabled) {
      return;
    }
    this.#enabled = true;
    this.target().registerAuditsDispatcher(this);
    const auditsAgent = this.target().auditsAgent();
    await auditsAgent.invoke_enable();
  }
  issueAdded(issueAddedEvent) {
    this.dispatchEventToListeners("IssueAdded", { issuesModel: this, inspectorIssue: issueAddedEvent.issue });
  }
  dispose() {
    super.dispose();
    this.#disposed = true;
  }
  getTargetIfNotDisposed() {
    if (!this.#disposed) {
      return this.target();
    }
    return null;
  }
};
var Events27 = /* @__PURE__ */ ((Events210) => {
  Events210["ISSUE_ADDED"] = "IssueAdded";
  return Events210;
})(Events27 || {});
SDKModel.register(IssuesModel, { capabilities: Capability.AUDITS, autostart: true });

// gen/front_end/core/sdk/LayerTreeBase.js
var LayerTreeBase_exports = {};
__export(LayerTreeBase_exports, {
  Layer: () => Layer,
  LayerTreeBase: () => LayerTreeBase,
  StickyPositionConstraint: () => StickyPositionConstraint
});
var Layer;
((Layer2) => {
  let ScrollRectType;
  ((ScrollRectType2) => {
    ScrollRectType2["NON_FAST_SCROLLABLE"] = "NonFastScrollable";
    ScrollRectType2["TOUCH_EVENT_HANDLER"] = "TouchEventHandler";
    ScrollRectType2["WHEEL_EVENT_HANDLER"] = "WheelEventHandler";
    ScrollRectType2["REPAINTS_ON_SCROLL"] = "RepaintsOnScroll";
    ScrollRectType2["MAIN_THREAD_SCROLL_REASON"] = "MainThreadScrollingReason";
  })(ScrollRectType = Layer2.ScrollRectType || (Layer2.ScrollRectType = {}));
})(Layer || (Layer = {}));
var StickyPositionConstraint = class {
  #stickyBoxRectInternal;
  #containingBlockRectInternal;
  #nearestLayerShiftingStickyBoxInternal;
  #nearestLayerShiftingContainingBlockInternal;
  constructor(layerTree, constraint) {
    this.#stickyBoxRectInternal = constraint.stickyBoxRect;
    this.#containingBlockRectInternal = constraint.containingBlockRect;
    this.#nearestLayerShiftingStickyBoxInternal = null;
    if (layerTree && constraint.nearestLayerShiftingStickyBox) {
      this.#nearestLayerShiftingStickyBoxInternal = layerTree.layerById(constraint.nearestLayerShiftingStickyBox);
    }
    this.#nearestLayerShiftingContainingBlockInternal = null;
    if (layerTree && constraint.nearestLayerShiftingContainingBlock) {
      this.#nearestLayerShiftingContainingBlockInternal = layerTree.layerById(constraint.nearestLayerShiftingContainingBlock);
    }
  }
  stickyBoxRect() {
    return this.#stickyBoxRectInternal;
  }
  containingBlockRect() {
    return this.#containingBlockRectInternal;
  }
  nearestLayerShiftingStickyBox() {
    return this.#nearestLayerShiftingStickyBoxInternal;
  }
  nearestLayerShiftingContainingBlock() {
    return this.#nearestLayerShiftingContainingBlockInternal;
  }
};
var LayerTreeBase = class {
  #targetInternal;
  #domModel;
  layersById;
  #rootInternal;
  #contentRootInternal;
  #backendNodeIdToNodeInternal;
  #viewportSizeInternal;
  constructor(target) {
    this.#targetInternal = target;
    this.#domModel = target ? target.model(DOMModel) : null;
    this.layersById = /* @__PURE__ */ new Map();
    this.#rootInternal = null;
    this.#contentRootInternal = null;
    this.#backendNodeIdToNodeInternal = /* @__PURE__ */ new Map();
  }
  target() {
    return this.#targetInternal;
  }
  root() {
    return this.#rootInternal;
  }
  setRoot(root) {
    this.#rootInternal = root;
  }
  contentRoot() {
    return this.#contentRootInternal;
  }
  setContentRoot(contentRoot) {
    this.#contentRootInternal = contentRoot;
  }
  forEachLayer(callback, root) {
    if (!root) {
      root = this.root();
      if (!root) {
        return false;
      }
    }
    return callback(root) || root.children().some(this.forEachLayer.bind(this, callback));
  }
  layerById(id) {
    return this.layersById.get(id) || null;
  }
  async resolveBackendNodeIds(requestedNodeIds) {
    if (!requestedNodeIds.size || !this.#domModel) {
      return;
    }
    const nodesMap = await this.#domModel.pushNodesByBackendIdsToFrontend(requestedNodeIds);
    if (!nodesMap) {
      return;
    }
    for (const nodeId of nodesMap.keys()) {
      this.#backendNodeIdToNodeInternal.set(nodeId, nodesMap.get(nodeId) || null);
    }
  }
  backendNodeIdToNode() {
    return this.#backendNodeIdToNodeInternal;
  }
  setViewportSize(viewportSize) {
    this.#viewportSizeInternal = viewportSize;
  }
  viewportSize() {
    return this.#viewportSizeInternal;
  }
  nodeForId(id) {
    return this.#domModel ? this.#domModel.nodeForId(id) : null;
  }
};

// gen/front_end/core/sdk/PageLoad.js
var PageLoad_exports = {};
__export(PageLoad_exports, {
  PageLoad: () => PageLoad
});
var PageLoad = class _PageLoad {
  id;
  url;
  startTime;
  loadTime;
  contentLoadTime;
  mainRequest;
  constructor(mainRequest) {
    this.id = ++_PageLoad.lastIdentifier;
    this.url = mainRequest.url();
    this.startTime = mainRequest.startTime;
    this.mainRequest = mainRequest;
  }
  static forRequest(request) {
    return pageLoadForRequest.get(request) || null;
  }
  bindRequest(request) {
    pageLoadForRequest.set(request, this);
  }
  static lastIdentifier = 0;
};
var pageLoadForRequest = /* @__PURE__ */ new WeakMap();

// gen/front_end/core/sdk/PaintProfiler.js
var PaintProfiler_exports = {};
__export(PaintProfiler_exports, {
  PaintProfilerLogItem: () => PaintProfilerLogItem,
  PaintProfilerModel: () => PaintProfilerModel,
  PaintProfilerSnapshot: () => PaintProfilerSnapshot
});
var PaintProfilerModel = class extends SDKModel {
  layerTreeAgent;
  constructor(target) {
    super(target);
    this.layerTreeAgent = target.layerTreeAgent();
  }
  async loadSnapshotFromFragments(tiles) {
    const { snapshotId } = await this.layerTreeAgent.invoke_loadSnapshot({ tiles });
    return snapshotId ? new PaintProfilerSnapshot(this, snapshotId) : null;
  }
  loadSnapshot(encodedPicture) {
    const fragment = { x: 0, y: 0, picture: encodedPicture };
    return this.loadSnapshotFromFragments([fragment]);
  }
  async makeSnapshot(layerId) {
    const { snapshotId } = await this.layerTreeAgent.invoke_makeSnapshot({ layerId });
    return snapshotId ? new PaintProfilerSnapshot(this, snapshotId) : null;
  }
};
var PaintProfilerSnapshot = class {
  #paintProfilerModel;
  #id;
  #refCount;
  constructor(paintProfilerModel, snapshotId) {
    this.#paintProfilerModel = paintProfilerModel;
    this.#id = snapshotId;
    this.#refCount = 1;
  }
  release() {
    console.assert(this.#refCount > 0, "release is already called on the object");
    if (!--this.#refCount) {
      void this.#paintProfilerModel.layerTreeAgent.invoke_releaseSnapshot({ snapshotId: this.#id });
    }
  }
  addReference() {
    ++this.#refCount;
    console.assert(this.#refCount > 0, "Referencing a dead object");
  }
  async replay(scale, fromStep, toStep) {
    const response = await this.#paintProfilerModel.layerTreeAgent.invoke_replaySnapshot(
      { snapshotId: this.#id, fromStep, toStep, scale: scale || 1 }
    );
    return response.dataURL;
  }
  async profile(clipRect) {
    const response = await this.#paintProfilerModel.layerTreeAgent.invoke_profileSnapshot(
      { snapshotId: this.#id, minRepeatCount: 5, minDuration: 1, clipRect: clipRect || void 0 }
    );
    return response.timings;
  }
  async commandLog() {
    const response = await this.#paintProfilerModel.layerTreeAgent.invoke_snapshotCommandLog({ snapshotId: this.#id });
    return response.commandLog ? response.commandLog.map((entry, index) => new PaintProfilerLogItem(entry, index)) : null;
  }
};
var PaintProfilerLogItem = class {
  method;
  params;
  commandIndex;
  constructor(rawEntry, commandIndex) {
    this.method = rawEntry.method;
    this.params = rawEntry.params;
    this.commandIndex = commandIndex;
  }
};
SDKModel.register(PaintProfilerModel, { capabilities: Capability.DOM, autostart: false });

// gen/front_end/core/sdk/PerformanceMetricsModel.js
var PerformanceMetricsModel_exports = {};
__export(PerformanceMetricsModel_exports, {
  PerformanceMetricsModel: () => PerformanceMetricsModel
});
import * as Platform22 from "./../platform/platform.js";
var PerformanceMetricsModel = class extends SDKModel {
  #agent;
  #metricModes;
  #metricData;
  constructor(target) {
    super(target);
    this.#agent = target.performanceAgent();
    this.#metricModes = /* @__PURE__ */ new Map([
      [
        "TaskDuration",
        "CumulativeTime"
        /* CUMULATIVE_TIME */
      ],
      [
        "ScriptDuration",
        "CumulativeTime"
        /* CUMULATIVE_TIME */
      ],
      [
        "LayoutDuration",
        "CumulativeTime"
        /* CUMULATIVE_TIME */
      ],
      [
        "RecalcStyleDuration",
        "CumulativeTime"
        /* CUMULATIVE_TIME */
      ],
      [
        "LayoutCount",
        "CumulativeCount"
        /* CUMULATIVE_COUNT */
      ],
      [
        "RecalcStyleCount",
        "CumulativeCount"
        /* CUMULATIVE_COUNT */
      ]
    ]);
    this.#metricData = /* @__PURE__ */ new Map();
  }
  enable() {
    return this.#agent.invoke_enable({});
  }
  disable() {
    return this.#agent.invoke_disable();
  }
  async requestMetrics() {
    const rawMetrics = await this.#agent.invoke_getMetrics() || [];
    const metrics = /* @__PURE__ */ new Map();
    const timestamp = performance.now();
    for (const metric of rawMetrics.metrics) {
      let data = this.#metricData.get(metric.name);
      if (!data) {
        data = { lastValue: void 0, lastTimestamp: void 0 };
        this.#metricData.set(metric.name, data);
      }
      let value;
      switch (this.#metricModes.get(metric.name)) {
        case "CumulativeTime":
          value = data.lastTimestamp && data.lastValue ? Platform22.NumberUtilities.clamp(
            (metric.value - data.lastValue) * 1e3 / (timestamp - data.lastTimestamp),
            0,
            1
          ) : 0;
          data.lastValue = metric.value;
          data.lastTimestamp = timestamp;
          break;
        case "CumulativeCount":
          value = data.lastTimestamp && data.lastValue ? Math.max(0, (metric.value - data.lastValue) * 1e3 / (timestamp - data.lastTimestamp)) : 0;
          data.lastValue = metric.value;
          data.lastTimestamp = timestamp;
          break;
        default:
          value = metric.value;
          break;
      }
      metrics.set(metric.name, value);
    }
    return { metrics, timestamp };
  }
};
SDKModel.register(PerformanceMetricsModel, { capabilities: Capability.DOM, autostart: false });

// gen/front_end/core/sdk/PreloadingModel.js
var PreloadingModel_exports = {};
__export(PreloadingModel_exports, {
  Events: () => Events28,
  PreloadingModel: () => PreloadingModel,
  PreloadingStatus: () => PreloadingStatus
});
import { assertNotNullOrUndefined as assertNotNullOrUndefined3 } from "./../platform/platform.js";
var PreloadingModel = class _PreloadingModel extends SDKModel {
  agent;
  loaderIds = [];
  targetJustAttached = true;
  lastPrimaryPageModel = null;
  documents = /* @__PURE__ */ new Map();
  constructor(target) {
    super(target);
    target.registerPreloadDispatcher(new PreloadDispatcher(this));
    this.agent = target.preloadAgent();
    void this.agent.invoke_enable();
    const targetInfo = target.targetInfo();
    if (targetInfo !== void 0 && targetInfo.subtype === "prerender") {
      this.lastPrimaryPageModel = TargetManager.instance().primaryPageTarget()?.model(_PreloadingModel) || null;
    }
    TargetManager.instance().addModelListener(
      ResourceTreeModel,
      Events4.PrimaryPageChanged,
      this.onPrimaryPageChanged,
      this
    );
  }
  dispose() {
    super.dispose();
    TargetManager.instance().removeModelListener(
      ResourceTreeModel,
      Events4.PrimaryPageChanged,
      this.onPrimaryPageChanged,
      this
    );
    void this.agent.invoke_disable();
  }
  ensureDocumentPreloadingData(loaderId) {
    if (this.documents.get(loaderId) === void 0) {
      this.documents.set(loaderId, new DocumentPreloadingData());
    }
  }
  currentLoaderId() {
    if (this.targetJustAttached) {
      return null;
    }
    if (this.loaderIds.length === 0) {
      throw new Error("unreachable");
    }
    return this.loaderIds[this.loaderIds.length - 1];
  }
  currentDocument() {
    const loaderId = this.currentLoaderId();
    return loaderId === null ? null : this.documents.get(loaderId) || null;
  }
  // Returns a rule set of the current page.
  //
  // Returns reference. Don't save returned values.
  // Returned value may or may not be updated as the time grows.
  getRuleSetById(id) {
    return this.currentDocument()?.ruleSets.getById(id) || null;
  }
  // Returns rule sets of the current page.
  //
  // Returns array of pairs of id and reference. Don't save returned references.
  // Returned values may or may not be updated as the time grows.
  getAllRuleSets() {
    return this.currentDocument()?.ruleSets.getAll() || [];
  }
  getPreloadCountsByRuleSetId() {
    const countsByRuleSetId = /* @__PURE__ */ new Map();
    for (const { value } of this.getPreloadingAttempts(null)) {
      for (const ruleSetId of [null, ...value.ruleSetIds]) {
        if (countsByRuleSetId.get(ruleSetId) === void 0) {
          countsByRuleSetId.set(ruleSetId, /* @__PURE__ */ new Map());
        }
        const countsByStatus = countsByRuleSetId.get(ruleSetId);
        assertNotNullOrUndefined3(countsByStatus);
        const i = countsByStatus.get(value.status) || 0;
        countsByStatus.set(value.status, i + 1);
      }
    }
    return countsByRuleSetId;
  }
  // Returns a preloading attempt of the current page.
  //
  // Returns reference. Don't save returned values.
  // Returned value may or may not be updated as the time grows.
  getPreloadingAttemptById(id) {
    const document2 = this.currentDocument();
    if (document2 === null) {
      return null;
    }
    return document2.preloadingAttempts.getById(id, document2.sources) || null;
  }
  // Returs preloading attempts of the current page that triggered by the rule set with `ruleSetId`.
  // `ruleSetId === null` means "do not filter".
  //
  // Returns array of pairs of id and reference. Don't save returned references.
  // Returned values may or may not be updated as the time grows.
  getPreloadingAttempts(ruleSetId) {
    const document2 = this.currentDocument();
    if (document2 === null) {
      return [];
    }
    return document2.preloadingAttempts.getAll(ruleSetId, document2.sources);
  }
  // Returs preloading attempts of the previousPgae.
  //
  // Returns array of pairs of id and reference. Don't save returned references.
  // Returned values may or may not be updated as the time grows.
  getPreloadingAttemptsOfPreviousPage() {
    if (this.loaderIds.length <= 1) {
      return [];
    }
    const document2 = this.documents.get(this.loaderIds[this.loaderIds.length - 2]);
    if (document2 === void 0) {
      return [];
    }
    return document2.preloadingAttempts.getAll(null, document2.sources);
  }
  onPrimaryPageChanged(event) {
    const { frame, type } = event.data;
    if (this.lastPrimaryPageModel === null && type === PrimaryPageChangeType.ACTIVATION) {
      return;
    }
    if (this.lastPrimaryPageModel !== null && type !== PrimaryPageChangeType.ACTIVATION) {
      return;
    }
    if (this.lastPrimaryPageModel !== null && type === PrimaryPageChangeType.ACTIVATION) {
      this.loaderIds = this.lastPrimaryPageModel.loaderIds;
      for (const [loaderId, prev] of this.lastPrimaryPageModel.documents.entries()) {
        this.ensureDocumentPreloadingData(loaderId);
        this.documents.get(loaderId)?.mergePrevious(prev);
      }
    }
    this.lastPrimaryPageModel = null;
    const currentLoaderId = frame.loaderId;
    this.loaderIds.push(currentLoaderId);
    this.loaderIds = this.loaderIds.slice(-2);
    this.ensureDocumentPreloadingData(currentLoaderId);
    for (const loaderId of this.documents.keys()) {
      if (!this.loaderIds.includes(loaderId)) {
        this.documents.delete(loaderId);
      }
    }
    this.dispatchEventToListeners(
      "ModelUpdated"
      /* MODEL_UPDATED */
    );
  }
  onRuleSetUpdated(event) {
    const ruleSet = event.ruleSet;
    const loaderId = ruleSet.loaderId;
    if (this.currentLoaderId() === null) {
      this.loaderIds = [loaderId];
      this.targetJustAttached = false;
    }
    this.ensureDocumentPreloadingData(loaderId);
    this.documents.get(loaderId)?.ruleSets.upsert(ruleSet);
    this.dispatchEventToListeners(
      "ModelUpdated"
      /* MODEL_UPDATED */
    );
  }
  onRuleSetRemoved(event) {
    const id = event.id;
    for (const document2 of this.documents.values()) {
      document2.ruleSets.delete(id);
    }
    this.dispatchEventToListeners(
      "ModelUpdated"
      /* MODEL_UPDATED */
    );
  }
  onPreloadingAttemptSourcesUpdated(event) {
    const loaderId = event.loaderId;
    this.ensureDocumentPreloadingData(loaderId);
    const document2 = this.documents.get(loaderId);
    if (document2 === void 0) {
      return;
    }
    document2.sources.update(event.preloadingAttemptSources);
    document2.preloadingAttempts.maybeRegisterNotTriggered(document2.sources);
    document2.preloadingAttempts.cleanUpRemovedAttempts(document2.sources);
    this.dispatchEventToListeners(
      "ModelUpdated"
      /* MODEL_UPDATED */
    );
  }
  onPrefetchStatusUpdated(event) {
    if (event.prefetchStatus === Preload.PrefetchStatus.PrefetchEvictedAfterCandidateRemoved) {
      return;
    }
    const loaderId = event.key.loaderId;
    this.ensureDocumentPreloadingData(loaderId);
    const attempt = {
      action: Preload.SpeculationAction.Prefetch,
      key: event.key,
      status: convertPreloadingStatus(event.status),
      prefetchStatus: event.prefetchStatus || null,
      requestId: event.requestId
    };
    this.documents.get(loaderId)?.preloadingAttempts.upsert(attempt);
    this.dispatchEventToListeners(
      "ModelUpdated"
      /* MODEL_UPDATED */
    );
  }
  onPrerenderStatusUpdated(event) {
    const loaderId = event.key.loaderId;
    this.ensureDocumentPreloadingData(loaderId);
    const attempt = {
      action: Preload.SpeculationAction.Prerender,
      key: event.key,
      status: convertPreloadingStatus(event.status),
      prerenderStatus: event.prerenderStatus || null,
      disallowedMojoInterface: event.disallowedMojoInterface || null,
      mismatchedHeaders: event.mismatchedHeaders || null
    };
    this.documents.get(loaderId)?.preloadingAttempts.upsert(attempt);
    this.dispatchEventToListeners(
      "ModelUpdated"
      /* MODEL_UPDATED */
    );
  }
  onPreloadEnabledStateUpdated(event) {
    this.dispatchEventToListeners("WarningsUpdated", event);
  }
};
SDKModel.register(PreloadingModel, { capabilities: Capability.DOM, autostart: false });
var Events28 = /* @__PURE__ */ ((Events210) => {
  Events210["MODEL_UPDATED"] = "ModelUpdated";
  Events210["WARNINGS_UPDATED"] = "WarningsUpdated";
  return Events210;
})(Events28 || {});
var PreloadDispatcher = class {
  model;
  constructor(model) {
    this.model = model;
  }
  ruleSetUpdated(event) {
    this.model.onRuleSetUpdated(event);
  }
  ruleSetRemoved(event) {
    this.model.onRuleSetRemoved(event);
  }
  preloadingAttemptSourcesUpdated(event) {
    this.model.onPreloadingAttemptSourcesUpdated(event);
  }
  prefetchStatusUpdated(event) {
    this.model.onPrefetchStatusUpdated(event);
  }
  prerenderStatusUpdated(event) {
    this.model.onPrerenderStatusUpdated(event);
  }
  preloadEnabledStateUpdated(event) {
    void this.model.onPreloadEnabledStateUpdated(event);
  }
};
var DocumentPreloadingData = class {
  ruleSets = new RuleSetRegistry();
  preloadingAttempts = new PreloadingAttemptRegistry();
  sources = new SourceRegistry();
  mergePrevious(prev) {
    if (!this.ruleSets.isEmpty() || !this.sources.isEmpty()) {
      throw new Error("unreachable");
    }
    this.ruleSets = prev.ruleSets;
    this.preloadingAttempts.mergePrevious(prev.preloadingAttempts);
    this.sources = prev.sources;
  }
};
var RuleSetRegistry = class {
  map = /* @__PURE__ */ new Map();
  isEmpty() {
    return this.map.size === 0;
  }
  // Returns reference. Don't save returned values.
  // Returned values may or may not be updated as the time grows.
  getById(id) {
    return this.map.get(id) || null;
  }
  // Returns reference. Don't save returned values.
  // Returned values may or may not be updated as the time grows.
  getAll() {
    return Array.from(this.map.entries()).map(([id, value]) => ({ id, value }));
  }
  upsert(ruleSet) {
    this.map.set(ruleSet.id, ruleSet);
  }
  delete(id) {
    this.map.delete(id);
  }
};
var PreloadingStatus = /* @__PURE__ */ ((PreloadingStatus2) => {
  PreloadingStatus2["NOT_TRIGGERED"] = "NotTriggered";
  PreloadingStatus2["PENDING"] = "Pending";
  PreloadingStatus2["RUNNING"] = "Running";
  PreloadingStatus2["READY"] = "Ready";
  PreloadingStatus2["SUCCESS"] = "Success";
  PreloadingStatus2["FAILURE"] = "Failure";
  PreloadingStatus2["NOT_SUPPORTED"] = "NotSupported";
  return PreloadingStatus2;
})(PreloadingStatus || {});
function convertPreloadingStatus(status) {
  switch (status) {
    case Preload.PreloadingStatus.Pending:
      return "Pending";
    case Preload.PreloadingStatus.Running:
      return "Running";
    case Preload.PreloadingStatus.Ready:
      return "Ready";
    case Preload.PreloadingStatus.Success:
      return "Success";
    case Preload.PreloadingStatus.Failure:
      return "Failure";
    case Preload.PreloadingStatus.NotSupported:
      return "NotSupported";
  }
  throw new Error("unreachable");
}
function makePreloadingAttemptId(key) {
  let action;
  switch (key.action) {
    case Preload.SpeculationAction.Prefetch:
      action = "Prefetch";
      break;
    case Preload.SpeculationAction.Prerender:
      action = "Prerender";
      break;
  }
  let targetHint;
  switch (key.targetHint) {
    case void 0:
      targetHint = "undefined";
      break;
    case Preload.SpeculationTargetHint.Blank:
      targetHint = "Blank";
      break;
    case Preload.SpeculationTargetHint.Self:
      targetHint = "Self";
      break;
  }
  return `${key.loaderId}:${action}:${key.url}:${targetHint}`;
}
var PreloadingAttemptRegistry = class {
  map = /* @__PURE__ */ new Map();
  enrich(attempt, source) {
    let ruleSetIds = [];
    let nodeIds = [];
    if (source !== null) {
      ruleSetIds = source.ruleSetIds;
      nodeIds = source.nodeIds;
    }
    return {
      ...attempt,
      ruleSetIds,
      nodeIds
    };
  }
  // Returns reference. Don't save returned values.
  // Returned values may or may not be updated as the time grows.
  getById(id, sources) {
    const attempt = this.map.get(id) || null;
    if (attempt === null) {
      return null;
    }
    return this.enrich(attempt, sources.getById(id));
  }
  // Returs preloading attempts that triggered by the rule set with `ruleSetId`.
  // `ruleSetId === null` means "do not filter".
  //
  // Returns reference. Don't save returned values.
  // Returned values may or may not be updated as the time grows.
  getAll(ruleSetId, sources) {
    return [...this.map.entries()].map(([id, value]) => ({ id, value: this.enrich(value, sources.getById(id)) })).filter(({ value }) => !ruleSetId || value.ruleSetIds.includes(ruleSetId));
  }
  upsert(attempt) {
    const id = makePreloadingAttemptId(attempt.key);
    this.map.set(id, attempt);
  }
  // Speculation rules emits a CDP event Preload.preloadingAttemptSourcesUpdated
  // and an IPC SpeculationHost::UpdateSpeculationCandidates. The latter emits
  // Preload.prefetch/prerenderAttemptUpdated for each preload attempt triggered.
  // In general, "Not triggered to triggered" period is short (resp. long) for
  // eager (resp. non-eager) preloads. For not yet emitted ones, we fill
  // "Not triggered" preload attempts and show them.
  maybeRegisterNotTriggered(sources) {
    for (const [id, { key }] of sources.entries()) {
      if (this.map.get(id) !== void 0) {
        continue;
      }
      let attempt;
      switch (key.action) {
        case Preload.SpeculationAction.Prefetch:
          attempt = {
            action: Preload.SpeculationAction.Prefetch,
            key,
            status: "NotTriggered",
            prefetchStatus: null,
            // Fill invalid request id.
            requestId: ""
          };
          break;
        case Preload.SpeculationAction.Prerender:
          attempt = {
            action: Preload.SpeculationAction.Prerender,
            key,
            status: "NotTriggered",
            prerenderStatus: null,
            disallowedMojoInterface: null,
            mismatchedHeaders: null
          };
          break;
      }
      this.map.set(id, attempt);
    }
  }
  // Removes keys in `this.map` that are not in `sources`. This is used to
  // remove attempts that no longer have a matching speculation rule.
  cleanUpRemovedAttempts(sources) {
    const keysToRemove = Array.from(this.map.keys()).filter((key) => !sources.getById(key));
    for (const key of keysToRemove) {
      this.map.delete(key);
    }
  }
  mergePrevious(prev) {
    for (const [id, attempt] of this.map.entries()) {
      prev.map.set(id, attempt);
    }
    this.map = prev.map;
  }
};
var SourceRegistry = class {
  map = /* @__PURE__ */ new Map();
  entries() {
    return this.map.entries();
  }
  isEmpty() {
    return this.map.size === 0;
  }
  getById(id) {
    return this.map.get(id) || null;
  }
  update(sources) {
    this.map = new Map(sources.map((s) => [makePreloadingAttemptId(s.key), s]));
  }
};

// gen/front_end/core/sdk/ServiceWorkerCacheModel.js
var ServiceWorkerCacheModel_exports = {};
__export(ServiceWorkerCacheModel_exports, {
  Cache: () => Cache,
  Events: () => Events30,
  ServiceWorkerCacheModel: () => ServiceWorkerCacheModel
});
import * as Common35 from "./../common/common.js";
import * as i18n31 from "./../i18n/i18n.js";

// gen/front_end/core/sdk/StorageBucketsModel.js
var StorageBucketsModel_exports = {};
__export(StorageBucketsModel_exports, {
  Events: () => Events29,
  StorageBucketsModel: () => StorageBucketsModel
});
var StorageBucketsModel = class extends SDKModel {
  enabled = false;
  storageAgent;
  storageKeyManager;
  bucketsById = /* @__PURE__ */ new Map();
  trackedStorageKeys = /* @__PURE__ */ new Set();
  constructor(target) {
    super(target);
    target.registerStorageDispatcher(this);
    this.storageAgent = target.storageAgent();
    this.storageKeyManager = target.model(StorageKeyManager);
  }
  getBuckets() {
    return new Set(this.bucketsById.values());
  }
  getBucketsForStorageKey(storageKey) {
    const buckets = [...this.bucketsById.values()];
    return new Set(buckets.filter(({ bucket }) => bucket.storageKey === storageKey));
  }
  getDefaultBucketForStorageKey(storageKey) {
    const buckets = [...this.bucketsById.values()];
    return buckets.find(({ bucket }) => bucket.storageKey === storageKey && bucket.name === void 0) ?? null;
  }
  getBucketById(bucketId) {
    return this.bucketsById.get(bucketId) ?? null;
  }
  getBucketByName(storageKey, bucketName) {
    if (!bucketName) {
      return this.getDefaultBucketForStorageKey(storageKey);
    }
    const buckets = [...this.bucketsById.values()];
    return buckets.find(({ bucket }) => bucket.storageKey === storageKey && bucket.name === bucketName) ?? null;
  }
  deleteBucket(bucket) {
    void this.storageAgent.invoke_deleteStorageBucket({ bucket });
  }
  enable() {
    if (this.enabled) {
      return;
    }
    if (this.storageKeyManager) {
      this.storageKeyManager.addEventListener(Events15.STORAGE_KEY_ADDED, this.storageKeyAdded, this);
      this.storageKeyManager.addEventListener(
        Events15.STORAGE_KEY_REMOVED,
        this.storageKeyRemoved,
        this
      );
      for (const storageKey of this.storageKeyManager.storageKeys()) {
        this.addStorageKey(storageKey);
      }
    }
    this.enabled = true;
  }
  storageKeyAdded(event) {
    this.addStorageKey(event.data);
  }
  storageKeyRemoved(event) {
    this.removeStorageKey(event.data);
  }
  addStorageKey(storageKey) {
    if (this.trackedStorageKeys.has(storageKey)) {
      throw new Error("Can't call addStorageKey for a storage key if it has already been added.");
    }
    this.trackedStorageKeys.add(storageKey);
    void this.storageAgent.invoke_setStorageBucketTracking({ storageKey, enable: true });
  }
  removeStorageKey(storageKey) {
    if (!this.trackedStorageKeys.has(storageKey)) {
      throw new Error("Can't call removeStorageKey for a storage key if it hasn't already been added.");
    }
    const bucketsForStorageKey = this.getBucketsForStorageKey(storageKey);
    for (const bucket of bucketsForStorageKey) {
      this.bucketRemoved(bucket);
    }
    this.trackedStorageKeys.delete(storageKey);
    void this.storageAgent.invoke_setStorageBucketTracking({ storageKey, enable: false });
  }
  bucketAdded(bucketInfo) {
    this.bucketsById.set(bucketInfo.id, bucketInfo);
    this.dispatchEventToListeners("BucketAdded", { model: this, bucketInfo });
  }
  bucketRemoved(bucketInfo) {
    this.bucketsById.delete(bucketInfo.id);
    this.dispatchEventToListeners("BucketRemoved", { model: this, bucketInfo });
  }
  bucketChanged(bucketInfo) {
    this.dispatchEventToListeners("BucketChanged", { model: this, bucketInfo });
  }
  bucketInfosAreEqual(bucketInfo1, bucketInfo2) {
    return bucketInfo1.bucket.storageKey === bucketInfo2.bucket.storageKey && bucketInfo1.id === bucketInfo2.id && bucketInfo1.bucket.name === bucketInfo2.bucket.name && bucketInfo1.expiration === bucketInfo2.expiration && bucketInfo1.quota === bucketInfo2.quota && bucketInfo1.persistent === bucketInfo2.persistent && bucketInfo1.durability === bucketInfo2.durability;
  }
  storageBucketCreatedOrUpdated({ bucketInfo }) {
    const curBucket = this.getBucketById(bucketInfo.id);
    if (curBucket) {
      if (!this.bucketInfosAreEqual(curBucket, bucketInfo)) {
        this.bucketChanged(bucketInfo);
      }
    } else {
      this.bucketAdded(bucketInfo);
    }
  }
  storageBucketDeleted({ bucketId }) {
    const curBucket = this.getBucketById(bucketId);
    if (curBucket) {
      this.bucketRemoved(curBucket);
    } else {
      throw new Error(
        `Received an event that Storage Bucket '${bucketId}' was deleted, but it wasn't in the StorageBucketsModel.`
      );
    }
  }
  attributionReportingTriggerRegistered(_event) {
  }
  interestGroupAccessed(_event) {
  }
  interestGroupAuctionEventOccurred(_event) {
  }
  interestGroupAuctionNetworkRequestCreated(_event) {
  }
  indexedDBListUpdated(_event) {
  }
  indexedDBContentUpdated(_event) {
  }
  cacheStorageListUpdated(_event) {
  }
  cacheStorageContentUpdated(_event) {
  }
  sharedStorageAccessed(_event) {
  }
  attributionReportingSourceRegistered(_event) {
  }
};
SDKModel.register(StorageBucketsModel, { capabilities: Capability.STORAGE, autostart: false });
var Events29 = /* @__PURE__ */ ((Events210) => {
  Events210["BUCKET_ADDED"] = "BucketAdded";
  Events210["BUCKET_REMOVED"] = "BucketRemoved";
  Events210["BUCKET_CHANGED"] = "BucketChanged";
  return Events210;
})(Events29 || {});

// gen/front_end/core/sdk/ServiceWorkerCacheModel.js
var UIStrings14 = {
  /**
   *@description Text in Service Worker Cache Model
   *@example {https://cache} PH1
   *@example {error message} PH2
   */
  serviceworkercacheagentError: "`ServiceWorkerCacheAgent` error deleting cache entry {PH1} in cache: {PH2}"
};
var str_14 = i18n31.i18n.registerUIStrings("core/sdk/ServiceWorkerCacheModel.ts", UIStrings14);
var i18nString14 = i18n31.i18n.getLocalizedString.bind(void 0, str_14);
var ServiceWorkerCacheModel = class extends SDKModel {
  cacheAgent;
  #storageAgent;
  #storageBucketModel;
  #cachesInternal = /* @__PURE__ */ new Map();
  #storageKeysTracked = /* @__PURE__ */ new Set();
  #storageBucketsUpdated = /* @__PURE__ */ new Set();
  #throttler = new Common35.Throttler.Throttler(2e3);
  #enabled = false;
  // Used by tests to remove the Throttler timeout.
  #scheduleAsSoonAsPossible = false;
  /**
   * Invariant: This #model can only be constructed on a ServiceWorker target.
   */
  constructor(target) {
    super(target);
    target.registerStorageDispatcher(this);
    this.cacheAgent = target.cacheStorageAgent();
    this.#storageAgent = target.storageAgent();
    this.#storageBucketModel = target.model(StorageBucketsModel);
  }
  enable() {
    if (this.#enabled) {
      return;
    }
    this.#storageBucketModel.addEventListener(Events29.BUCKET_ADDED, this.storageBucketAdded, this);
    this.#storageBucketModel.addEventListener(
      Events29.BUCKET_REMOVED,
      this.storageBucketRemoved,
      this
    );
    for (const storageBucket of this.#storageBucketModel.getBuckets()) {
      this.addStorageBucket(storageBucket.bucket);
    }
    this.#enabled = true;
  }
  clearForStorageKey(storageKey) {
    for (const [opaqueId, cache] of this.#cachesInternal.entries()) {
      if (cache.storageKey === storageKey) {
        this.#cachesInternal.delete(opaqueId);
        this.cacheRemoved(cache);
      }
    }
    for (const storageBucket of this.#storageBucketModel.getBucketsForStorageKey(storageKey)) {
      void this.loadCacheNames(storageBucket.bucket);
    }
  }
  refreshCacheNames() {
    for (const cache of this.#cachesInternal.values()) {
      this.cacheRemoved(cache);
    }
    this.#cachesInternal.clear();
    const storageBuckets = this.#storageBucketModel.getBuckets();
    for (const storageBucket of storageBuckets) {
      void this.loadCacheNames(storageBucket.bucket);
    }
  }
  async deleteCache(cache) {
    const response = await this.cacheAgent.invoke_deleteCache({ cacheId: cache.cacheId });
    if (response.getError()) {
      console.error(`ServiceWorkerCacheAgent error deleting cache ${cache.toString()}: ${response.getError()}`);
      return;
    }
    this.#cachesInternal.delete(cache.cacheId);
    this.cacheRemoved(cache);
  }
  async deleteCacheEntry(cache, request) {
    const response = await this.cacheAgent.invoke_deleteEntry({ cacheId: cache.cacheId, request });
    if (response.getError()) {
      Common35.Console.Console.instance().error(i18nString14(
        UIStrings14.serviceworkercacheagentError,
        { PH1: cache.toString(), PH2: String(response.getError()) }
      ));
      return;
    }
  }
  loadCacheData(cache, skipCount, pageSize, pathFilter, callback) {
    void this.requestEntries(cache, skipCount, pageSize, pathFilter, callback);
  }
  loadAllCacheData(cache, pathFilter, callback) {
    void this.requestAllEntries(cache, pathFilter, callback);
  }
  caches() {
    const caches = new Array();
    for (const cache of this.#cachesInternal.values()) {
      caches.push(cache);
    }
    return caches;
  }
  dispose() {
    for (const cache of this.#cachesInternal.values()) {
      this.cacheRemoved(cache);
    }
    this.#cachesInternal.clear();
    if (this.#enabled) {
      this.#storageBucketModel.removeEventListener(
        Events29.BUCKET_ADDED,
        this.storageBucketAdded,
        this
      );
      this.#storageBucketModel.removeEventListener(
        Events29.BUCKET_REMOVED,
        this.storageBucketRemoved,
        this
      );
    }
  }
  addStorageBucket(storageBucket) {
    void this.loadCacheNames(storageBucket);
    if (!this.#storageKeysTracked.has(storageBucket.storageKey)) {
      this.#storageKeysTracked.add(storageBucket.storageKey);
      void this.#storageAgent.invoke_trackCacheStorageForStorageKey({ storageKey: storageBucket.storageKey });
    }
  }
  removeStorageBucket(storageBucket) {
    let storageKeyCount = 0;
    for (const [opaqueId, cache] of this.#cachesInternal.entries()) {
      if (storageBucket.storageKey === cache.storageKey) {
        storageKeyCount++;
      }
      if (cache.inBucket(storageBucket)) {
        storageKeyCount--;
        this.#cachesInternal.delete(opaqueId);
        this.cacheRemoved(cache);
      }
    }
    if (storageKeyCount === 0) {
      this.#storageKeysTracked.delete(storageBucket.storageKey);
      void this.#storageAgent.invoke_untrackCacheStorageForStorageKey({ storageKey: storageBucket.storageKey });
    }
  }
  async loadCacheNames(storageBucket) {
    const response = await this.cacheAgent.invoke_requestCacheNames({ storageBucket });
    if (response.getError()) {
      return;
    }
    this.updateCacheNames(storageBucket, response.caches);
  }
  updateCacheNames(storageBucket, cachesJson) {
    function deleteAndSaveOldCaches(cache) {
      if (cache.inBucket(storageBucket) && !updatingCachesIds.has(cache.cacheId)) {
        oldCaches.set(cache.cacheId, cache);
        this.#cachesInternal.delete(cache.cacheId);
      }
    }
    const updatingCachesIds = /* @__PURE__ */ new Set();
    const newCaches = /* @__PURE__ */ new Map();
    const oldCaches = /* @__PURE__ */ new Map();
    for (const cacheJson of cachesJson) {
      const storageBucket2 = cacheJson.storageBucket ?? this.#storageBucketModel.getDefaultBucketForStorageKey(cacheJson.storageKey)?.bucket;
      if (!storageBucket2) {
        continue;
      }
      const cache = new Cache(this, storageBucket2, cacheJson.cacheName, cacheJson.cacheId);
      updatingCachesIds.add(cache.cacheId);
      if (this.#cachesInternal.has(cache.cacheId)) {
        continue;
      }
      newCaches.set(cache.cacheId, cache);
      this.#cachesInternal.set(cache.cacheId, cache);
    }
    this.#cachesInternal.forEach(deleteAndSaveOldCaches, this);
    newCaches.forEach(this.cacheAdded, this);
    oldCaches.forEach(this.cacheRemoved, this);
  }
  storageBucketAdded({ data: { bucketInfo: { bucket } } }) {
    this.addStorageBucket(bucket);
  }
  storageBucketRemoved({ data: { bucketInfo: { bucket } } }) {
    this.removeStorageBucket(bucket);
  }
  cacheAdded(cache) {
    this.dispatchEventToListeners("CacheAdded", { model: this, cache });
  }
  cacheRemoved(cache) {
    this.dispatchEventToListeners("CacheRemoved", { model: this, cache });
  }
  async requestEntries(cache, skipCount, pageSize, pathFilter, callback) {
    const response = await this.cacheAgent.invoke_requestEntries({ cacheId: cache.cacheId, skipCount, pageSize, pathFilter });
    if (response.getError()) {
      console.error("ServiceWorkerCacheAgent error while requesting entries: ", response.getError());
      return;
    }
    callback(response.cacheDataEntries, response.returnCount);
  }
  async requestAllEntries(cache, pathFilter, callback) {
    const response = await this.cacheAgent.invoke_requestEntries({ cacheId: cache.cacheId, pathFilter });
    if (response.getError()) {
      console.error("ServiceWorkerCacheAgent error while requesting entries: ", response.getError());
      return;
    }
    callback(response.cacheDataEntries, response.returnCount);
  }
  cacheStorageListUpdated({ bucketId }) {
    const storageBucket = this.#storageBucketModel.getBucketById(bucketId)?.bucket;
    if (storageBucket) {
      this.#storageBucketsUpdated.add(storageBucket);
      void this.#throttler.schedule(
        () => {
          const promises = Array.from(this.#storageBucketsUpdated, (storageBucket2) => this.loadCacheNames(storageBucket2));
          this.#storageBucketsUpdated.clear();
          return Promise.all(promises);
        },
        this.#scheduleAsSoonAsPossible ? Common35.Throttler.Scheduling.AS_SOON_AS_POSSIBLE : Common35.Throttler.Scheduling.DEFAULT
      );
    }
  }
  cacheStorageContentUpdated({ bucketId, cacheName }) {
    const storageBucket = this.#storageBucketModel.getBucketById(bucketId)?.bucket;
    if (storageBucket) {
      this.dispatchEventToListeners("CacheStorageContentUpdated", { storageBucket, cacheName });
    }
  }
  attributionReportingTriggerRegistered(_event) {
  }
  indexedDBListUpdated(_event) {
  }
  indexedDBContentUpdated(_event) {
  }
  interestGroupAuctionEventOccurred(_event) {
  }
  interestGroupAccessed(_event) {
  }
  interestGroupAuctionNetworkRequestCreated(_event) {
  }
  sharedStorageAccessed(_event) {
  }
  storageBucketCreatedOrUpdated(_event) {
  }
  storageBucketDeleted(_event) {
  }
  setThrottlerSchedulesAsSoonAsPossibleForTest() {
    this.#scheduleAsSoonAsPossible = true;
  }
  attributionReportingSourceRegistered(_event) {
  }
};
var Events30 = /* @__PURE__ */ ((Events210) => {
  Events210["CACHE_ADDED"] = "CacheAdded";
  Events210["CACHE_REMOVED"] = "CacheRemoved";
  Events210["CACHE_STORAGE_CONTENT_UPDATED"] = "CacheStorageContentUpdated";
  return Events210;
})(Events30 || {});
var Cache = class {
  #model;
  storageKey;
  storageBucket;
  cacheName;
  cacheId;
  constructor(model, storageBucket, cacheName, cacheId) {
    this.#model = model;
    this.storageBucket = storageBucket;
    this.storageKey = storageBucket.storageKey;
    this.cacheName = cacheName;
    this.cacheId = cacheId;
  }
  inBucket(storageBucket) {
    return this.storageKey === storageBucket.storageKey && this.storageBucket.name === storageBucket.name;
  }
  equals(cache) {
    return this.cacheId === cache.cacheId;
  }
  toString() {
    return this.storageKey + this.cacheName;
  }
  async requestCachedResponse(url, requestHeaders) {
    const response = await this.#model.cacheAgent.invoke_requestCachedResponse(
      { cacheId: this.cacheId, requestURL: url, requestHeaders }
    );
    if (response.getError()) {
      return null;
    }
    return response.response;
  }
};
SDKModel.register(ServiceWorkerCacheModel, { capabilities: Capability.STORAGE, autostart: false });

// gen/front_end/core/sdk/ServiceWorkerManager.js
var ServiceWorkerManager_exports = {};
__export(ServiceWorkerManager_exports, {
  Events: () => Events31,
  ServiceWorkerManager: () => ServiceWorkerManager,
  ServiceWorkerRegistration: () => ServiceWorkerRegistration,
  ServiceWorkerRouterRule: () => ServiceWorkerRouterRule,
  ServiceWorkerVersion: () => ServiceWorkerVersion,
  ServiceWorkerVersionState: () => ServiceWorkerVersionState
});
import * as Common36 from "./../common/common.js";
import * as i18n33 from "./../i18n/i18n.js";
var UIStrings15 = {
  /**
   *@description Service worker running status displayed in the Service Workers view in the Application panel
   */
  running: "running",
  /**
   *@description Service worker running status displayed in the Service Workers view in the Application panel
   */
  starting: "starting",
  /**
   *@description Service worker running status displayed in the Service Workers view in the Application panel
   */
  stopped: "stopped",
  /**
   *@description Service worker running status displayed in the Service Workers view in the Application panel
   */
  stopping: "stopping",
  /**
   *@description Service worker version status displayed in the Threads view of the Debugging side pane in the Sources panel
   */
  activated: "activated",
  /**
   *@description Service worker version status displayed in the Threads view of the Debugging side pane in the Sources panel
   */
  activating: "activating",
  /**
   *@description Service worker version status displayed in the Threads view of the Debugging side pane in the Sources panel
   */
  installed: "installed",
  /**
   *@description Service worker version status displayed in the Threads view of the Debugging side pane in the Sources panel
   */
  installing: "installing",
  /**
   *@description Service worker version status displayed in the Threads view of the Debugging side pane in the Sources panel
   */
  new: "new",
  /**
   *@description Service worker version status displayed in the Threads view of the Debugging side pane in the Sources panel
   */
  redundant: "redundant",
  /**
   *@description Service worker version status displayed in the Threads view of the Debugging side pane in the Sources panel
   *@example {sw.js} PH1
   *@example {117} PH2
   *@example {activated} PH3
   */
  sSS: "{PH1} #{PH2} ({PH3})"
};
var str_15 = i18n33.i18n.registerUIStrings("core/sdk/ServiceWorkerManager.ts", UIStrings15);
var i18nString15 = i18n33.i18n.getLocalizedString.bind(void 0, str_15);
var i18nLazyString2 = i18n33.i18n.getLazilyComputedLocalizedString.bind(void 0, str_15);
var ServiceWorkerManager = class extends SDKModel {
  #agent;
  #registrationsInternal;
  #enabled;
  #forceUpdateSetting;
  serviceWorkerNetworkRequestsPanelStatus;
  constructor(target) {
    super(target);
    target.registerServiceWorkerDispatcher(new ServiceWorkerDispatcher(this));
    this.#agent = target.serviceWorkerAgent();
    this.#registrationsInternal = /* @__PURE__ */ new Map();
    this.#enabled = false;
    void this.enable();
    this.#forceUpdateSetting = Common36.Settings.Settings.instance().createSetting("service-worker-update-on-reload", false);
    if (this.#forceUpdateSetting.get()) {
      this.forceUpdateSettingChanged();
    }
    this.#forceUpdateSetting.addChangeListener(this.forceUpdateSettingChanged, this);
    new ServiceWorkerContextNamer(target, this);
    this.serviceWorkerNetworkRequestsPanelStatus = {
      isOpen: false,
      openedAt: 0
    };
  }
  async enable() {
    if (this.#enabled) {
      return;
    }
    this.#enabled = true;
    await this.#agent.invoke_enable();
  }
  async disable() {
    if (!this.#enabled) {
      return;
    }
    this.#enabled = false;
    this.#registrationsInternal.clear();
    await this.#agent.invoke_enable();
  }
  registrations() {
    return this.#registrationsInternal;
  }
  hasRegistrationForURLs(urls) {
    for (const registration of this.#registrationsInternal.values()) {
      if (urls.filter((url) => url && url.startsWith(registration.scopeURL)).length === urls.length) {
        return true;
      }
    }
    return false;
  }
  findVersion(versionId) {
    for (const registration of this.registrations().values()) {
      const version = registration.versions.get(versionId);
      if (version) {
        return version;
      }
    }
    return null;
  }
  deleteRegistration(registrationId) {
    const registration = this.#registrationsInternal.get(registrationId);
    if (!registration) {
      return;
    }
    if (registration.isRedundant()) {
      this.#registrationsInternal.delete(registrationId);
      this.dispatchEventToListeners("RegistrationDeleted", registration);
      return;
    }
    registration.deleting = true;
    for (const version of registration.versions.values()) {
      void this.stopWorker(version.id);
    }
    void this.unregister(registration.scopeURL);
  }
  async updateRegistration(registrationId) {
    const registration = this.#registrationsInternal.get(registrationId);
    if (!registration) {
      return;
    }
    await this.#agent.invoke_updateRegistration({ scopeURL: registration.scopeURL });
  }
  async deliverPushMessage(registrationId, data) {
    const registration = this.#registrationsInternal.get(registrationId);
    if (!registration) {
      return;
    }
    const origin = Common36.ParsedURL.ParsedURL.extractOrigin(registration.scopeURL);
    await this.#agent.invoke_deliverPushMessage({ origin, registrationId, data });
  }
  async dispatchSyncEvent(registrationId, tag, lastChance) {
    const registration = this.#registrationsInternal.get(registrationId);
    if (!registration) {
      return;
    }
    const origin = Common36.ParsedURL.ParsedURL.extractOrigin(registration.scopeURL);
    await this.#agent.invoke_dispatchSyncEvent({ origin, registrationId, tag, lastChance });
  }
  async dispatchPeriodicSyncEvent(registrationId, tag) {
    const registration = this.#registrationsInternal.get(registrationId);
    if (!registration) {
      return;
    }
    const origin = Common36.ParsedURL.ParsedURL.extractOrigin(registration.scopeURL);
    await this.#agent.invoke_dispatchPeriodicSyncEvent({ origin, registrationId, tag });
  }
  async unregister(scopeURL) {
    await this.#agent.invoke_unregister({ scopeURL });
  }
  async startWorker(scopeURL) {
    await this.#agent.invoke_startWorker({ scopeURL });
  }
  async skipWaiting(scopeURL) {
    await this.#agent.invoke_skipWaiting({ scopeURL });
  }
  async stopWorker(versionId) {
    await this.#agent.invoke_stopWorker({ versionId });
  }
  async inspectWorker(versionId) {
    await this.#agent.invoke_inspectWorker({ versionId });
  }
  workerRegistrationUpdated(registrations) {
    for (const payload of registrations) {
      let registration = this.#registrationsInternal.get(payload.registrationId);
      if (!registration) {
        registration = new ServiceWorkerRegistration(payload);
        this.#registrationsInternal.set(payload.registrationId, registration);
        this.dispatchEventToListeners("RegistrationUpdated", registration);
        continue;
      }
      registration.update(payload);
      if (registration.shouldBeRemoved()) {
        this.#registrationsInternal.delete(registration.id);
        this.dispatchEventToListeners("RegistrationDeleted", registration);
      } else {
        this.dispatchEventToListeners("RegistrationUpdated", registration);
      }
    }
  }
  workerVersionUpdated(versions) {
    const registrations = /* @__PURE__ */ new Set();
    for (const payload of versions) {
      const registration = this.#registrationsInternal.get(payload.registrationId);
      if (!registration) {
        continue;
      }
      registration.updateVersion(payload);
      registrations.add(registration);
    }
    for (const registration of registrations) {
      if (registration.shouldBeRemoved()) {
        this.#registrationsInternal.delete(registration.id);
        this.dispatchEventToListeners("RegistrationDeleted", registration);
      } else {
        this.dispatchEventToListeners("RegistrationUpdated", registration);
      }
    }
  }
  workerErrorReported(payload) {
    const registration = this.#registrationsInternal.get(payload.registrationId);
    if (!registration) {
      return;
    }
    registration.errors.push(payload);
    this.dispatchEventToListeners("RegistrationErrorAdded", { registration, error: payload });
  }
  forceUpdateOnReloadSetting() {
    return this.#forceUpdateSetting;
  }
  forceUpdateSettingChanged() {
    const forceUpdateOnPageLoad = this.#forceUpdateSetting.get();
    void this.#agent.invoke_setForceUpdateOnPageLoad({ forceUpdateOnPageLoad });
  }
};
var Events31 = /* @__PURE__ */ ((Events210) => {
  Events210["REGISTRATION_UPDATED"] = "RegistrationUpdated";
  Events210["REGISTRATION_ERROR_ADDED"] = "RegistrationErrorAdded";
  Events210["REGISTRATION_DELETED"] = "RegistrationDeleted";
  return Events210;
})(Events31 || {});
var ServiceWorkerDispatcher = class {
  #manager;
  constructor(manager) {
    this.#manager = manager;
  }
  workerRegistrationUpdated({ registrations }) {
    this.#manager.workerRegistrationUpdated(registrations);
  }
  workerVersionUpdated({ versions }) {
    this.#manager.workerVersionUpdated(versions);
  }
  workerErrorReported({ errorMessage }) {
    this.#manager.workerErrorReported(errorMessage);
  }
};
var ServiceWorkerVersionState = class {
  runningStatus;
  status;
  lastUpdatedTimestamp;
  previousState;
  constructor(runningStatus, status, previousState, timestamp) {
    this.runningStatus = runningStatus;
    this.status = status;
    this.lastUpdatedTimestamp = timestamp;
    this.previousState = previousState;
  }
};
var ServiceWorkerRouterRule = class {
  condition;
  source;
  id;
  constructor(condition, source, id) {
    this.condition = condition;
    this.source = source;
    this.id = id;
  }
};
var ServiceWorkerVersion = class _ServiceWorkerVersion {
  id;
  scriptURL;
  parsedURL;
  securityOrigin;
  scriptLastModified;
  scriptResponseTime;
  controlledClients;
  targetId;
  routerRules;
  currentState;
  registration;
  constructor(registration, payload) {
    this.registration = registration;
    this.update(payload);
  }
  update(payload) {
    this.id = payload.versionId;
    this.scriptURL = payload.scriptURL;
    const parsedURL = new Common36.ParsedURL.ParsedURL(payload.scriptURL);
    this.securityOrigin = parsedURL.securityOrigin();
    this.currentState = new ServiceWorkerVersionState(payload.runningStatus, payload.status, this.currentState, Date.now());
    this.scriptLastModified = payload.scriptLastModified;
    this.scriptResponseTime = payload.scriptResponseTime;
    if (payload.controlledClients) {
      this.controlledClients = payload.controlledClients.slice();
    } else {
      this.controlledClients = [];
    }
    this.targetId = payload.targetId || null;
    this.routerRules = null;
    if (payload.routerRules) {
      this.routerRules = this.parseJSONRules(payload.routerRules);
    }
  }
  isStartable() {
    return !this.registration.isDeleted && this.isActivated() && this.isStopped();
  }
  isStoppedAndRedundant() {
    return this.runningStatus === ServiceWorker.ServiceWorkerVersionRunningStatus.Stopped && this.status === ServiceWorker.ServiceWorkerVersionStatus.Redundant;
  }
  isStopped() {
    return this.runningStatus === ServiceWorker.ServiceWorkerVersionRunningStatus.Stopped;
  }
  isStarting() {
    return this.runningStatus === ServiceWorker.ServiceWorkerVersionRunningStatus.Starting;
  }
  isRunning() {
    return this.runningStatus === ServiceWorker.ServiceWorkerVersionRunningStatus.Running;
  }
  isStopping() {
    return this.runningStatus === ServiceWorker.ServiceWorkerVersionRunningStatus.Stopping;
  }
  isNew() {
    return this.status === ServiceWorker.ServiceWorkerVersionStatus.New;
  }
  isInstalling() {
    return this.status === ServiceWorker.ServiceWorkerVersionStatus.Installing;
  }
  isInstalled() {
    return this.status === ServiceWorker.ServiceWorkerVersionStatus.Installed;
  }
  isActivating() {
    return this.status === ServiceWorker.ServiceWorkerVersionStatus.Activating;
  }
  isActivated() {
    return this.status === ServiceWorker.ServiceWorkerVersionStatus.Activated;
  }
  isRedundant() {
    return this.status === ServiceWorker.ServiceWorkerVersionStatus.Redundant;
  }
  get status() {
    return this.currentState.status;
  }
  get runningStatus() {
    return this.currentState.runningStatus;
  }
  mode() {
    if (this.isNew() || this.isInstalling()) {
      return _ServiceWorkerVersion.Modes.INSTALLING;
    }
    if (this.isInstalled()) {
      return _ServiceWorkerVersion.Modes.WAITING;
    }
    if (this.isActivating() || this.isActivated()) {
      return _ServiceWorkerVersion.Modes.ACTIVE;
    }
    return _ServiceWorkerVersion.Modes.REDUNDANT;
  }
  parseJSONRules(input) {
    try {
      const parsedObject = JSON.parse(input);
      if (!Array.isArray(parsedObject)) {
        console.error("Parse error: `routerRules` in ServiceWorkerVersion should be an array");
        return null;
      }
      const routerRules = [];
      for (const parsedRule of parsedObject) {
        const { condition, source, id } = parsedRule;
        if (condition === void 0 || source === void 0 || id === void 0) {
          console.error("Parse error: Missing some fields of `routerRules` in ServiceWorkerVersion");
          return null;
        }
        routerRules.push(new ServiceWorkerRouterRule(JSON.stringify(condition), JSON.stringify(source), id));
      }
      return routerRules;
    } catch (e) {
      console.error("Parse error: Invalid `routerRules` in ServiceWorkerVersion");
      return null;
    }
  }
};
((ServiceWorkerVersion2) => {
  ServiceWorkerVersion2.RunningStatus = {
    [ServiceWorker.ServiceWorkerVersionRunningStatus.Running]: i18nLazyString2(UIStrings15.running),
    [ServiceWorker.ServiceWorkerVersionRunningStatus.Starting]: i18nLazyString2(UIStrings15.starting),
    [ServiceWorker.ServiceWorkerVersionRunningStatus.Stopped]: i18nLazyString2(UIStrings15.stopped),
    [ServiceWorker.ServiceWorkerVersionRunningStatus.Stopping]: i18nLazyString2(UIStrings15.stopping)
  };
  ServiceWorkerVersion2.Status = {
    [ServiceWorker.ServiceWorkerVersionStatus.Activated]: i18nLazyString2(UIStrings15.activated),
    [ServiceWorker.ServiceWorkerVersionStatus.Activating]: i18nLazyString2(UIStrings15.activating),
    [ServiceWorker.ServiceWorkerVersionStatus.Installed]: i18nLazyString2(UIStrings15.installed),
    [ServiceWorker.ServiceWorkerVersionStatus.Installing]: i18nLazyString2(UIStrings15.installing),
    [ServiceWorker.ServiceWorkerVersionStatus.New]: i18nLazyString2(UIStrings15.new),
    [ServiceWorker.ServiceWorkerVersionStatus.Redundant]: i18nLazyString2(UIStrings15.redundant)
  };
  let Modes;
  ((Modes2) => {
    Modes2["INSTALLING"] = "installing";
    Modes2["WAITING"] = "waiting";
    Modes2["ACTIVE"] = "active";
    Modes2["REDUNDANT"] = "redundant";
  })(Modes = ServiceWorkerVersion2.Modes || (ServiceWorkerVersion2.Modes = {}));
})(ServiceWorkerVersion || (ServiceWorkerVersion = {}));
var ServiceWorkerRegistration = class {
  #fingerprintInternal;
  id;
  scopeURL;
  securityOrigin;
  isDeleted;
  versions;
  deleting;
  errors;
  constructor(payload) {
    this.update(payload);
    this.versions = /* @__PURE__ */ new Map();
    this.deleting = false;
    this.errors = [];
  }
  update(payload) {
    this.#fingerprintInternal = Symbol("fingerprint");
    this.id = payload.registrationId;
    this.scopeURL = payload.scopeURL;
    const parsedURL = new Common36.ParsedURL.ParsedURL(payload.scopeURL);
    this.securityOrigin = parsedURL.securityOrigin();
    this.isDeleted = payload.isDeleted;
  }
  fingerprint() {
    return this.#fingerprintInternal;
  }
  versionsByMode() {
    const result = /* @__PURE__ */ new Map();
    for (const version of this.versions.values()) {
      result.set(version.mode(), version);
    }
    return result;
  }
  updateVersion(payload) {
    this.#fingerprintInternal = Symbol("fingerprint");
    let version = this.versions.get(payload.versionId);
    if (!version) {
      version = new ServiceWorkerVersion(this, payload);
      this.versions.set(payload.versionId, version);
      return version;
    }
    version.update(payload);
    return version;
  }
  isRedundant() {
    for (const version of this.versions.values()) {
      if (!version.isStoppedAndRedundant()) {
        return false;
      }
    }
    return true;
  }
  shouldBeRemoved() {
    return this.isRedundant() && (!this.errors.length || this.deleting);
  }
  canBeRemoved() {
    return this.isDeleted || this.deleting;
  }
  clearErrors() {
    this.#fingerprintInternal = Symbol("fingerprint");
    this.errors = [];
  }
};
var ServiceWorkerContextNamer = class {
  #target;
  #serviceWorkerManager;
  #versionByTargetId;
  constructor(target, serviceWorkerManager) {
    this.#target = target;
    this.#serviceWorkerManager = serviceWorkerManager;
    this.#versionByTargetId = /* @__PURE__ */ new Map();
    serviceWorkerManager.addEventListener("RegistrationUpdated", this.registrationsUpdated, this);
    serviceWorkerManager.addEventListener("RegistrationDeleted", this.registrationsUpdated, this);
    TargetManager.instance().addModelListener(
      RuntimeModel,
      Events10.ExecutionContextCreated,
      this.executionContextCreated,
      this
    );
  }
  registrationsUpdated() {
    this.#versionByTargetId.clear();
    const registrations = this.#serviceWorkerManager.registrations().values();
    for (const registration of registrations) {
      for (const version of registration.versions.values()) {
        if (version.targetId) {
          this.#versionByTargetId.set(version.targetId, version);
        }
      }
    }
    this.updateAllContextLabels();
  }
  executionContextCreated(event) {
    const executionContext = event.data;
    const serviceWorkerTargetId = this.serviceWorkerTargetId(executionContext.target());
    if (!serviceWorkerTargetId) {
      return;
    }
    this.updateContextLabel(executionContext, this.#versionByTargetId.get(serviceWorkerTargetId) || null);
  }
  serviceWorkerTargetId(target) {
    if (target.parentTarget() !== this.#target || target.type() !== Type2.ServiceWorker) {
      return null;
    }
    return target.id();
  }
  updateAllContextLabels() {
    for (const target of TargetManager.instance().targets()) {
      const serviceWorkerTargetId = this.serviceWorkerTargetId(target);
      if (!serviceWorkerTargetId) {
        continue;
      }
      const version = this.#versionByTargetId.get(serviceWorkerTargetId) || null;
      const runtimeModel = target.model(RuntimeModel);
      const executionContexts = runtimeModel ? runtimeModel.executionContexts() : [];
      for (const context of executionContexts) {
        this.updateContextLabel(context, version);
      }
    }
  }
  updateContextLabel(context, version) {
    if (!version) {
      context.setLabel("");
      return;
    }
    const parsedUrl = Common36.ParsedURL.ParsedURL.fromString(context.origin);
    const label = parsedUrl ? parsedUrl.lastPathComponentWithFragment() : context.name;
    const localizedStatus = ServiceWorkerVersion.Status[version.status];
    context.setLabel(i18nString15(UIStrings15.sSS, { PH1: label, PH2: version.id, PH3: localizedStatus() }));
  }
};
SDKModel.register(ServiceWorkerManager, { capabilities: Capability.SERVICE_WORKER, autostart: true });

// gen/front_end/core/sdk/TraceObject.js
var TraceObject_exports = {};
__export(TraceObject_exports, {
  RevealableEvent: () => RevealableEvent,
  TraceObject: () => TraceObject
});
var TraceObject = class {
  traceEvents;
  metadata;
  constructor(traceEvents, metadata = {}) {
    this.traceEvents = traceEvents;
    this.metadata = metadata;
  }
};
var RevealableEvent = class {
  // Only Trace.Types.Events.Event are passed in, but we can't depend on that type from SDK
  /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
  constructor(event) {
    this.event = event;
  }
};

// gen/front_end/core/sdk/WebAuthnModel.js
var WebAuthnModel_exports = {};
__export(WebAuthnModel_exports, {
  Events: () => Events32,
  WebAuthnModel: () => WebAuthnModel
});
var Events32 = /* @__PURE__ */ ((Events210) => {
  Events210["CREDENTIAL_ADDED"] = "CredentialAdded";
  Events210["CREDENTIAL_ASSERTED"] = "CredentialAsserted";
  Events210["CREDENTIAL_DELETED"] = "CredentialDeleted";
  Events210["CREDENTIAL_UPDATED"] = "CredentialUpdated";
  return Events210;
})(Events32 || {});
var WebAuthnModel = class extends SDKModel {
  #agent;
  constructor(target) {
    super(target);
    this.#agent = target.webAuthnAgent();
    target.registerWebAuthnDispatcher(new WebAuthnDispatcher(this));
  }
  setVirtualAuthEnvEnabled(enable) {
    if (enable) {
      return this.#agent.invoke_enable({ enableUI: true });
    }
    return this.#agent.invoke_disable();
  }
  async addAuthenticator(options) {
    const response = await this.#agent.invoke_addVirtualAuthenticator({ options });
    return response.authenticatorId;
  }
  async removeAuthenticator(authenticatorId) {
    await this.#agent.invoke_removeVirtualAuthenticator({ authenticatorId });
  }
  async setAutomaticPresenceSimulation(authenticatorId, enabled) {
    await this.#agent.invoke_setAutomaticPresenceSimulation({ authenticatorId, enabled });
  }
  async getCredentials(authenticatorId) {
    const response = await this.#agent.invoke_getCredentials({ authenticatorId });
    return response.credentials;
  }
  async removeCredential(authenticatorId, credentialId) {
    await this.#agent.invoke_removeCredential({ authenticatorId, credentialId });
  }
  credentialAdded(params) {
    this.dispatchEventToListeners("CredentialAdded", params);
  }
  credentialAsserted(params) {
    this.dispatchEventToListeners("CredentialAsserted", params);
  }
  credentialDeleted(params) {
    this.dispatchEventToListeners("CredentialDeleted", params);
  }
  credentialUpdated(params) {
    this.dispatchEventToListeners("CredentialUpdated", params);
  }
};
var WebAuthnDispatcher = class {
  #model;
  constructor(model) {
    this.#model = model;
  }
  credentialAdded(params) {
    this.#model.credentialAdded(params);
  }
  credentialAsserted(params) {
    this.#model.credentialAsserted(params);
  }
  credentialDeleted(params) {
    this.#model.credentialDeleted(params);
  }
  credentialUpdated(params) {
    this.#model.credentialUpdated(params);
  }
};
SDKModel.register(WebAuthnModel, { capabilities: Capability.WEB_AUTHN, autostart: false });
export {
  AccessibilityModel_exports as AccessibilityModel,
  AnimationModel_exports as AnimationModel,
  AutofillModel_exports as AutofillModel,
  CPUProfileDataModel_exports as CPUProfileDataModel,
  CPUProfilerModel_exports as CPUProfilerModel,
  CPUThrottlingManager_exports as CPUThrottlingManager,
  CSSContainerQuery_exports as CSSContainerQuery,
  CSSFontFace_exports as CSSFontFace,
  CSSLayer_exports as CSSLayer,
  CSSMatchedStyles_exports as CSSMatchedStyles,
  CSSMedia_exports as CSSMedia,
  CSSMetadata_exports as CSSMetadata,
  CSSModel_exports as CSSModel,
  CSSProperty_exports as CSSProperty,
  CSSPropertyParser_exports as CSSPropertyParser,
  CSSQuery_exports as CSSQuery,
  CSSRule_exports as CSSRule,
  CSSScope_exports as CSSScope,
  CSSStyleDeclaration_exports as CSSStyleDeclaration,
  CSSStyleSheetHeader_exports as CSSStyleSheetHeader,
  CSSSupports_exports as CSSSupports,
  CategorizedBreakpoint_exports as CategorizedBreakpoint,
  ChildTargetManager_exports as ChildTargetManager,
  CompilerSourceMappingContentProvider_exports as CompilerSourceMappingContentProvider,
  Connections_exports as Connections,
  ConsoleModel_exports as ConsoleModel,
  Cookie_exports as Cookie,
  CookieModel_exports as CookieModel,
  CookieParser_exports as CookieParser,
  DOMDebuggerModel_exports as DOMDebuggerModel,
  DOMModel_exports as DOMModel,
  DebuggerModel_exports as DebuggerModel,
  EmulationModel_exports as EmulationModel,
  EnhancedTracesParser_exports as EnhancedTracesParser,
  EventBreakpointsModel_exports as EventBreakpointsModel,
  FrameAssociated,
  FrameManager_exports as FrameManager,
  HeapProfilerModel_exports as HeapProfilerModel,
  IOModel_exports as IOModel,
  IsolateManager_exports as IsolateManager,
  IssuesModel_exports as IssuesModel,
  LayerTreeBase_exports as LayerTreeBase,
  LogModel_exports as LogModel,
  NetworkManager_exports as NetworkManager,
  NetworkRequest_exports as NetworkRequest,
  OverlayColorGenerator_exports as OverlayColorGenerator,
  OverlayModel_exports as OverlayModel,
  OverlayPersistentHighlighter_exports as OverlayPersistentHighlighter,
  PageLoad_exports as PageLoad,
  PageResourceLoader_exports as PageResourceLoader,
  PaintProfiler_exports as PaintProfiler,
  PerformanceMetricsModel_exports as PerformanceMetricsModel,
  PreloadingModel_exports as PreloadingModel,
  ProfileTreeModel_exports as ProfileTreeModel,
  RemoteObject_exports as RemoteObject,
  Resource_exports as Resource,
  ResourceTreeModel_exports as ResourceTreeModel,
  RuntimeModel_exports as RuntimeModel,
  SDKModel_exports as SDKModel,
  ScreenCaptureModel_exports as ScreenCaptureModel,
  Script_exports as Script,
  SecurityOriginManager_exports as SecurityOriginManager,
  ServerSentEventsProtocol_exports as ServerSentEventProtocol,
  ServerTiming_exports as ServerTiming,
  ServiceWorkerCacheModel_exports as ServiceWorkerCacheModel,
  ServiceWorkerManager_exports as ServiceWorkerManager,
  SourceMap_exports as SourceMap,
  SourceMapManager_exports as SourceMapManager,
  SourceMapScopeChainEntry_exports as SourceMapScopeChainEntry,
  SourceMapScopes_exports as SourceMapScopes,
  SourceMapScopesInfo_exports as SourceMapScopesInfo,
  StorageBucketsModel_exports as StorageBucketsModel,
  StorageKeyManager_exports as StorageKeyManager,
  Target_exports as Target,
  TargetManager_exports as TargetManager,
  TraceObject_exports as TraceObject,
  WebAuthnModel_exports as WebAuthnModel
};
